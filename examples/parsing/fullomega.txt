(if (ref (ref (ref "apple"))) then ({ * ({ Some C : Star , Float }) , (! (if unit then "apple" else "apple")) } as (Ref Bool)) else ((unit [ (Ref Bool) ]) ((if 0 then c else "boy") [ ({ Some E : Star , A }) ])))
(if (\ E : ((Star => Star) => Star) . (b . b)) then (({ * Nat , 2 } as Float) [ (All A : (Star => Star) . (Ref Nat)) ]) else (pred (let e = false in a)))
((ref (if (fix a) then ({ e = "apple" , e = false }) else b)) . c)
(pred ((\ A : Star . (b b)) as ({ e : C , a : ({ d : Unit , a : Float }) })))
(iszero (fix (0 as ({ Some C : Star , Float }))))
(succ (((ref 0) as (Ref C)) [ (String -> ({ b : Float , a : B })) ]))
(let e = (succ (if c then (1 as Unit) else (succ 0))) in ({ * (Ref Unit) , ({ b = (if 2 then 1 else false) , d = true }) } as (Ref C)))
(\ D : (((Star => Star) => Star) => (Star => Star)) . (({ a = false , b = "apple" }) [ ({ Some D : Star , Float }) ]))
(iszero ((\ c : Float . a) as ({ e : (Ref B) , d : Bool })))
(pred ({ e = (\ c : ({ e : String , c : A }) . (fix false)) , a = (true [ ({ c : Float , e : Bool }) ]) }))
((fix (a (\ A : Star . 1))) [ ((({ Some B : Star , Nat }) (All D : Star . Unit)) -> ({ d : Nat , e : String })) ])
({ b = (let { A , d } = (ref (! (ref "boy"))) in (\ E : Star . 1)) , e = ({ * (All D : Star . B) , (pred 2) } as (({ Some D : Star , C }) String)) })
(let { C , e } = ((ref (c "apple")) (let { B , a } = c in false)) in (pred (! ({ * B , 2 } as Float))))
(\ c : ((All B : ((Star => Star) => Star) . (A -> ({ c : Float , b : Nat }))) ({ Some C : ((Star => Star) => Star) , ({ c : Bool , a : (\ A : Star . Unit) }) })) . (let b = (succ "apple") in (let { C , b } = c in 0)))
(succ ({ * (All C : Star . ({ Some D : Star , String })) , (\ B : (Star => (Star => Star)) . (\ d : String . "boy")) } as ({ c : (\ C : Star . (Unit -> String)) , c : (A -> B) })))
(fix (let c = (let { C , d } = (! "apple") in b) in (let { B , a } = ({ * Unit , 1 } as String) in (fix 2))))
({ * (({ e : (Unit Nat) , c : (B -> Bool) }) (A -> Float)) , (succ (let a = ("apple" := (! true)) in ({ d = b , a = true }))) } as (All B : (Star => Star) . ({ c : (Bool -> A) , d : Nat })))
(succ (! (succ (succ unit))))
(\ e : ({ Some B : (Star => Star) , (All C : (Star => Star) . Unit) }) . ((\ e : String . "apple") as (({ Some E : Star , Unit }) -> (String -> B))))
(if (pred ((\ A : Star . "apple") . a)) then (let { D , c } = (pred "apple") in (pred true)) else ((pred (false . e)) := (iszero ((iszero 2) as (Float -> Unit)))))
(ref (\ C : (Star => Star) . ({ d = "apple" , d = "apple" })))
(\ b : (({ Some E : (Star => Star) , (\ A : Star . Bool) }) -> (\ D : ((Star => Star) => (Star => Star)) . ({ Some A : Star , C }))) . (\ C : ((Star => Star) => (Star => Star)) . ((pred true) [ String ])))
(pred ((if (succ 2) then (2 . c) else "boy") := (! (c [ Float ]))))
(({ c = (\ b : (Ref Bool) . (let c = b in 0)) , c = (let { B , b } = (let { D , a } = false in c) in ((ref unit) := (if true then false else c))) }) as (Ref (\ B : Star . String)))
(succ (! ({ a = 1 , e = unit })))
((iszero ((\ D : (Star => Star) . (\ A : Star . unit)) as (({ d : Float , e : Unit }) -> ({ b : C , a : String })))) ({ e = ({ * (C String) , (let a = false in 1) } as (\ E : Star . C)) , a = (! (iszero 1)) }))
(fix ({ * (Ref (\ C : Star . C)) , (iszero unit) } as (All E : (Star => Star) . (\ C : Star . A))))
((\ e : (\ A : Star . Bool) . (\ a : Nat . "apple")) (succ (if unit then false else true)))
((! (succ false)) . a)
(let a = (iszero (({ * A , "boy" } as Bool) ("apple" := 1))) in (ref (false . a)))
(iszero (\ d : (\ C : Star . Float) . (2 as C)))
((fix (1 . d)) [ ((\ E : (Star => Star) . (Float -> C)) -> ((Ref Nat) (\ B : Star . (Nat String)))) ])
({ * ({ Some D : ((Star => Star) => (Star => Star)) , ({ Some C : (Star => Star) , (All A : Star . B) }) }) , (let { E , e } = (! b) in ({ * C , 0 } as Bool)) } as (\ A : (Star => (Star => Star)) . (Ref (Ref Bool))))
(pred ({ * ({ Some E : Star , String }) , (b [ (C -> Nat) ]) } as (\ B : Star . ({ a : Nat , a : Nat }))))
(({ b = (! (let { B , d } = unit in true)) , e = (let b = (if 0 then 2 else true) in (2 "boy")) }) ((2 (let { E , e } = "apple" in b)) as (All C : Star . Bool)))
(succ (ref (ref ("apple" [ Float ]))))
(\ E : ((Star => Star) => (((Star => Star) => Star) => (Star => Star))) . (fix (0 [ B ])))
((let c = (\ B : (Star => Star) . (if 0 then 1 else 1)) in (fix "apple")) . e)
(ref (let { D , b } = (c a) in (\ a : A . true)))
(fix (ref (succ a)))
({ * ({ Some B : (Star => Star) , (Unit C) }) , (\ A : (Star => (Star => Star)) . ({ * Unit , "apple" } as Unit)) } as (Ref ((Nat -> B) -> (String Nat))))
((fix (iszero ({ * String , 1 } as String))) . e)
(\ e : (Ref ({ Some B : Star , (All D : Star . A) })) . (if (\ D : Star . true) then ((! 1) . b) else (succ "apple")))
({ c = (\ b : ((String -> A) -> (Unit A)) . (ref (iszero 0))) , d = (let { D , e } = ({ * C , 0 } as Unit) in ("boy" [ Bool ])) })
(! ((\ E : (Star => Star) . (false "apple")) as (All C : (Star => Star) . (Ref C))))
((succ (fix (let { B , e } = a in a))) := (let { C , d } = (unit := "boy") in ((true [ (Ref Bool) ]) as (All A : (Star => Star) . (All B : Star . Bool)))))
(let { D , d } = (iszero (succ (fix ("boy" unit)))) in (let { C , c } = (((succ 2) . b) (let d = "boy" in false)) in (let { E , d } = 1 in a)))
(\ E : (((Star => Star) => Star) => ((Star => Star) => ((Star => Star) => (Star => Star)))) . ((succ 0) [ ({ Some E : Star , String }) ]))
(fix (let a = (succ false) in (succ 0)))
(((let e = (0 := "boy") in ("boy" "boy")) ((\ d : Unit . true) as Unit)) := ((ref (\ A : Star . unit)) . d))
(let { E , e } = (fix ("boy" . d)) in ({ b = (if (\ d : B . "boy") then (let b = "apple" in "apple") else (c := false)) , d = (1 as A) }))
(pred (\ E : (Star => Star) . (succ 2)))
(((if 1 then (\ c : C . a) else false) := (succ (b := c))) [ (((All A : Star . Nat) A) (All A : Star . (Float String))) ])
(pred (((let { E , b } = "apple" in c) as (Ref Bool)) as (Ref (\ A : Star . String))))
(\ E : ((Star => Star) => ((Star => Star) => Star)) . (\ D : ((Star => Star) => Star) . (iszero false)))
((let e = ({ * Float , (false [ Float ]) } as ({ a : A , d : Float })) in (succ (succ "apple"))) [ ((Ref (Float -> Float)) ((\ D : Star . (\ D : Star . Float)) -> (\ C : Star . B))) ])
(! (let { A , a } = (({ * Unit , 0 } as Unit) := (ref a)) in ((pred c) as (Ref Unit))))
((\ b : ({ Some C : Star , Unit }) . (let { C , d } = ("apple" := 0) in 1)) (fix (iszero c)))
((\ d : (Ref C) . ({ e = (let b = 2 in 2) , c = (pred 0) })) (\ c : (Float -> (String Float)) . (a . a)))
((fix (let d = (let { E , d } = 0 in (let c = "boy" in unit)) in (pred 1))) := ({ b = (true [ Unit ]) , c = (2 as Nat) }))
(pred ((pred (iszero 1)) (pred (ref (b . c)))))
((succ (! (2 [ Bool ]))) [ (({ c : Bool , c : C }) (C -> Bool)) ])
({ * ({ Some E : ((Star => (Star => Star)) => (Star => Star)) , (All B : ((Star => Star) => (Star => Star)) . (Ref Unit)) }) , (({ * (\ D : Star . A) , c } as ({ Some D : Star , C })) . e) } as ({ a : (({ Some C : Star , Float }) -> (Unit -> Nat)) , c : ({ e : String , b : A }) }))
(ref (let { B , b } = (0 := 0) in (iszero 0)))
(\ d : ({ b : (Ref (Ref B)) , c : ({ c : Bool , d : (B -> Bool) }) }) . ((false . b) [ (\ C : (Star => Star) . String) ]))
(pred (pred (\ d : A . "apple")))
(pred (succ (iszero (2 as (A Nat)))))
(\ d : (All C : (Star => Star) . ({ b : A , d : String })) . ({ c = (! true) , b = (pred "apple") }))
((pred (\ C : Star . false)) := ((succ (! false)) := (pred false)))
(succ ({ b = (if "boy" then true else "apple") , d = (iszero "boy") }))
((\ a : (({ c : String , b : Float }) (C C)) . (let { B , c } = (pred unit) in (iszero b))) . d)
(if (fix (pred a)) then ({ * (Ref Bool) , (let { C , e } = a in c) } as (String -> (Float -> Bool))) else (iszero ((c := c) . a)))
(succ ((\ d : Float . "apple") (let { A , b } = 2 in b)))
((if ({ * (Ref Float) , 2 } as B) then ({ * Float , b } as (C String)) else (false true)) := (let { D , d } = (succ 2) in (pred (succ 1))))
(((b (false . c)) := ({ d = c , a = unit })) as ({ Some D : (Star => Star) , (All D : Star . B) }))
(pred ((\ e : Bool . (! b)) ((iszero 2) [ B ])))
(pred ((\ e : ({ a : Float , d : Unit }) . ({ * Float , "apple" } as B)) . d))
(\ D : ((Star => Star) => (Star => Star)) . ({ * ({ d : (({ a : C , b : String }) -> Nat) , b : ({ Some C : Star , (Ref C) }) }) , (iszero ({ b = "boy" , a = false })) } as (\ B : (Star => Star) . ({ Some C : (Star => Star) , String }))))
(iszero ((fix (! c)) . d))
((fix (succ unit)) := ((\ E : Star . "apple") := (if unit then true else "boy")))
(let { A , b } = (\ A : (Star => Star) . (let c = false in (succ c))) in (ref (2 as String)))
(pred ((ref true) ("apple" as B)))
((pred (unit true)) . a)
({ c = ({ e = (if c then a else false) , c = (iszero 0) }) , c = (fix ((pred 0) as C)) })
({ a = (succ (succ 0)) , a = (ref (fix 2)) })
(pred (ref ((false a) as ({ e : C , d : A }))))
(! ((let { A , a } = a in unit) := (iszero "boy")))
(succ (let { B , c } = (if b then "boy" else unit) in (\ e : (Float -> Unit) . (b as Bool))))
(pred (if (\ A : (Star => Star) . (\ B : Star . 1)) then (let { D , e } = (\ C : Star . c) in (let d = b in a)) else ((b 0) as (Nat -> Float))))
((! (! (let { C , c } = a in a))) as ({ Some A : (Star => Star) , (\ B : Star . C) }))
(iszero ({ * ({ Some B : (Star => Star) , (All D : Star . C) }) , (ref unit) } as (\ C : (Star => Star) . (Ref Nat))))
(if (ref (let d = (let b = b in b) in (if unit then ({ c = c , b = true }) else 0))) then (let { B , b } = ((ref "apple") as (\ B : (Star => Star) . Float)) in ((unit as ({ e : Unit , a : Unit })) [ ({ Some E : Star , A }) ])) else (pred (pred 1)))
({ a = (! (b as Unit)) , b = ({ b = ((\ b : Float . true) (ref "apple")) , b = ((ref false) . c) }) })
(\ c : ({ a : (C -> C) , a : ((\ B : Star . Nat) (All E : Star . Nat)) }) . (if (\ e : Float . "boy") then (1 [ C ]) else (iszero 0)))
(let { D , b } = (fix (iszero true)) in (ref (if unit then false else 0)))
((let e = ("boy" as (\ A : Star . Unit)) in (ref 0)) (ref (succ "apple")))
((if ({ b = 1 , d = 0 }) then (! (if c then b else 1)) else ("boy" "apple")) (succ (pred true)))
(\ C : (((Star => Star) => (Star => Star)) => ((Star => Star) => (Star => Star))) . (({ d = "apple" , b = a }) (succ (\ E : Star . 1))))
(({ * ({ Some C : Star , (Ref B) }) , (ref "apple") } as (B (Float -> C))) . e)
(({ * ({ a : Bool , b : String }) , (! (a := unit)) } as ({ b : ({ Some C : Star , Nat }) , b : (All B : Star . Bool) })) := ({ e = (iszero "boy") , c = (pred (iszero a)) }))
((fix (ref (\ b : String . b))) . a)
(((({ c = 2 , e = "boy" }) as Float) . d) . b)
(let a = ({ * ({ e : Nat , a : Float }) , ({ * B , 1 } as Unit) } as (Float -> (Float -> Unit))) in ((let { D , e } = (\ c : Float . c) in (b as Float)) as (Ref (\ B : Star . Unit))))
(fix ((let a = (iszero (0 "boy")) in (ref (b := "boy"))) [ ({ Some A : (Star => Star) , ({ e : B , b : B }) }) ]))
(if (if (let a = (c a) in (! 0)) then (1 . e) else (fix "boy")) then (pred ((unit [ C ]) := ({ b = b , c = 0 }))) else (let { D , b } = (fix false) in (fix unit)))
(if ((pred 2) (a . e)) then ((let e = 2 in 0) [ (All B : Star . Float) ]) else (if ({ * Bool , (\ E : Star . a) } as ({ e : Float , d : Bool })) then (! (! 1)) else (fix a)))
((pred (ref (! "boy"))) [ (({ b : String , b : String }) (Float -> ({ b : Bool , b : Nat }))) ])
(if (! (ref (let { D , d } = a in 2))) then (if (ref c) then ({ * Bool , (fix "boy") } as (Ref B)) else (pred a)) else (ref (! (false := 0))))
({ * (All D : (Star => Star) . (All A : (Star => Star) . (Unit -> Unit))) , (pred ({ * ({ c : (C -> String) , b : Bool }) , (succ a) } as (\ C : Star . C))) } as (\ B : (Star => Star) . (Nat A)))
(succ (\ b : (All D : (Star => Star) . (\ B : Star . Unit)) . ({ b = (\ e : Float . false) , c = unit })))
(ref (pred ((\ c : Float . "apple") := (\ c : String . unit))))
((((pred "apple") as (B B)) := (\ D : (Star => Star) . (let d = 2 in 0))) := (\ E : (((Star => Star) => Star) => (Star => Star)) . (fix (\ E : Star . false))))
(((\ E : (Star => Star) . "apple") as (\ E : Star . (Nat -> Float))) as (\ E : ((Star => Star) => (Star => Star)) . ({ c : (Float -> A) , e : (All D : Star . B) })))
(\ b : (All A : (Star => Star) . (Ref Nat)) . (iszero (\ B : ((Star => Star) => Star) . (b [ Bool ]))))
((((b as A) := 2) . d) as ({ Some B : ((Star => Star) => (Star => Star)) , (\ C : (Star => Star) . (All A : (Star => Star) . (A Unit))) }))
(let b = (ref ((succ a) (iszero true))) in (ref ("boy" (\ A : Star . c))))
((\ D : ((Star => Star) => Star) . (! 2)) (iszero (c as A)))
(iszero ((if "boy" then b else 0) as (All B : Star . ({ a : String , a : Bool }))))
(ref (iszero (0 true)))
(if (\ a : ({ Some D : (Star => Star) , (All A : Star . B) }) . (iszero ((pred "boy") [ (Bool -> A) ]))) then (pred (pred "apple")) else ((succ 2) := (0 "boy")))
({ e = ((! 0) := (iszero true)) , d = ({ a = ((1 . d) := (if c then "boy" else c)) , c = (let c = (let { C , e } = 0 in false) in (ref 2)) }) })
(\ c : ((All C : (Star => Star) . (All B : Star . Float)) (All D : (Star => Star) . (Ref Bool))) . (\ E : ((Star => Star) => Star) . (\ b : A . "apple")))
(pred (iszero (2 . e)))
(let e = (if (let b = ((succ "boy") [ Float ]) in (if 1 then unit else false)) then (let { A , b } = ({ a = a , e = c }) in b) else (\ a : C . false)) in (let { C , d } = (\ d : Unit . b) in (! a)))
(let { C , a } = (let { D , a } = ((fix 2) as (All B : Star . Nat)) in ((iszero 0) := (if unit then (pred c) else unit))) in (((succ false) [ (All C : Star . ({ b : String , a : Unit })) ]) := (succ (\ D : Star . 1))))
(((let { B , e } = (b . a) in (fix 0)) := (pred (! b))) := ((\ a : Float . 2) as ({ b : Unit , e : String })))
(\ d : (All A : (Star => Star) . (String -> C)) . ((ref (if 2 then (ref true) else (1 . a))) ((let { E , c } = (let b = c in true) in (pred true)) (if 2 then unit else c))))
(\ A : (((Star => Star) => (Star => Star)) => ((Star => Star) => (Star => (Star => Star)))) . (fix (ref a)))
(if ((true as Bool) as ({ Some B : Star , Nat })) then (let b = (a [ Unit ]) in ({ * (Ref B) , ("apple" as Nat) } as (\ B : Star . A))) else (iszero (! (let { A , c } = a in 1))))
((if (({ * A , 2 } as String) as Unit) then (pred (\ a : B . b)) else (if 0 then 0 else 0)) as ({ Some A : (Star => Star) , (Ref Unit) }))
({ a = (\ b : (All E : (Star => Star) . (Nat (Ref B))) . (\ B : (Star => Star) . ("boy" . a))) , e = (\ a : ({ d : Bool , e : ({ d : C , e : A }) }) . (let a = (if b then 1 else c) in true)) })
(((ref ({ * A , a } as Nat)) [ ({ c : ({ Some D : Star , C }) , c : ({ d : Float , a : Unit }) }) ]) ({ c = (succ (\ e : Nat . unit)) , e = (pred (a := (let a = true in a))) }))
(\ A : (((Star => Star) => (Star => (Star => Star))) => (Star => (Star => Star))) . (ref (iszero b)))
(! (pred (succ (! b))))
({ * (({ d : String , c : Float }) (\ C : Star . (\ A : Star . Unit))) , (let { D , b } = (ref "apple") in (! c)) } as (({ Some D : (Star => Star) , Bool }) -> (Ref (Ref B))))
(succ (let { D , a } = (b true) in ("boy" [ Bool ])))
(ref (pred ("apple" as Nat)))
(if (({ e = 0 , d = (ref a) }) (false . a)) then (succ (2 := 1)) else (let { C , e } = ((pred ({ * B , c } as Float)) as (Ref String)) in (let d = (2 . a) in (pred 1))))
(fix ((true [ Unit ]) := (let a = false in 0)))
(\ A : (((Star => Star) => (Star => Star)) => (Star => (Star => Star))) . ({ d = ({ d = 0 , d = 2 }) , d = ({ * ({ Some A : Star , Bool }) , (! "boy") } as (Ref B)) }))
(iszero ((\ e : Unit . unit) [ ({ Some D : Star , A }) ]))
(iszero (let { A , e } = ((\ c : ({ Some D : Star , B }) . (\ E : Star . false)) := (let d = false in "boy")) in (ref (let c = true in unit))))
(fix (let c = (succ 2) in (ref (! 2))))
(ref (! (\ E : (Star => Star) . (if 0 then unit else a))))
(ref (succ ({ e = (let a = 0 in b) , c = true })))
(! (let e = ({ * A , "apple" } as (Float A)) in ((unit as A) . a)))
((\ A : (Star => Star) . ({ e = unit , d = unit })) [ ({ c : (\ C : Star . (All A : Star . Unit)) , c : (\ D : (Star => Star) . (Float -> Nat)) }) ])
({ b = (((let { A , a } = unit in 2) as (String A)) [ ((Ref Unit) ({ Some E : Star , A })) ]) , a = (if ((if "apple" then "apple" else "boy") [ A ]) then ({ e = "boy" , a = false }) else ({ d = false , b = ({ * Float , a } as C) })) })
(pred (pred (pred ((true [ String ]) . a))))
(\ b : (Ref (Ref String)) . ((! (\ d : Float . ("boy" a))) . b))
(iszero ({ b = (if 1 then 1 else "boy") , c = (let { D , b } = 2 in 1) }))
(let d = (\ d : (\ D : Star . (A B)) . (\ A : Star . a)) in (let { D , e } = (! false) in ({ * (Bool C) , (! false) } as ({ c : Nat , d : Nat }))))
(\ d : ({ a : ({ Some D : Star , A }) , a : ({ Some C : Star , (All A : Star . Unit) }) }) . (\ a : (\ C : (Star => Star) . (\ C : Star . Nat)) . (ref (! "apple"))))
(fix (fix ((ref "boy") [ ({ Some E : Star , String }) ])))
(({ * (\ C : (Star => Star) . (({ Some A : Star , String }) -> (B C))) , (fix "apple") } as ({ a : (All B : Star . B) , d : (String A) })) . e)
((("apple" [ (Ref Nat) ]) as (((Ref C) -> ({ Some C : Star , A })) -> (Bool -> C))) . c)
(let { C , a } = (! ((1 . d) (if (iszero 2) then (succ 0) else (succ false)))) in (ref (true [ A ])))
(succ ({ * ({ Some C : Star , Bool }) , (iszero (\ c : Bool . true)) } as (All E : ((Star => Star) => Star) . (Ref Float))))
(pred ((fix ({ a = 2 , d = unit })) := (iszero a)))
(pred (iszero ("boy" b)))
((if (fix (1 [ B ])) then (iszero "apple") else ((ref "apple") . c)) (\ C : ((Star => Star) => Star) . (ref (\ e : String . (ref unit)))))
((iszero (\ e : Unit . "boy")) [ (((Ref String) ({ Some D : (Star => Star) , Float })) ({ Some A : ((Star => Star) => Star) , (All E : Star . ({ Some B : Star , C })) })) ])
(let { A , a } = ((succ (let { A , d } = unit in "boy")) := (1 unit)) in (let { E , a } = (fix 0) in (unit as A)))
((! (c . d)) := (succ ((pred "boy") a)))
(\ d : (((All A : (Star => Star) . (\ B : Star . C)) (\ E : Star . A)) -> (({ Some C : (Star => Star) , (All B : Star . B) }) -> (\ C : Star . (Nat -> A)))) . (iszero (\ b : ({ Some B : Star , String }) . a)))
((! (a := 2)) . c)
({ a = ((ref (fix a)) (succ 1)) , c = ((iszero "boy") := (iszero 2)) })
((pred ({ a = unit , a = false })) [ ({ b : (All D : Star . C) , a : (Float A) }) ])
(! (let c = (succ unit) in (iszero c)))
(iszero (("boy" . d) := (! 2)))
(\ e : ({ d : ((Nat -> B) ({ a : Bool , d : C })) , a : (A C) }) . (succ (b (0 . d))))
(((ref b) := ((let a = c in 2) b)) . b)
(! ((\ E : Star . false) ("apple" := 0)))
({ c = (\ b : ({ Some D : Star , ({ Some D : Star , String }) }) . (ref 1)) , d = (if ((unit := 1) (fix true)) then (ref (0 [ C ])) else (succ (let d = "boy" in 0))) })
(if ({ * ({ c : Nat , a : Bool }) , ((unit as Float) . e) } as (Ref C)) then ((let b = 0 in 2) as ({ Some E : Star , Bool })) else (succ (\ B : (Star => (Star => Star)) . (unit [ C ]))))
(let { D , b } = (fix (\ b : Bool . a)) in (\ a : ({ Some C : (Star => Star) , B }) . (unit . d)))
(((iszero unit) . a) as (\ C : (Star => Star) . (All C : (Star => Star) . ({ a : A , e : Nat }))))
(let d = (! ((pred c) as (String -> Float))) in ((true [ Nat ]) (let { A , a } = (succ 2) in true)))
(let e = (! (! a)) in (ref ((let { A , e } = a in unit) := ({ c = c , a = unit }))))
(\ B : ((Star => (Star => Star)) => ((Star => Star) => (Star => Star))) . (! (! 2)))
(let a = ((let { D , e } = "apple" in false) as (\ B : Star . C)) in (! (let { A , a } = false in "boy")))
({ d = (ref (true := (\ d : Bool . unit))) , d = (ref (iszero "boy")) })
((((0 as Float) [ B ]) [ ({ c : (Float C) , b : ({ d : A , c : Bool }) }) ]) := (((pred unit) . b) [ (\ A : Star . (\ E : Star . C)) ]))
(succ (let { B , a } = (\ B : (Star => Star) . (iszero c)) in (let { E , e } = (a [ Nat ]) in ((let e = "apple" in true) as ({ d : C , e : Unit })))))
(! (if (fix 0) then (! 0) else (pred b)))
(succ ((iszero ({ * (\ A : Star . Bool) , (pred a) } as ({ Some E : Star , Float }))) := (let { D , b } = unit in ("apple" := false))))
(let { C , c } = ((fix (pred 1)) . e) in (succ (\ B : Star . (c [ B ]))))
(({ * (\ A : (Star => Star) . A) , (let d = (let { C , d } = a in true) in (\ B : Star . "apple")) } as (String -> Bool)) := (ref (let { B , d } = 2 in true)))
(succ (let a = ({ * (C -> Unit) , ({ * Bool , false } as Unit) } as (String Nat)) in (pred (succ c))))
({ c = (fix ({ c = (if c then b else "boy") , d = c })) , d = (iszero (let a = ((let e = "apple" in b) := "boy") in (fix true))) })
(iszero ((ref "boy") as (Float Unit)))
(((true as A) [ (Nat C) ]) [ ({ Some D : ((Star => Star) => (Star => Star)) , (All D : (Star => Star) . ({ a : Float , b : A })) }) ])
(let { E , d } = ({ a = (iszero (false . c)) , b = (! (\ B : Star . a)) }) in ((ref ("apple" [ String ])) as ({ a : Unit , c : ({ d : Unit , c : Unit }) })))
((succ (ref 0)) := ((! unit) ((ref (pred 0)) . e)))
(((b . e) [ (\ B : Star . A) ]) as ((\ B : (Star => Star) . C) ({ c : ({ Some D : Star , B }) , a : A })))
(succ (if ((ref false) [ (B -> Nat) ]) then (let { B , d } = (\ c : B . unit) in ("apple" as Bool)) else (iszero 0)))
({ a = (fix ({ * B , 2 } as B)) , a = (fix ({ e = (iszero (unit [ A ])) , a = ({ e = false , b = false }) })) })
(ref ((pred 0) := (iszero false)))
((if ((iszero unit) := (c . d)) then (let { B , b } = (ref c) in (succ c)) else (! (fix (fix 0)))) := (pred (fix (succ "apple"))))
((pred ("apple" . a)) := ({ * (All D : Star . (Bool A)) , ({ * (Bool -> Bool) , "apple" } as (\ A : Star . A)) } as (\ A : (Star => (Star => Star)) . ({ e : (All C : Star . Bool) , c : Nat }))))
(\ b : ({ Some B : ((Star => Star) => (Star => Star)) , (All B : (Star => Star) . (All D : Star . (\ B : Star . Unit))) }) . (fix (ref (\ c : Nat . "boy"))))
(ref (pred ({ d = b , d = 1 })))
({ * (Ref ((All E : Star . Unit) (Ref Unit))) , (if (fix b) then (c := 0) else (succ true)) } as (\ E : ((Star => Star) => Star) . ((Nat -> Nat) -> Bool)))
(((ref false) . e) as ({ Some A : ((Star => Star) => Star) , ({ Some D : Star , Bool }) }))
(\ B : ((Star => Star) => (Star => Star)) . (pred (c . a)))
((fix (! (b . d))) as ((({ Some E : Star , C }) -> Unit) -> (({ Some C : Star , B }) (Ref String))))
(let { E , d } = (succ (\ D : (Star => Star) . (fix 0))) in (succ (let d = c in c)))
(({ a = (pred a) , e = (iszero (a . e)) }) := (let e = (let { B , e } = true in ({ * C , unit } as Bool)) in ({ * (All E : Star . B) , ({ d = true , c = unit }) } as String)))
(\ D : ((Star => Star) => (Star => Star)) . (\ E : (((Star => Star) => Star) => (Star => Star)) . (0 := 0)))
((let { A , d } = ({ b = ({ a = a , a = c }) , e = ({ b = unit , e = "apple" }) }) in (! (a := (false . c)))) (if (b as ({ b : String , e : B })) then (b as B) else (fix ({ * Float , unit } as Unit))))
(ref (ref (succ 2)))
(((ref (true as Bool)) [ (Float -> A) ]) [ ((\ A : Star . ({ a : Nat , b : A })) (B -> (All D : Star . C))) ])
(! (! ({ c = true , b = (! true) })))
(fix (iszero (fix (if a then false else "apple"))))
(if ((ref (\ D : Star . a)) [ ({ a : A , d : Float }) ]) then ((b unit) := (a false)) else (pred ((1 as C) [ B ])))
(fix ((let b = (\ C : (Star => Star) . "apple") in (if true then a else "apple")) (\ a : ({ Some D : (Star => Star) , (String String) }) . (if c then 0 else ({ * B , "apple" } as B)))))
(let e = ({ * (Nat -> (All D : Star . Nat)) , (succ 1) } as (Float -> ({ Some C : Star , String }))) in (iszero (iszero 0)))
(if (succ ({ * (All D : Star . Bool) , (fix a) } as String)) then ({ * (({ Some C : (Star => Star) , (String Nat) }) -> ({ Some A : (Star => Star) , String })) , (succ ((fix "apple") := (\ e : Nat . true))) } as (({ Some B : Star , Unit }) -> ({ Some D : Star , Nat }))) else ((2 as String) . c))
((! (succ true)) as ({ Some B : (Star => (Star => Star)) , (\ E : Star . Bool) }))
(! ({ a = (! (a [ B ])) , d = ((let a = 2 in 1) . b) }))
({ a = ((succ "apple") [ ({ Some A : (Star => Star) , ({ Some D : Star , C }) }) ]) , a = ((! (iszero "apple")) := (let { D , b } = ({ e = ({ b = a , d = c }) , e = "apple" }) in (\ D : Star . "boy"))) })
(\ b : (\ D : ((Star => Star) => Star) . (Ref (All C : Star . Bool))) . ({ b = ((fix 2) ({ a = false , b = 2 })) , a = (\ D : ((Star => Star) => Star) . ({ * A , b } as String)) }))
(! (let b = (pred ({ d = (if 1 then 0 else 0) , e = (\ c : String . a) })) in (\ D : (Star => Star) . (unit := c))))
((\ C : ((Star => Star) => (Star => Star)) . (ref a)) . e)
((\ e : ({ Some D : Star , Unit }) . ({ * C , (pred 0) } as Nat)) [ ((A A) ((Bool C) -> (\ B : Star . Unit))) ])
(let { B , b } = (! (\ E : Star . "boy")) in (succ (c [ Nat ])))
(succ (iszero (false as A)))
(if (("boy" := (iszero 2)) [ (Float B) ]) then (pred (false (2 as Bool))) else (iszero (succ (b := "apple"))))
(succ ((false b) (if false then false else 1)))
(fix (let { D , b } = (if (iszero b) then (if 0 then unit else unit) else (let { E , a } = b in "boy")) in (fix (true . b))))
(succ (pred (fix (let e = false in 0))))
((\ A : (Star => Star) . (pred b)) as ((\ D : Star . Bool) -> ((Ref String) C)))
(pred (pred (let { B , b } = false in (true as Nat))))
(ref ((fix c) (unit := unit)))
((("boy" . b) . c) . a)
((let b = ((ref "apple") b) in (unit b)) . c)
((if ({ a = (ref 0) , a = 0 }) then ({ * A , "boy" } as Nat) else ({ * String , (\ b : Nat . a) } as Nat)) [ (\ A : (Star => Star) . (\ E : (Star => Star) . Nat)) ])
(succ (ref (pred (succ c))))
(pred (\ e : (A -> ({ d : B , b : String })) . (ref (false := true))))
({ e = (\ d : (Nat -> Unit) . (0 unit)) , d = ((c [ Bool ]) . a) })
(let { D , a } = ({ * (Unit Float) , (b as Nat) } as (Unit -> Unit)) in ({ * (Bool Float) , (fix (if 0 then true else 2)) } as (\ A : Star . Unit)))
(\ E : ((Star => (Star => Star)) => (Star => Star)) . ((\ c : (All E : Star . C) . (\ a : (B -> Float) . (succ 2))) [ ({ Some D : Star , ({ e : Nat , b : A }) }) ]))
(((\ e : (Nat A) . (\ B : Star . true)) := (succ 2)) [ ({ Some D : (Star => Star) , (All C : Star . Bool) }) ])
(succ (iszero (let b = unit in a)))
(let a = (fix (iszero (! (let a = true in 1)))) in (ref (\ B : (Star => Star) . (iszero "apple"))))
(if (let c = (if "boy" then (b := "boy") else 0) in ((c [ Unit ]) . d)) then (succ (let { D , a } = "boy" in (false . c))) else (\ A : (Star => Star) . ((pred "boy") [ (Bool -> Bool) ])))
((iszero (let c = (\ c : C . (pred "apple")) in ("boy" as Unit))) := (ref (let b = (\ d : Bool . (let { A , a } = false in 1)) in (\ D : (Star => Star) . (fix c)))))
((\ C : (Star => (Star => Star)) . ({ * Nat , c } as A)) := (let e = ({ a = (if ({ b = "apple" , a = "apple" }) then a else true) , e = ({ d = 2 , d = c }) }) in (if (! "boy") then (a 1) else ({ * ({ c : Nat , d : Bool }) , (0 true) } as (\ C : Star . Nat)))))
({ c = ({ * (Ref (Unit -> A)) , (succ ("apple" . a)) } as ((Unit Bool) ({ e : Bool , b : String }))) , a = ((2 as String) . e) })
(fix (let { D , a } = (("apple" := "boy") [ Bool ]) in (\ d : (({ d : Float , b : Bool }) -> B) . (let { E , c } = false in 1))))
(iszero (let b = (fix c) in (if "apple" then c else 1)))
(\ b : ({ Some D : (Star => (Star => Star)) , (All B : (Star => Star) . (String String)) }) . (succ ((fix false) . b)))
(((\ B : Star . ("boy" . b)) [ ((String A) ({ Some E : Star , (Ref Nat) })) ]) [ (Ref (Unit Bool)) ])
(let { C , e } = ((fix (\ d : (All D : Star . Nat) . c)) as (All D : ((Star => Star) => (Star => Star)) . (Ref Nat))) in ((\ B : Star . 2) . c))
(let d = (let { D , c } = (("boy" := 2) := (ref 2)) in ({ d = ({ b = 1 , d = false }) , b = (let e = c in "boy") })) in ({ c = (0 as ({ Some D : Star , A })) , a = ((pred c) [ (All E : Star . ({ Some D : Star , C })) ]) }))
((\ E : (((Star => Star) => Star) => ((Star => Star) => (Star => Star))) . (fix (a as Bool))) as (\ D : ((Star => Star) => (Star => Star)) . (Bool C)))
(\ A : (((Star => Star) => (Star => Star)) => (Star => Star)) . ((iszero 1) as ({ Some A : (Star => Star) , (Unit -> C) })))
({ * ((\ A : Star . String) (\ E : Star . (Ref Float))) , ((iszero (succ 1)) := ((let d = b in (iszero a)) := (succ b))) } as (Ref ((Ref (Nat String)) ({ Some B : (Star => Star) , (All E : Star . String) }))))
(iszero (((! true) (c [ Unit ])) := ({ * (Unit -> Nat) , 2 } as Nat)))
(pred (pred (pred 0)))
(succ (iszero ((iszero c) [ (Ref Unit) ])))
(let c = ((let { B , d } = "apple" in b) (! true)) in (pred (fix (0 . e))))
(let { E , a } = (\ D : ((Star => Star) => ((Star => Star) => (Star => Star))) . (\ e : B . unit)) in (iszero ((\ e : Bool . a) := a)))
((let { E , c } = (let b = ((let a = false in 2) [ (Float -> A) ]) in ((pred "apple") . a)) in (let { A , e } = (let a = unit in b) in (2 unit))) as ((\ C : Star . String) -> ({ b : Nat , a : B })))
(iszero (((let a = 1 in c) [ Nat ]) [ (\ C : Star . Float) ]))
(fix (if (\ A : Star . c) then (a [ Bool ]) else (iszero "boy")))
(! ((if true then "boy" else c) . d))
(\ A : (((Star => Star) => Star) => (Star => Star)) . (let c = (pred 1) in ({ b = false , e = 0 })))
(fix (ref ((\ a : Unit . c) (pred 0))))
(fix (! (\ E : (Star => Star) . (fix unit))))
(pred (succ (("apple" [ Unit ]) [ (Ref C) ])))
(let d = (pred (\ a : ({ c : C , b : Unit }) . (fix 2))) in (((let b = b in unit) . e) := (pred b)))
((let e = ({ * C , (2 := 0) } as (Ref String)) in (\ A : (Star => Star) . 1)) := ((if (succ 0) then b else 0) := ((if unit then (b as Unit) else (let { B , a } = b in true)) (if b then true else c))))
((if (({ * A , b } as String) . b) then (1 [ String ]) else (0 [ Bool ])) ({ * (Ref Bool) , ((\ E : Star . (\ A : Star . true)) ((false 2) as B)) } as (\ C : Star . Nat)))
(pred (fix (let { C , c } = (succ unit) in "apple")))
(let d = (\ C : (Star => Star) . (("apple" := 1) [ Unit ])) in (pred (fix ((true [ B ]) := (true as Bool)))))
(fix (! (iszero (let e = (fix unit) in (let e = 2 in true)))))
((let e = (let { D , a } = true in false) in ({ b = unit , b = 2 })) (ref (\ B : (Star => Star) . (\ E : Star . a))))
(if (("boy" := true) [ (All D : Star . Nat) ]) then ((if (let b = false in c) then (iszero (let { B , a } = c in unit)) else (pred "boy")) (iszero (if "boy" then (fix 0) else a))) else (ref ((fix 0) as ({ Some D : Star , Nat }))))
(let d = ({ b = (pred "apple") , e = ("boy" [ (Bool C) ]) }) in (pred (\ c : (All A : Star . C) . (\ D : Star . c))))
((iszero (\ B : Star . "apple")) [ ({ Some D : (Star => (Star => Star)) , (All B : Star . Bool) }) ])
(\ e : ({ Some B : (Star => (Star => Star)) , ((Ref Float) (Unit -> C)) }) . (succ ((\ b : Unit . c) ("apple" [ Float ]))))
(fix ((\ d : (Ref B) . (ref c)) as (((\ D : Star . Unit) String) -> (\ A : Star . (All B : Star . Bool)))))
((! (true true)) as (Ref ({ d : Float , a : C })))
(\ c : ({ d : (\ D : (Star => Star) . ({ Some D : Star , Float })) , d : ({ c : ({ Some C : Star , Unit }) , e : (All A : Star . B) }) }) . (if (pred unit) then ({ * Float , ("apple" . c) } as (Nat -> B)) else ("boy" (if 2 then b else b))))
(pred ((\ d : ((Float Nat) -> String) . ("apple" [ (\ E : Star . Nat) ])) (fix (! 0))))
(! (\ B : (Star => Star) . (fix 1)))
(! (! (fix a)))
(iszero ((! ({ e = a , d = "boy" })) . e))
(((if 1 then false else 1) as (Ref (\ B : Star . Float))) (! (let c = b in 2)))
(fix (! (false . b)))
(fix (! (succ 2)))
(let { B , e } = (({ * (All D : Star . Unit) , 2 } as ({ Some A : Star , C })) . b) in (! ((succ false) . a)))
(ref (succ (0 [ (\ C : Star . Unit) ])))
(\ E : ((Star => Star) => ((Star => Star) => Star)) . ((if b then true else true) [ (B Bool) ]))
(((iszero c) . e) [ (({ Some C : (Star => Star) , (A -> Float) }) ({ Some D : (Star => Star) , ({ a : Bool , c : Unit }) })) ])
(ref (if ((2 [ B ]) [ (C -> B) ]) then ((! b) as (\ D : Star . B)) else (if true then (b := "boy") else unit)))
(let { E , c } = (fix (iszero (1 . d))) in (({ * Unit , 1 } as A) as (Float -> Nat)))
(! (! ((ref b) as (A -> Float))))
((ref (fix 0)) as ((Float -> ({ Some C : Star , Nat })) (({ d : A , c : B }) (Unit -> String))))
((! (\ c : B . 0)) . a)
({ * ((\ C : Star . (\ C : Star . Unit)) -> (\ D : Star . ({ Some B : Star , C }))) , ({ c = ((let b = (unit := a) in a) (fix false)) , b = (1 . e) }) } as (All A : ((Star => Star) => (Star => Star)) . (\ E : (Star => Star) . (\ A : Star . Nat))))
(iszero ({ e = (\ a : ({ Some B : Star , (All E : Star . Float) }) . (let { A , c } = false in 2)) , c = ("boy" . d) }))
((succ (if (c as C) then (pred 1) else a)) (let { B , c } = (b := false) in (if a then a else true)))
({ * (\ A : (Star => (Star => Star)) . (A -> Nat)) , (succ (c := a)) } as (All D : (Star => Star) . ({ a : Float , e : C })))
(let c = (\ d : ({ Some E : (Star => Star) , (B -> (Ref A)) }) . (pred (succ 0))) in (pred ({ * String , a } as Nat)))
((iszero (fix "apple")) [ ((Ref ({ b : Nat , e : Float })) (All E : (Star => (Star => Star)) . (\ D : (Star => Star) . (Bool Float)))) ])
(let { A , d } = (let { D , e } = (true := unit) in (\ D : (Star => Star) . 2)) in (let { B , d } = (iszero ({ * Bool , b } as Nat)) in (pred "apple")))
((((b . a) := (ref a)) [ ({ e : (All A : Star . C) , c : Unit }) ]) := (ref (iszero a)))
({ e = ({ d = (! ({ a = a , b = c })) , b = ({ * (\ C : Star . Nat) , true } as String) }) , a = (({ d = c , d = "apple" }) [ (Unit Float) ]) })
(pred ((let a = a in c) . c))
(\ b : (\ A : ((Star => Star) => Star) . (({ Some D : Star , B }) ({ Some B : Star , Unit }))) . (succ ({ * C , ({ * Bool , c } as C) } as ({ b : Nat , a : Float }))))
((fix (if true then (a . b) else (! b))) as (\ C : ((Star => Star) => ((Star => Star) => (Star => Star))) . (All B : (Star => Star) . ({ c : Nat , a : A }))))
({ * (({ b : Nat , a : Nat }) -> (All C : Star . (Unit -> C))) , (\ A : (Star => Star) . (pred unit)) } as (Ref (({ Some C : Star , B }) Unit)))
({ * ({ Some C : (Star => (Star => Star)) , (C Nat) }) , (((let c = unit in unit) (iszero false)) as ((\ A : Star . String) -> A)) } as (Ref (Bool -> A)))
(fix ((0 c) . b))
((let c = (0 . e) in (c := 1)) (fix ({ * ({ b : C , e : Unit }) , true } as Bool)))
(iszero (succ (\ a : (\ E : Star . Unit) . a)))
(fix (if ({ d = true , a = true }) then (succ "apple") else (succ (let d = 1 in 1))))
(\ e : ({ a : (\ D : (Star => Star) . ({ Some A : Star , Bool })) , c : ({ c : (Ref String) , b : (C Float) }) }) . ({ a = ((iszero true) [ Nat ]) , b = (\ b : (Bool -> Unit) . true) }))
(pred ({ * (Ref Bool) , (pred c) } as (\ D : Star . Float)))
(ref ((succ false) := (\ E : (Star => Star) . (ref unit))))
((((fix 0) as (\ D : Star . Bool)) := (\ a : Float . "boy")) . c)
({ b = (iszero (a . d)) , d = (fix (2 [ Nat ])) })
((let b = (iszero 2) in (ref (succ 1))) . a)
(! (! (unit [ ({ e : C , b : B }) ])))
(((let { B , e } = c in "apple") := (succ "boy")) . c)
((! (\ a : C . "boy")) (if ({ b = "apple" , d = c }) then (! false) else (false . e)))
((let b = ((pred unit) 1) in (! b)) [ ({ a : ({ Some B : (Star => Star) , (Bool -> Unit) }) , e : ({ a : ({ Some B : Star , Nat }) , c : (Bool -> (All C : Star . Bool)) }) }) ])
(! ((2 . a) . d))
(fix ((\ a : (Bool -> C) . (iszero 1)) as (Bool String)))
((! ({ c = (\ C : Star . "boy") , b = (fix a) })) := (! (! (! c))))
(({ b = (! c) , b = (let b = (if b then false else false) in (! 0)) }) (succ (ref c)))
((\ d : (\ B : (Star => (Star => Star)) . (C Float)) . (ref (iszero 0))) [ (Ref (Ref Unit)) ])
(! (! ({ * ({ Some A : (Star => Star) , (Bool -> Unit) }) , (\ a : A . 0) } as ({ e : (All D : Star . C) , a : (\ E : Star . Unit) }))))
((let c = (\ b : (Nat -> Bool) . ({ * A , b } as B)) in (! 0)) as (\ B : ((Star => Star) => (Star => Star)) . ((\ D : Star . Bool) (All E : Star . Nat))))
(\ D : ((Star => Star) => ((Star => Star) => (Star => Star))) . ((let { A , a } = (if 1 then unit else b) in (\ E : Star . b)) as ({ d : (Nat String) , b : (\ D : (Star => Star) . ({ Some B : Star , B })) })))
(\ d : (\ A : ((Star => Star) => (Star => Star)) . ({ b : Unit , d : (Ref A) })) . (succ (ref true)))
({ b = ({ b = ((if 2 then unit else b) ({ * Float , "boy" } as (Ref Bool))) , e = (succ ({ * Bool , (0 . b) } as Nat)) }) , e = ((succ ((1 . d) := (ref 2))) ((fix 0) . b)) })
(fix (pred (fix unit)))
((({ * ((Float A) -> (\ C : Star . Nat)) , (let c = b in "boy") } as ({ Some B : Star , Unit })) . e) := ({ * (Ref (Unit Bool)) , (succ 2) } as ((C B) -> (\ B : Star . C))))
({ * (\ D : (Star => Star) . ({ a : Nat , a : Float })) , (iszero (\ E : ((Star => Star) => (Star => Star)) . (0 [ A ]))) } as ({ e : (All A : Star . Float) , e : (\ C : Star . A) }))
((\ D : (Star => Star) . (\ E : Star . ({ * A , 1 } as Nat))) (\ A : ((Star => Star) => (Star => Star)) . ((pred "apple") [ B ])))
(\ c : ((\ C : (Star => Star) . (String B)) (All A : (Star => Star) . A)) . (iszero ({ * Unit , b } as (Float Float))))
((pred (let b = ((\ a : C . c) := a) in (b as Float))) := (! (\ b : Unit . ({ * Bool , c } as String))))
((iszero (\ A : Star . "apple")) (let { A , a } = (unit a) in ((true c) as (Ref Nat))))
(((({ c = a , e = 0 }) (\ a : B . true)) as (Ref (Nat -> String))) as ((All A : (Star => Star) . ({ Some A : Star , C })) -> (All C : ((Star => Star) => Star) . ({ Some E : Star , A }))))
(\ A : (((Star => Star) => (Star => Star)) => (Star => Star)) . (pred (if 1 then a else unit)))
(({ * (B ({ d : String , c : Unit })) , ((iszero unit) as (({ Some B : Star , A }) (Ref Unit))) } as (\ E : (Star => Star) . (Nat -> A))) := ((ref 0) (\ C : Star . unit)))
(succ (\ D : ((Star => Star) => (Star => Star)) . (\ E : (Star => Star) . ({ a = 1 , d = b }))))
(({ b = (let e = a in "boy") , e = ({ * Nat , 2 } as Nat) }) := (if ((\ e : A . 0) [ (B B) ]) then ({ c = (iszero (pred unit)) , e = (\ D : (Star => Star) . true) }) else (("boy" . e) as (({ Some D : Star , String }) -> String))))
({ * (\ B : ((Star => Star) => ((Star => Star) => (Star => Star))) . ((B String) (\ C : Star . Float))) , (if (succ ({ * String , "apple" } as Float)) then (pred (if "apple" then true else 2)) else (fix unit)) } as ({ Some E : (Star => (Star => Star)) , (\ C : (Star => Star) . Float) }))
((let { C , a } = (ref c) in ({ c = (pred a) , c = (\ e : Unit . "apple") })) (\ d : (Ref C) . (true false)))
(fix (let { C , b } = (if c then 0 else false) in (pred 0)))
(({ * ((B -> C) Float) , (succ 0) } as ((Ref Unit) -> (Ref C))) . d)
((let { C , b } = ((let a = unit in b) (! (succ 2))) in (false as Float)) [ ({ Some C : (Star => Star) , (\ D : Star . Unit) }) ])
(\ c : (All B : (Star => Star) . ({ Some B : Star , A })) . (let { C , d } = (ref c) in (succ (0 . e))))
(if (let c = ((iszero a) := (\ d : Unit . a)) in ((ref (ref false)) as ({ d : (Bool -> A) , e : ({ Some D : Star , Unit }) }))) then (let { E , b } = (succ (\ D : Star . 2)) in (\ c : A . (succ unit))) else ((if b then (1 := "apple") else 1) ({ * ({ b : Bool , c : Bool }) , (fix (pred unit)) } as (\ C : Star . Nat))))
(((iszero a) . e) := ((ref true) . e))
(\ c : (Ref (All B : (Star => Star) . B)) . (fix (succ (! "boy"))))
(((true . b) . c) (! ((let d = (let { C , c } = c in c) in 0) [ (Ref ({ Some D : Star , String })) ])))
(pred (succ ({ * ((Bool C) -> Unit) , (true a) } as (A -> (\ C : Star . Float)))))
(if (let d = (let a = (unit . a) in c) in (! ("boy" . c))) then ((iszero (fix 0)) as (Ref Float)) else (ref ((if unit then c else 1) [ (C A) ])))
((ref (iszero b)) as ((Ref B) -> (({ Some E : Star , (String Bool) }) -> (All D : (Star => Star) . (All C : Star . Nat)))))
(let c = (iszero (if 0 then (1 [ Float ]) else (false := unit))) in ((\ E : Star . (c [ Bool ])) (let { C , e } = ("apple" . e) in (pred (\ D : Star . 2)))))
(succ ((b [ String ]) . e))
(((unit true) [ (Ref Bool) ]) [ (All D : (Star => Star) . (\ D : Star . Float)) ])
({ b = (ref (iszero (fix a))) , d = ({ * (Ref Float) , ("boy" as (Ref B)) } as ((String -> C) (A A))) })
(ref (ref (let b = c in unit)))
({ c = (if (let { B , c } = (unit "apple") in (succ b)) then (\ a : B . ("boy" as B)) else ({ a = c , a = (\ D : Star . a) })) , e = (! (\ B : Star . true)) })
(let c = ((! (if 2 then "boy" else true)) as (\ A : (Star => Star) . (All D : (Star => Star) . Float))) in (succ (\ B : (Star => Star) . 1)))
((let c = (a [ Float ]) in (pred (! 0))) [ (\ D : ((Star => (Star => Star)) => ((Star => Star) => (Star => Star))) . (Nat -> ({ d : Unit , c : A }))) ])
(let b = ((if c then (! true) else (unit [ Float ])) := (fix (iszero false))) in (succ (iszero 0)))
(let { A , b } = (if (! (0 [ Bool ])) then (\ B : Star . true) else ((! false) c)) in (! (succ true)))
(((\ B : Star . 0) . b) ((fix (b false)) as ({ Some E : (Star => Star) , ({ Some E : Star , C }) })))
(if ({ * (\ E : Star . C) , ({ * B , 2 } as C) } as (All C : Star . (Ref Nat))) then (iszero (succ (fix "apple"))) else (pred ((! b) [ (Unit String) ])))
(let e = (({ a = 0 , a = a }) as ({ Some A : Star , Bool })) in (iszero (! (! 2))))
(fix (({ * (All B : Star . String) , (pred b) } as ({ c : String , e : B })) [ (Ref String) ]))
((ref ({ b = 0 , c = (let b = true in a) })) . a)
({ c = (succ (ref "boy")) , d = (! ({ * Float , b } as Float)) })
(if (succ (\ a : Nat . a)) then (\ b : (All D : Star . A) . (let e = (\ D : Star . 2) in (\ c : A . b))) else (fix (iszero "apple")))
(\ e : (Ref (Bool (Ref Nat))) . ((\ e : (All C : Star . (Ref Unit)) . (if (fix a) then 0 else "boy")) . d))
(pred (({ * (A -> B) , b } as Float) := (if unit then false else a)))
((let { C , c } = (! ({ d = "apple" , d = false })) in ({ * B , (let { A , c } = b in 2) } as ({ d : Float , d : Unit }))) := (if (\ a : Float . a) then (\ E : (Star => Star) . (1 . c)) else (a := (1 [ Nat ]))))
(fix ((if 2 then (let { B , a } = b in c) else (ref c)) [ (Ref String) ]))
(((let { B , a } = (! 1) in true) := (1 [ String ])) := (fix (! ({ * Nat , c } as C))))
(\ C : (((Star => Star) => (Star => Star)) => (Star => Star)) . (iszero (let { B , c } = (iszero true) in 2)))
(pred (\ D : (Star => Star) . (if a then (iszero c) else ({ * Float , c } as B))))
(((iszero (unit . d)) . e) . b)
(\ a : (Ref (All E : Star . B)) . ((pred "boy") [ ((B Unit) -> (Ref B)) ]))
(let { C , e } = (ref (ref unit)) in (\ C : (Star => Star) . (2 := (\ A : Star . 2))))
((((\ c : String . true) := (\ D : Star . "boy")) as (\ A : (Star => Star) . (All C : Star . String))) [ ({ d : (Unit Nat) , d : (Ref B) }) ])
(((\ A : (Star => Star) . (if 0 then true else c)) [ ({ a : ({ d : B , a : Nat }) , e : ({ b : Unit , a : Nat }) }) ]) [ ({ d : (\ B : Star . Bool) , e : ({ b : Unit , a : ({ Some E : Star , C }) }) }) ])
(pred (let { B , a } = (pred (fix c)) in (if 1 then 0 else (fix a))))
({ b = ({ * ({ d : (\ B : Star . String) , e : (\ C : Star . Nat) }) , (pred ("apple" "boy")) } as (Ref (Nat Nat))) , e = (ref (if (\ b : Nat . (unit . a)) then ("boy" := false) else (pred b))) })
(ref (\ C : ((Star => Star) => Star) . ((succ 0) . b)))
(pred (iszero (! b)))
(ref (let e = (\ D : Star . a) in ((let d = false in true) := (if false then false else a))))
((\ a : ({ b : (A A) , b : ((\ B : Star . A) -> (\ B : Star . Bool)) }) . ((unit := 0) ("boy" . e))) . c)
(! ((succ "boy") (let { C , b } = unit in (fix c))))
(\ b : ({ d : (Nat -> Unit) , d : (All D : Star . Float) }) . (\ B : ((Star => Star) => Star) . ({ a = true , e = 1 })))
({ * (\ E : (Star => (Star => Star)) . (All E : (Star => Star) . (All A : (Star => Star) . ({ b : Bool , a : A })))) , (pred (if (false as A) then false else (let e = 1 in false))) } as ((Ref Unit) -> ({ b : Unit , e : Bool })))
((pred (ref 0)) := ({ a = (let { D , e } = 1 in true) , c = (if ({ * A , b } as Nat) then true else a) }))
({ * ((Ref (B Bool)) (Unit Bool)) , (let d = (fix (b . a)) in (2 as C)) } as (({ Some E : (Star => Star) , (\ E : Star . String) }) -> (All B : Star . (\ D : Star . Unit))))
(\ d : ((All C : (Star => Star) . Float) (All B : Star . B)) . ({ * ({ Some A : (Star => Star) , (Bool B) }) , ((! (let a = "apple" in "boy")) as (\ E : Star . B)) } as ({ d : C , d : (\ D : Star . A) })))
((succ (\ C : (Star => Star) . (1 . e))) := (let { B , d } = (unit as B) in (iszero ("boy" := true))))
((let b = ({ b = (\ C : (Star => Star) . (if a then true else unit)) , e = (succ "apple") }) in (let e = (b := "boy") in (b := ("apple" := b)))) as ((Ref (All C : Star . Nat)) -> ((All B : (Star => Star) . C) -> (\ C : Star . Unit))))
(! (iszero (0 as C)))
({ a = (! (b . c)) , b = (succ (! (succ b))) })
(pred (if (let { B , e } = true in 0) then (iszero unit) else (iszero ("boy" "apple"))))
((pred (ref a)) . c)
(succ (\ A : (Star => (Star => Star)) . (let { C , a } = 0 in false)))
((pred (\ C : Star . unit)) := (((if a then false else b) (succ true)) [ (Ref (All E : Star . (Nat -> Nat))) ]))
(\ B : ((Star => Star) => (Star => Star)) . (succ (ref "boy")))
(pred (ref (if false then "boy" else 2)))
(let c = ((false as Float) as (Ref String)) in (\ c : (\ E : (Star => (Star => Star)) . (All C : (Star => Star) . (C -> String))) . (if (iszero "boy") then (\ A : (Star => Star) . b) else (let { E , d } = c in (let a = 2 in a)))))
(succ ({ * (All D : (Star => Star) . ({ Some C : Star , A })) , (let b = (succ 1) in (a true)) } as ({ Some E : (Star => Star) , ({ e : A , d : B }) })))
((ref (a [ C ])) as (\ A : (Star => (Star => Star)) . (Ref (Float -> (\ D : Star . String)))))
(iszero (succ ((succ b) . d)))
(! ({ b = (c as Nat) , e = (fix (succ "apple")) }))
(! (({ b = ({ * String , "apple" } as B) , a = (if 0 then 2 else 0) }) [ (All D : Star . Float) ]))
(({ b = ({ * (\ C : Star . Nat) , "boy" } as Unit) , a = (\ E : (Star => (Star => Star)) . (c := "apple")) }) [ (Ref ({ d : (B B) , b : A })) ])
((fix (! unit)) := (\ A : (Star => Star) . ({ e = (let e = "apple" in true) , b = (let b = false in 2) })))
(((succ 1) . d) ((fix "boy") as (Ref (Ref ({ Some B : Star , String })))))
((let { C , e } = ({ * ({ a : B , d : (Ref A) }) , ({ d = true , b = (\ B : Star . unit) }) } as (All B : Star . C)) in (\ a : (Ref A) . (fix (if 0 then 0 else false)))) as (\ E : (Star => Star) . ({ Some B : Star , Float })))
(! (({ * B , unit } as Nat) := ({ * A , unit } as A)))
(ref (({ c = (pred "apple") , a = (b as Float) }) [ ((Nat -> C) -> (({ b : Bool , b : A }) (Float -> Float))) ]))
(ref (iszero (unit 2)))
(let { A , c } = (ref (let b = 0 in 1)) in ((true as Float) . d))
(let { B , a } = (ref (\ d : Nat . false)) in (succ (1 as (All B : Star . B))))
(let b = (let { E , b } = (\ c : Nat . (true . e)) in (iszero b)) in ((succ (let a = unit in b)) (succ (ref unit))))
(let a = (pred (succ 0)) in ((\ d : (String (\ B : Star . Float)) . (succ 2)) := (pred (ref unit))))
(let a = (ref (a . c)) in (if (\ d : Bool . 0) then ({ * Float , unit } as String) else (let a = c in c)))
(ref (succ (\ D : (Star => Star) . (fix c))))
(let b = (((fix unit) [ (A -> ({ b : Float , e : A })) ]) ((pred 0) . d)) in (let { B , c } = (let e = (fix "boy") in ({ d = b , c = 1 })) in ((\ d : A . a) as Float)))
((pred ((false [ Unit ]) := unit)) as (All E : ((Star => Star) => Star) . ({ d : (All C : Star . B) , a : Bool })))
(iszero (! (2 as B)))
(iszero (iszero (if "boy" then c else 2)))
(ref (({ * Bool , c } as Float) as ({ Some D : (Star => Star) , (All B : Star . B) })))
(pred (if (let d = a in false) then ("apple" [ (\ B : Star . B) ]) else ({ * C , 1 } as A)))
(\ A : (((Star => Star) => ((Star => Star) => (Star => Star))) => ((Star => Star) => (Star => Star))) . ((c [ Float ]) . b))
(({ a = (ref ({ * Nat , ("apple" as C) } as Float)) , b = (\ A : (Star => Star) . false) }) (fix (\ B : (Star => Star) . (true := 2))))
(fix (let { C , a } = (iszero (let e = "boy" in "apple")) in (2 as Bool)))
((ref ({ * A , (iszero "apple") } as C)) . a)
(! ({ * (Nat B) , (b "apple") } as (Ref Bool)))
(! ((fix "boy") as (Unit C)))
((let { C , e } = (iszero (pred 1)) in (c as (All C : Star . C))) . c)
(let b = (fix (\ b : Float . (b [ Float ]))) in (let d = (succ true) in (iszero a)))
((ref (if unit then (succ 0) else unit)) . b)
(pred (\ C : ((Star => (Star => Star)) => (Star => Star)) . ({ d = (let { A , d } = 1 in "apple") , b = (true (let c = false in c)) })))
(if ({ a = (if false then 1 else false) , a = (! "boy") }) then (let { A , b } = (iszero 2) in ((iszero b) as (\ E : Star . Bool))) else (if (ref unit) then ({ * C , 1 } as C) else ({ * B , "boy" } as String)))
((\ c : (Float -> A) . (a := (! true))) := ({ * ({ Some A : (Star => Star) , ({ e : String , e : Unit }) }) , (! c) } as ({ d : ({ Some B : Star , String }) , c : (({ e : String , b : String }) -> A) })))
(succ (pred ((succ b) := 0)))
(ref (fix (\ c : (C -> A) . (({ c = "boy" , b = 0 }) := "boy"))))
(((\ D : (Star => Star) . 0) := ("boy" as Unit)) ({ * (B -> B) , ((succ a) [ C ]) } as ({ Some E : (Star => Star) , (Ref Bool) })))
(iszero ({ * ((\ B : Star . Nat) (Bool String)) , (iszero (ref b)) } as ((Unit C) -> A)))
((if ((ref 2) . e) then (pred ({ * A , false } as Nat)) else (let d = (pred false) in b)) . b)
(\ A : (((Star => Star) => (Star => (Star => Star))) => (Star => Star)) . ((! (true := unit)) [ (Ref ({ Some E : Star , String })) ]))
((((2 [ String ]) [ Bool ]) := (let e = (fix false) in b)) (\ B : ((Star => Star) => Star) . ((! 2) := b)))
(if ({ a = (succ (\ C : Star . false)) , d = (let b = false in ("boy" . d)) }) then (if (\ b : Float . "apple") then (\ a : ({ d : Float , e : Nat }) . (let { B , b } = (let b = a in "boy") in (a . c))) else (fix (fix a))) else (ref ({ * Bool , 1 } as C)))
((let c = (\ E : (Star => Star) . false) in (pred ("apple" := unit))) (let a = (\ a : (A -> String) . (\ d : C . 0)) in (iszero (fix false))))
(\ e : (\ B : ((Star => Star) => (Star => Star)) . ({ d : ({ Some E : Star , A }) , e : Nat })) . (\ d : ({ c : String , b : (Ref Unit) }) . (\ a : (\ E : Star . A) . "apple")))
(let d = ({ d = (1 . c) , b = ("boy" [ B ]) }) in ({ * ({ b : Bool , c : (Ref B) }) , (\ c : (B C) . (succ b)) } as ({ Some B : (Star => Star) , C })))
((if (pred (\ D : Star . unit)) then ((fix 2) := false) else (! ({ * C , a } as A))) . b)
({ * ((({ b : B , b : ({ c : String , a : C }) }) ({ c : (Nat -> Nat) , d : C })) -> ({ d : (C -> Float) , d : ({ d : B , d : String }) })) , (ref (succ b)) } as (({ a : Float , a : (Bool -> Float) }) ({ Some A : ((Star => Star) => (Star => Star)) , (\ A : Star . (All E : Star . Bool)) })))
(({ a = (iszero "apple") , e = (succ (\ C : Star . true)) }) as (Ref (All E : Star . C)))
(succ (iszero ({ * Bool , b } as C)))
(({ * ({ e : (\ B : (Star => Star) . String) , b : (A -> (Bool Nat)) }) , (fix (let d = true in false)) } as ({ Some E : Star , ({ Some E : Star , Bool }) })) [ ({ Some E : ((Star => Star) => Star) , (({ Some B : Star , ({ Some B : Star , Float }) }) -> (All D : Star . Nat)) }) ])
((let a = (\ b : Unit . 0) in (let b = (pred false) in (fix 1))) := (let { C , b } = (let { E , a } = b in b) in ((pred b) as (Bool -> Nat))))
(\ e : (({ Some A : (Star => Star) , ({ c : ({ d : B , a : String }) , d : (A -> Bool) }) }) -> ({ d : (All D : Star . A) , e : (\ D : Star . Nat) })) . ((("boy" := unit) . c) := ({ * ({ Some C : (Star => Star) , (\ B : Star . A) }) , (succ 2) } as ({ Some D : Star , C }))))
((! (let { B , c } = (if "boy" then (succ "boy") else true) in (let { A , b } = ({ e = true , b = "apple" }) in ("apple" [ Float ])))) . c)
(\ B : ((Star => Star) => (Star => Star)) . ({ b = (succ ({ e = b , e = unit })) , e = (\ d : (Ref Unit) . (iszero a)) }))
({ a = (((pred "boy") . d) . c) , a = ((unit . e) . d) })
(\ C : (((Star => Star) => (Star => Star)) => ((Star => Star) => ((Star => Star) => Star))) . ((fix "apple") [ (Float A) ]))
(({ c = (\ C : (Star => Star) . (! unit)) , e = (succ (b . d)) }) . d)
((succ (\ e : B . "boy")) . c)
(({ d = ({ * B , a } as A) , e = (\ B : Star . a) }) := (({ * ({ Some B : Star , Nat }) , 1 } as (String Float)) [ (Float -> A) ]))
(fix (\ a : (\ D : (Star => Star) . (All E : Star . Float)) . (((let c = false in "boy") . a) [ (All D : Star . Nat) ])))
((let d = (iszero 2) in ({ e = (1 := unit) , b = c })) [ (Ref ((\ D : Star . String) ({ e : Unit , a : Unit }))) ])
(pred ({ * (\ A : Star . (A B)) , ((if "apple" then 0 else a) . a) } as (All B : Star . Float)))
(((0 [ A ]) := (false [ String ])) [ (Ref (All B : (Star => Star) . String)) ])
(let a = ((\ C : Star . unit) . a) in (iszero ((\ B : Star . "apple") [ Nat ])))
((! (if (ref unit) then (a unit) else c)) . c)
(((let { A , d } = (pred a) in 1) := (false := false)) := (pred (let { A , b } = "boy" in 2)))
(\ B : ((Star => Star) => (Star => (Star => Star))) . (\ D : ((Star => Star) => Star) . (fix 2)))
((if (0 [ String ]) then (let b = c in false) else (! ("boy" [ Nat ]))) (ref (fix 0)))
(ref (if (! (\ D : Star . "boy")) then ((ref unit) ({ * Float , unit } as C)) else ((\ e : C . 0) as (All C : Star . C))))
({ * ({ e : ((Ref Float) -> (Unit -> String)) , c : (All E : Star . C) }) , (let { A , e } = (succ (false as C)) in (({ * Nat , b } as Bool) (true 1))) } as (\ D : (Star => Star) . (\ B : ((Star => Star) => (Star => Star)) . (Float -> B))))
(let e = (\ C : (Star => Star) . (pred (succ a))) in ((1 := "apple") [ (All E : (Star => Star) . B) ]))
(let b = (fix ((iszero c) [ ({ Some D : (Star => Star) , (All E : Star . C) }) ])) in (if (let c = 2 in "apple") then ((\ A : (Star => Star) . "boy") . b) else (({ * String , "apple" } as C) := (let { E , d } = unit in unit))))
(! (\ D : (Star => Star) . ((if a then "apple" else c) (succ 0))))
(ref (({ b = (! "apple") , a = 2 }) (succ ((let { C , a } = 2 in false) as (All C : Star . C)))))
(pred ({ d = (\ D : ((Star => Star) => Star) . ((pred "apple") := (fix 2))) , c = (fix (\ e : Unit . "boy")) }))
(((fix b) (ref (ref 0))) := (! ((if (let { D , c } = c in a) then (\ D : Star . a) else (unit 0)) as ({ Some B : Star , Nat }))))
(! (pred (fix "apple")))
(\ C : ((Star => Star) => (Star => Star)) . (iszero (pred (iszero 1))))
((if (fix "apple") then (ref (b := 2)) else (ref "apple")) . c)
(fix (fix ((! (iszero true)) [ ({ d : Float , c : Nat }) ])))
((("boy" := false) (let c = 2 in 0)) as (All E : ((Star => Star) => Star) . (({ Some E : Star , String }) ({ d : B , c : B }))))
(((pred true) as (\ A : (Star => Star) . Bool)) [ ({ Some C : ((Star => Star) => Star) , ((\ E : Star . Unit) ({ Some D : Star , String })) }) ])
(\ e : ({ Some E : ((Star => Star) => ((Star => Star) => (Star => Star))) , ({ Some E : (Star => Star) , (\ C : Star . C) }) }) . ({ * ({ Some E : ((Star => Star) => Star) , (All A : Star . C) }) , (1 [ Nat ]) } as ({ Some C : ((Star => Star) => (Star => Star)) , (Nat -> Nat) })))
({ * ((\ B : Star . (\ C : Star . A)) (({ c : String , d : Nat }) (Ref Nat))) , (\ D : ((Star => Star) => (Star => Star)) . (ref c)) } as ({ Some A : ((Star => Star) => (Star => Star)) , (\ B : ((Star => Star) => Star) . (Ref A)) }))
(iszero (iszero ("boy" [ B ])))
({ d = (((succ ({ e = "boy" , c = unit })) := (! 1)) (iszero (succ 1))) , a = ((unit false) [ (All D : (Star => Star) . ({ e : Float , a : String })) ]) })
(pred (iszero ((! unit) := 2)))
((\ c : (Ref (All A : Star . String)) . (let b = (iszero "apple") in (fix 0))) as ({ a : ({ d : (Ref Bool) , c : Nat }) , c : (Float (B -> Unit)) }))
((pred ((a := false) . e)) ({ * (All D : (Star => Star) . (All C : Star . B)) , ({ a = ({ c = a , b = (\ b : Float . c) }) , d = (ref b) }) } as (\ B : ((Star => Star) => (Star => Star)) . ({ Some E : Star , Unit }))))
({ * ({ d : (B -> String) , e : (Ref (Nat -> Float)) }) , (if (ref 0) then (\ E : Star . "apple") else (succ c)) } as (\ D : (((Star => Star) => (Star => Star)) => ((Star => Star) => (Star => Star))) . ((Ref Bool) (C -> String))))
(! (fix (fix 1)))
((fix (succ (ref (if 0 then 2 else true)))) ({ b = (fix "apple") , a = (pred unit) }))
((\ a : (Ref Bool) . ("boy" := a)) := ((2 as A) := (fix "apple")))
(let { C , a } = (fix ({ * C , ({ d = 2 , d = true }) } as (All C : Star . Bool))) in (((if true then true else 1) . c) := (({ * (\ D : Star . Nat) , (2 0) } as Nat) as ({ Some E : Star , Nat }))))
({ c = ((false as ({ c : B , e : Unit })) := ({ * C , "apple" } as B)) , c = ((\ D : (Star => Star) . (ref c)) := (pred (let { C , d } = (succ true) in (iszero 1)))) })
(fix (iszero (pred true)))
(! (if (succ (fix c)) then (succ (false as (All B : Star . C))) else ({ * ({ c : Unit , c : String }) , "boy" } as Float)))
((let d = ({ b = (fix "apple") , d = (if "boy" then unit else (succ b)) }) in (if "boy" then a else (ref b))) [ (\ B : (Star => Star) . (Ref (All E : Star . Bool))) ])
(pred ({ e = (unit [ (Ref Float) ]) , d = (\ d : (All D : Star . B) . ("apple" := b)) }))
((! (let b = (fix true) in (if 2 then 1 else 1))) as ((Float -> String) (Float ({ b : String , d : Float }))))
(iszero (\ E : (Star => (Star => Star)) . (1 as ({ d : String , a : String }))))
({ * (({ Some B : (Star => Star) , ({ Some A : Star , Bool }) }) ({ Some E : Star , C })) , (let d = (let e = (if c then "boy" else unit) in ({ * Bool , ("apple" . e) } as Unit)) in (succ (iszero (ref 1)))) } as (\ C : (Star => (Star => Star)) . (\ B : Star . (All C : Star . Nat))))
(succ (ref (succ 2)))
(((fix a) . c) [ ((\ B : Star . Bool) (\ A : Star . String)) ])
(fix (\ d : (({ c : (\ D : Star . C) , d : ({ Some B : Star , B }) }) (All B : Star . Unit)) . (succ (\ e : ({ a : B , c : A }) . (! 2)))))
(iszero (pred (iszero (let { E , e } = 2 in "boy"))))
({ * (All E : (Star => Star) . (All C : Star . Unit)) , (let { A , b } = (\ A : (Star => Star) . ({ d = 1 , a = 1 })) in ({ a = (false 0) , a = (ref 0) })) } as (\ E : ((Star => Star) => (Star => Star)) . (\ D : (Star => Star) . (Nat -> Unit))))
(\ a : ({ d : (Nat A) , c : (Ref Bool) }) . (({ b = ("apple" := "boy") , d = ({ * Nat , c } as Float) }) (\ c : (All A : Star . Nat) . (2 [ Bool ]))))
((\ c : (({ Some E : Star , A }) -> (Unit Unit)) . ({ * (\ E : Star . Float) , (let d = true in b) } as ({ Some B : Star , Nat }))) (((a . c) as (All E : Star . A)) (pred (fix unit))))
((\ c : ({ Some D : Star , Nat }) . (\ a : (String String) . (let a = c in unit))) . e)
((fix ({ * ({ d : A , e : C }) , true } as (A B))) := (let e = (\ B : (Star => Star) . (false [ A ])) in (pred (if 0 then 2 else a))))
(let { D , d } = ((ref 1) := (\ D : Star . 1)) in (if ((\ e : Bool . "apple") as Unit) then (b as Float) else (\ B : Star . (0 2))))
(let c = (iszero (! (fix 2))) in ({ * ((Ref Unit) ({ d : Nat , c : Nat })) , (succ (unit . b)) } as (Ref (Bool (C -> C)))))
(\ c : (All D : (Star => Star) . (Ref (\ E : Star . Float))) . ({ * (\ E : (Star => Star) . ({ Some C : Star , Unit })) , ((pred unit) := (let c = 1 in false)) } as (All C : Star . Unit)))
(((\ c : B . false) (let { E , a } = "apple" in a)) as (\ E : (((Star => Star) => Star) => (Star => Star)) . (\ A : Star . Float)))
((\ E : ((Star => Star) => (Star => Star)) . (let { D , d } = a in (\ a : A . 2))) [ ({ b : (Ref String) , a : (\ B : Star . (Ref Nat)) }) ])
(\ c : ((All C : (Star => Star) . Float) (All D : (Star => Star) . (\ C : Star . B))) . (! (let { B , c } = ({ d = "apple" , b = 2 }) in "apple")))
(pred (iszero (fix 0)))
({ * (({ Some E : Star , Nat }) (Ref B)) , (iszero ({ * (B -> B) , (\ B : Star . c) } as ({ a : Nat , b : Bool }))) } as (({ c : ({ Some E : Star , B }) , c : B }) -> (\ C : Star . ({ Some D : Star , Unit }))))
(ref (succ (fix (succ c))))
(\ d : (All E : (Star => Star) . ({ c : B , b : Bool })) . (if (\ c : String . b) then ({ d = "boy" , a = false }) else (1 . c)))
(if (\ B : (Star => (Star => Star)) . (\ A : Star . (fix a))) then ((let b = (c b) in (2 b)) . c) else ({ c = (let a = "boy" in true) , d = (\ B : Star . c) }))
(let { D , e } = ((ref (c "boy")) [ (Ref Nat) ]) in (if (\ a : Unit . 1) then (let { C , c } = 1 in b) else (unit [ Nat ])))
((fix ({ * ({ d : Unit , e : B }) , ({ a = a , c = c }) } as (\ C : Star . C))) . d)
({ d = (\ e : ({ c : C , c : Unit }) . (a 0)) , d = ({ b = (let b = (let { B , a } = 1 in 0) in (true as Float)) , c = (succ (fix a)) }) })
(! (succ (0 . b)))
((fix (pred c)) := (let { E , a } = (let { E , e } = b in (fix a)) in (if 0 then "boy" else false)))
(((ref (fix c)) . b) [ ({ Some C : ((Star => Star) => Star) , (Ref String) }) ])
(let b = (((false a) . d) (\ E : Star . c)) in ((let { B , c } = (ref a) in c) as (Ref C)))
(\ D : ((Star => Star) => (Star => Star)) . (if (iszero true) then (("apple" false) . e) else (\ a : A . "boy")))
(\ E : ((Star => (Star => Star)) => (Star => Star)) . (iszero (if 2 then c else 0)))
(let a = (({ b = ({ * C , 1 } as Float) , c = (iszero b) }) . d) in (pred (iszero false)))
((succ (((1 := "apple") := ({ c = 2 , b = 0 })) . b)) as (Ref ({ a : Bool , c : Float })))
(! (ref (a := a)))
(succ (\ E : (Star => Star) . (let { E , e } = 1 in (b := "boy"))))
(((pred false) ((pred ({ * Float , c } as String)) ((pred 1) b))) as (Ref (\ C : Star . Float)))
(succ (let { A , d } = (fix (let { E , a } = b in 0)) in (ref ({ b = true , e = 0 }))))
((succ (succ (pred false))) (fix (! (if b then false else 1))))
(iszero ((\ a : ({ Some B : Star , A }) . (2 := true)) (let e = b in (let { B , b } = c in 0))))
(if (! ({ * String , b } as C)) then ({ d = (\ e : ({ Some C : Star , C }) . a) , c = (if (let d = true in 1) then (if "apple" then true else c) else (let { B , a } = unit in 2)) }) else ((\ C : Star . (if false then a else 2)) . e))
((if (pred c) then (fix false) else (true := 2)) := (pred (iszero (fix b))))
(pred (succ (let e = (1 [ C ]) in (pred 1))))
(ref (succ (iszero (ref c))))
(ref (fix (! (let { A , c } = (iszero b) in 1))))
(((\ C : (Star => Star) . false) as (All C : (Star => Star) . A)) as (Ref (((C -> B) (Unit A)) ({ c : String , c : Float }))))
(let { E , c } = (if (! (unit as Float)) then ({ d = (\ D : Star . 2) , b = ({ * Nat , a } as Bool) }) else (pred c)) in (let { A , e } = ((if a then 1 else (! b)) . d) in ((succ true) . c)))
(((\ D : Star . unit) := ("apple" as Unit)) (\ A : (Star => Star) . (({ e = 1 , b = b }) . a)))
(let { C , b } = (succ (pred 0)) in (pred (\ a : ({ a : Float , c : A }) . (succ b))))
(let c = (if (ref 2) then ({ c = "apple" , a = 2 }) else ({ * C , (2 [ Bool ]) } as Unit)) in ({ c = (pred (true . e)) , c = (fix ({ d = b , e = "boy" })) }))
(if ({ * ({ a : (All A : Star . C) , a : (Ref Nat) }) , (0 unit) } as (\ D : Star . Float)) then (pred (unit := true)) else (succ (! (if c then true else c))))
((succ ({ * Unit , (fix false) } as (All B : Star . Nat))) := (let b = (((pred 0) (1 := a)) [ ({ c : Float , b : Bool }) ]) in (if (pred 2) then (let a = c in b) else (\ C : (Star => Star) . c))))
(! (("apple" as Unit) [ (All A : (Star => Star) . (\ E : Star . Bool)) ]))
(iszero (ref ({ * (A Bool) , ("boy" as String) } as (String String))))
((let { E , a } = (let { A , a } = (\ b : A . 1) in (let c = 1 in "boy")) in (iszero (fix 0))) := ({ * (All C : (Star => Star) . String) , (if ((let { E , e } = "boy" in false) := 0) then (\ C : (Star => Star) . (a := 1)) else ({ * C , "apple" } as (String Nat))) } as (\ E : (Star => Star) . Bool)))
(! (ref (ref "boy")))
(fix (fix ((succ "boy") [ ({ d : Float , d : A }) ])))
({ * (All D : (Star => Star) . (All A : Star . A)) , (({ * (Unit -> A) , (\ D : Star . true) } as B) := (pred false)) } as (({ Some E : (Star => Star) , (All A : Star . Bool) }) -> (Nat Bool)))
(let { C , d } = (((fix 0) . c) as ((Ref Nat) -> String)) in (ref (! b)))
((if ("boy" [ ({ e : String , b : Nat }) ]) then (ref (pred "apple")) else ({ e = false , a = a })) . b)
(! (fix (if (let { B , b } = c in "boy") then (\ C : Star . false) else 0)))
(({ * ((All C : Star . A) -> A) , (succ a) } as (\ C : (Star => Star) . ({ Some D : Star , C }))) [ ({ e : (Ref Nat) , c : (Unit (Ref Bool)) }) ])
(let c = ((if (fix "boy") then (iszero "apple") else (iszero 2)) as (String -> (Bool Float))) in (succ (let { C , d } = b in (unit as B))))
(let { A , d } = (! (! (\ d : B . unit))) in (pred (\ B : (Star => Star) . 0)))
(let d = ((iszero (let a = 1 in 0)) [ ({ Some D : ((Star => Star) => (Star => Star)) , (Ref ({ Some B : Star , A })) }) ]) in ((2 . c) . c))
(if (("boy" [ ({ a : Float , c : Nat }) ]) as (Ref String)) then (let b = (fix "apple") in (fix "boy")) else (let { E , b } = (succ c) in ({ * C , (c as Float) } as ({ Some C : Star , Unit }))))
({ c = (fix (\ B : Star . "boy")) , c = (\ a : (({ c : C , a : Unit }) (Bool -> C)) . (! 1)) })
((! ({ e = "apple" , d = false })) . e)
(if (iszero (let a = 1 in "apple")) then ((fix c) [ (Ref (Float A)) ]) else ((let { C , d } = ({ c = (if b then true else c) , b = (pred 0) }) in (2 b)) . d))
(let a = (iszero (pred 1)) in (iszero ((\ C : Star . "apple") . a)))
(fix (((succ "apple") [ Bool ]) := (if a then unit else "boy")))
(iszero (let c = (\ C : Star . b) in (! c)))
((\ a : ((C String) -> ({ b : String , e : Unit })) . (succ 2)) as (Ref (({ Some E : Star , Float }) -> Unit)))
(iszero (let { B , e } = (let { B , d } = b in (let { E , e } = c in 2)) in (if "boy" then (0 [ B ]) else unit)))
(pred ({ * (All E : Star . Unit) , (ref c) } as (\ D : (Star => Star) . (({ a : C , b : Unit }) -> Nat))))
(({ * (All C : Star . (All C : Star . B)) , (fix (if a then a else b)) } as ({ Some E : (Star => Star) , (Ref A) })) as ({ Some E : (Star => Star) , (Ref Float) }))
((! (let d = (false [ String ]) in (\ A : Star . "boy"))) (iszero (fix (if b then false else c))))
({ c = (iszero (iszero a)) , a = (({ e = (! 2) , a = false }) as (Ref (\ B : Star . A))) })
(let a = ((\ b : (Bool A) . ((\ e : A . b) . b)) as ((\ E : Star . Bool) -> B)) in (let { E , e } = ({ * C , a } as Float) in (pred true)))
({ c = ((b as Unit) . c) , c = (\ b : ({ c : (Bool -> String) , d : ({ Some C : Star , String }) }) . (\ b : (All B : Star . Unit) . 1)) })
(\ a : ({ Some B : ((Star => Star) => (Star => Star)) , ((String -> (All D : Star . A)) (\ A : Star . Bool)) }) . ({ d = (ref ({ * Unit , unit } as (\ A : Star . String))) , d = ({ a = (iszero "apple") , d = (true a) }) }))
(succ ({ a = (((2 as String) [ String ]) := (1 . b)) , b = ({ * ({ Some B : Star , Bool }) , 2 } as B) }))
(let { C , a } = (let b = (\ E : Star . (if 1 then c else b)) in (let c = ({ c = (let { A , c } = 1 in c) , a = 2 }) in (pred 0))) in (ref (1 (\ b : Float . false))))
(pred (ref (let b = a in ({ c = unit , e = "boy" }))))
((succ (if (let { D , d } = b in false) then (0 := 2) else 1)) [ (\ A : ((Star => Star) => Star) . (\ C : (Star => Star) . (Ref Nat))) ])
((succ (\ B : Star . true)) := (if (\ a : (Float Unit) . (ref unit)) then (if 2 then ({ a = unit , a = "apple" }) else "boy") else (succ (! c))))
(({ * (Nat -> Float) , (b := 2) } as (\ C : Star . Float)) [ ((All D : Star . C) -> (All A : (Star => Star) . String)) ])
(ref ((iszero "apple") := (ref 1)))
(\ c : (All D : (Star => Star) . (A -> Nat)) . (((iszero (! "apple")) := (0 as Bool)) . b))
(succ (succ (iszero (fix c))))
({ * ((\ B : (Star => Star) . ({ Some B : Star , B })) ({ Some C : (Star => Star) , (B Unit) })) , (let a = (pred (! 2)) in (iszero (iszero (\ C : Star . 1)))) } as ({ c : (Unit Unit) , e : ((Ref B) -> (String -> Nat)) }))
(\ B : (((Star => Star) => Star) => (Star => (Star => Star))) . ((\ C : ((Star => Star) => Star) . ("boy" [ B ])) [ (\ C : Star . Nat) ]))
({ c = ((iszero (\ b : Nat . 0)) . d) , c = (iszero ((succ (succ 1)) := (let d = (b . e) in (if "boy" then false else a)))) })
(iszero (succ (ref (iszero 0))))
(iszero (\ B : (Star => Star) . (let c = c in c)))
(let c = (ref (a := (iszero 1))) in (pred (succ a)))
(let d = ((let a = 0 in ({ * C , true } as Float)) . c) in (pred (! (fix (ref unit)))))
({ * (All A : (Star => Star) . ({ Some E : Star , (Bool -> Nat) })) , ((unit [ Unit ]) := (ref "apple")) } as (All C : (Star => (Star => Star)) . (All C : Star . String)))
(ref (fix (let a = a in (pred false))))
(fix (iszero ((ref c) "apple")))
({ * (All A : (Star => Star) . ({ Some B : (Star => Star) , Float })) , (iszero (iszero c)) } as ((All B : Star . ({ Some D : Star , Unit })) (Ref Nat)))
(\ A : ((Star => Star) => (Star => (Star => Star))) . (! (! a)))
(pred (! ((b [ (All B : Star . B) ]) . c)))
(({ * (C -> B) , (a as Unit) } as ({ e : B , e : Nat })) ((fix (b . a)) . a))
((\ e : (\ C : Star . (\ E : Star . B)) . (ref true)) := (iszero (\ A : Star . unit)))
((ref (\ d : (C -> B) . (! (if 0 then 2 else 2)))) . e)
({ e = (\ e : (All E : Star . B) . (ref c)) , c = (if (fix a) then (\ D : Star . 1) else (iszero false)) })
(iszero (({ c = 0 , e = "apple" }) [ ((Bool -> Nat) -> C) ]))
(\ b : (\ E : (Star => Star) . (All B : (Star => Star) . String)) . (let e = (1 . d) in (iszero 2)))
(let { A , e } = (succ (true as (\ A : Star . Float))) in (\ E : ((Star => Star) => (Star => Star)) . (fix false)))
(let { D , e } = (\ c : (Ref String) . (let { B , b } = (\ a : Float . "boy") in (ref "apple"))) in ((pred (let c = (if c then true else 0) in (if true then c else b))) (succ c)))
({ d = ((fix true) := (let a = (let c = true in c) in a)) , e = (! (true := (let e = 2 in true))) })
((\ B : (Star => Star) . (succ (\ c : A . 0))) ({ d = (({ e = a , e = "apple" }) . c) , d = (fix false) }))
(iszero ((ref 0) [ (Bool -> Float) ]))
((\ C : ((Star => Star) => Star) . ({ b = (let { B , c } = (iszero true) in true) , b = (let b = "apple" in 1) })) as ({ c : (All A : Star . C) , d : ({ Some A : Star , Unit }) }))
({ d = (! (a := unit)) , a = (pred ({ c = (\ d : C . unit) , d = (let { A , b } = b in unit) })) })
(((("apple" := ({ * String , 2 } as Nat)) . b) := (pred (if a then true else 2))) := (succ (succ ({ d = false , e = 0 }))))
(let { C , d } = (let d = (pred "boy") in (c as C)) in ((succ true) as ((\ A : Star . C) ({ Some D : Star , Nat }))))
({ * ((Ref Bool) ({ Some B : (Star => Star) , ((All E : Star . String) -> ({ d : A , d : Nat })) })) , ((c as Float) := (iszero (if "apple" then "boy" else 2))) } as (\ A : (Star => Star) . (\ D : (Star => Star) . String)))
(if ({ * (Ref (All E : Star . Unit)) , (! 2) } as (({ Some E : Star , A }) (All A : Star . Float))) then ((succ (let b = (iszero c) in ({ * Bool , b } as Nat))) . b) else (succ ((! true) unit)))
((let { B , a } = (iszero "boy") in ("boy" (fix 2))) := (let { A , e } = (succ (pred (ref 0))) in ({ b = 1 , a = (succ 2) })))
((! (\ c : String . (\ e : B . 1))) as (Ref (\ B : Star . B)))
(let e = ((let e = b in (ref 0)) [ (All C : (Star => Star) . ({ Some B : Star , Bool })) ]) in (\ D : (Star => (Star => Star)) . (ref (0 . c))))
(\ D : ((((Star => Star) => Star) => ((Star => Star) => (Star => Star))) => (Star => Star)) . (({ * B , 1 } as Unit) . e))
(succ (let a = (\ A : (Star => Star) . ({ e = "apple" , b = 0 })) in (iszero ((\ A : Star . 2) . c))))
(pred (succ ({ a = true , e = 2 })))
(pred ((succ (\ B : Star . a)) as (Ref ({ Some B : Star , C }))))
((succ (pred 1)) (((\ c : Float . (false a)) as (Ref (Nat B))) ((fix "apple") . e)))
(if (! (\ B : (Star => Star) . true)) then (((pred 2) false) (if (unit as String) then ({ * (All B : Star . B) , "boy" } as (Unit C)) else (succ (ref 2)))) else ({ e = (fix 0) , b = ({ c = (\ E : Star . "apple") , b = (if "boy" then true else unit) }) }))
(! ((ref (false := b)) as (All D : Star . String)))
(iszero (let { E , c } = ({ * String , (unit b) } as B) in (\ E : Star . 2)))
(iszero (ref (\ D : Star . (succ unit))))
(iszero (iszero (let a = unit in 0)))
(ref ((\ a : ({ Some D : Star , A }) . unit) [ (\ A : (Star => Star) . Bool) ]))
(iszero (\ B : (((Star => Star) => (Star => Star)) => ((Star => Star) => Star)) . (let { B , a } = (if 0 then (fix 2) else unit) in (! 0))))
(ref ((if (a as C) then (pred b) else (ref 1)) (let { B , c } = (0 . a) in ({ c = "boy" , e = a }))))
((pred ({ b = (unit b) , e = 1 })) ((\ c : Float . "boy") := ((1 [ B ]) := (let { C , a } = "apple" in true))))
((let a = (c as A) in (succ 1)) (((if true then 0 else unit) as C) as ({ Some A : (Star => Star) , B })))
((({ * ({ c : C , a : B }) , (if true then "apple" else 0) } as Bool) [ (\ A : (Star => Star) . B) ]) . b)
(fix (\ c : ({ d : ({ Some D : Star , B }) , a : B }) . (iszero false)))
(if ({ d = ({ c = a , e = ({ * C , 0 } as Float) }) , e = (ref 2) }) then (\ e : (\ B : (Star => Star) . ({ b : Float , a : Nat })) . ((true as B) [ ((Bool -> Bool) Float) ])) else ((ref false) := ({ * A , "boy" } as String)))
(pred (pred (fix c)))
((\ D : (Star => (Star => Star)) . (pred (pred 0))) as (All A : (Star => Star) . ((Ref String) -> ({ Some E : Star , String }))))
(\ A : ((Star => Star) => (Star => (Star => Star))) . ((fix b) as ({ Some E : (Star => Star) , (\ D : Star . Float) })))
(let d = ({ * (Nat String) , ({ d = (\ a : String . 2) , b = ({ * Bool , "boy" } as Float) }) } as ({ Some E : (Star => Star) , B })) in (fix (succ unit)))
(pred (\ C : (Star => Star) . (iszero ({ * C , unit } as String))))
(fix (ref ({ * Nat , ({ c = b , b = a }) } as A)))
(let b = (fix ((iszero false) := c)) in (let e = (1 as Bool) in (b . c)))
(let b = (pred (\ C : ((Star => Star) => (Star => Star)) . (pred a))) in (! (let { D , c } = "apple" in 0)))
(pred ((pred true) as (A Unit)))
(\ D : ((Star => (Star => Star)) => (Star => Star)) . (succ (pred (c . c))))
(pred (\ c : (Float (Nat A)) . (\ c : String . "apple")))
(pred (succ (pred (\ b : Bool . "apple"))))
(\ c : (Ref (({ e : B , a : Nat }) -> ({ b : Bool , c : B }))) . (if (if (if c then a else "apple") then (let { B , d } = a in true) else (let a = (2 := false) in unit)) then ({ * (String A) , (\ C : (Star => Star) . 2) } as (Bool -> (C String))) else ((iszero a) := (let { C , c } = true in unit))))
(let d = (fix (pred "apple")) in (((\ a : Nat . "apple") (c as Nat)) := (! ({ b = "apple" , c = false }))))
(! (((iszero b) . e) (if (succ 2) then (\ d : Bool . "boy") else (a := (pred "apple")))))
(ref (if (let { B , a } = (if 1 then false else a) in b) then (let b = "boy" in (ref false)) else ({ c = (\ D : Star . "boy") , c = (\ B : Star . false) })))
(if (iszero (succ unit)) then (iszero (iszero (fix 0))) else (fix (pred (let d = (ref unit) in (if c then 1 else b)))))
(((\ e : B . "boy") as ((\ A : Star . C) String)) [ (All A : (Star => Star) . (Nat String)) ])
(iszero ((pred (succ 2)) := (2 as ({ Some E : Star , C }))))
(let { A , c } = (({ b = "apple" , c = "apple" }) . c) in (! (2 := 2)))
(fix (({ d = 0 , a = 1 }) ({ * C , 2 } as Nat)))
((((ref false) as (String String)) . b) := ({ * (Float ({ e : String , a : Nat })) , (fix (let { C , a } = unit in 1)) } as ((\ B : Star . Float) Nat)))
(\ E : ((Star => (Star => Star)) => (Star => Star)) . (! (pred c)))
(\ c : ((All E : (Star => Star) . (All B : Star . B)) (Ref A)) . (succ (pred (iszero (0 := "apple")))))
({ * (Ref (B (Ref A))) , (if ((! false) := "boy") then ({ * (Bool Bool) , unit } as Bool) else (let { A , d } = (let a = 1 in "apple") in (pred 2))) } as (All E : (Star => (Star => Star)) . ((All E : Star . Nat) -> Unit)))
(succ ((let b = 0 in 0) . a))
(iszero (succ (iszero ({ b = a , d = b }))))
(fix (let { C , a } = ((iszero false) := (\ E : (Star => Star) . a)) in ({ e = (let d = a in 1) , c = (0 [ Bool ]) })))
({ b = ((pred 2) := (fix b)) , c = (\ B : (Star => (Star => Star)) . (if ((\ D : Star . 0) . c) then (ref (if "boy" then "boy" else 2)) else (let d = false in "apple"))) })
(succ (succ (iszero (\ D : Star . false))))
(succ ((c [ String ]) . b))
(succ (fix (\ b : String . unit)))
((\ C : ((Star => Star) => (Star => Star)) . ((unit false) := (c as B))) (let { A , c } = (let a = (! b) in (\ B : Star . "boy")) in (\ c : (Nat Bool) . ("apple" [ Nat ]))))
(iszero (let { E , e } = (iszero "boy") in (iszero (if 2 then unit else 2))))
(let a = (\ c : (All E : (Star => Star) . C) . ((fix 0) := unit)) in (pred ({ * C , true } as Bool)))
(({ * (All A : (Star => (Star => Star)) . (A Unit)) , ({ * (Unit String) , (b := true) } as ({ b : B , b : B })) } as (Ref (\ C : Star . C))) . a)
(((false [ Nat ]) as (All A : Star . A)) . e)
((if (0 as ({ Some D : Star , Nat })) then (c [ A ]) else (iszero (let e = "boy" in b))) [ ((\ B : (Star => Star) . (Ref B)) -> (Ref ({ c : Float , b : A }))) ])
(succ ({ c = (({ * A , unit } as A) (b := 0)) , d = (let { E , d } = (unit . c) in (0 [ B ])) }))
(if ((ref (fix true)) := (succ 2)) then (ref (let e = 1 in "boy")) else (({ * ({ Some C : Star , Bool }) , (\ D : Star . (fix 2)) } as (\ E : Star . A)) := ({ * C , true } as Bool)))
(iszero ((ref (if true then b else true)) as (\ E : ((Star => Star) => (Star => Star)) . (Ref Unit))))
(if (iszero (fix false)) then (iszero (fix (let { D , c } = b in b))) else (let { B , b } = (fix unit) in (\ e : ({ d : A , a : String }) . (let { C , b } = 0 in b))))
(ref ((fix (b . e)) . d))
(((succ 0) (\ a : B . 0)) [ ({ Some B : (Star => (Star => Star)) , ({ Some B : (Star => Star) , ({ Some C : Star , B }) }) }) ])
(fix (\ B : ((Star => Star) => ((Star => Star) => (Star => Star))) . (! (let { A , e } = false in (fix a)))))
({ c = (iszero (if unit then (let { B , b } = c in "apple") else (ref b))) , b = (\ e : (\ C : (Star => Star) . ({ c : Unit , a : String })) . ({ d = false , e = unit })) })
(let b = ((succ 0) := (a [ String ])) in ({ * ((A C) -> (\ A : Star . Unit)) , (({ * B , b } as Nat) 2) } as (All D : Star . B)))
(pred (succ ((! 0) (fix "apple"))))
((ref (! (fix ({ * String , "boy" } as A)))) [ (All E : (Star => (Star => Star)) . (Ref Nat)) ])
(((succ (fix 2)) [ (\ D : (Star => Star) . (Bool -> Float)) ]) . d)
(pred (\ C : ((Star => Star) => (Star => Star)) . (\ E : Star . true)))
({ * ((All B : ((Star => Star) => (Star => Star)) . ({ b : Float , d : Bool })) -> (B -> (Ref Float))) , (fix (let { C , b } = true in unit)) } as ({ Some B : (Star => (Star => Star)) , (Ref ({ b : Bool , a : C })) }))
((let a = (ref "boy") in (({ b = "boy" , e = 2 }) 2)) := ({ a = (a := "boy") , b = (\ C : Star . 2) }))
(! (succ ((if c then 0 else 0) := (if "apple" then 2 else "boy"))))
((((! "boy") (false := "apple")) . b) . a)
(succ (succ ({ c = b , e = b })))
(\ A : ((Star => (Star => Star)) => ((Star => Star) => (Star => Star))) . (succ (succ 2)))
((iszero ((iszero "boy") [ (Unit Bool) ])) ((if c then c else "apple") := (pred (! (pred "apple")))))
(iszero (! (\ c : (All B : Star . Nat) . 2)))
((let { C , b } = (let b = ("apple" [ String ]) in (false := 2)) in (ref (let c = false in "boy"))) as (All B : ((Star => Star) => (Star => Star)) . ((All A : Star . C) (\ C : Star . Float))))
(! (fix (pred 2)))
(ref (((ref c) (iszero c)) := ((\ c : B . true) ({ b = c , c = a }))))
((\ B : (Star => Star) . (if (let a = (unit true) in 2) then ({ c = 0 , b = (\ a : String . 2) }) else (pred "boy"))) := ({ * ({ c : (All A : Star . String) , c : ({ d : String , c : Float }) }) , (fix c) } as ({ a : String , a : C })))
(({ * (All B : Star . Bool) , (iszero "apple") } as ((\ C : Star . Unit) Unit)) . b)
(let { D , b } = (! (if a then "boy" else "apple")) in (succ (b as Bool)))
(if ((\ a : (All A : Star . Float) . ("boy" . c)) (\ a : (\ A : Star . A) . (fix false))) then ((\ e : (\ B : Star . Float) . (c as Float)) . c) else (iszero (ref true)))
(fix (let { C , d } = (\ e : ({ c : ({ b : C , c : Bool }) , e : (String -> B) }) . (pred true)) in (\ e : Unit . (iszero c))))
((\ A : ((Star => Star) => ((Star => Star) => (Star => Star))) . ((if ("apple" . b) then 2 else 2) [ (Ref (Ref C)) ])) as ((\ E : (Star => Star) . (B -> Unit)) -> (Ref Unit)))
(ref ((ref ({ * C , false } as Unit)) := ((a 0) := (iszero false))))
(if (! (let a = (b [ B ]) in (1 (0 . a)))) then (let b = (let { A , e } = c in true) in (fix (1 . b))) else ((! (iszero unit)) (unit . c)))
(\ d : (((\ A : Star . Unit) -> (C -> B)) -> ({ d : (Nat -> B) , c : Bool })) . (ref (\ B : (Star => Star) . "boy")))
((ref (if false then b else (! b))) as ({ b : ({ d : Nat , d : A }) , d : ((Ref A) -> (C -> String)) }))
(let a = ((iszero "boy") (pred "boy")) in ((succ (fix 1)) [ ({ b : ({ c : Float , d : String }) , d : (Float -> Unit) }) ]))
((((! (let { A , c } = b in a)) [ (All C : Star . Bool) ]) := (let { D , d } = (! true) in ({ d = (ref "apple") , c = (let { C , b } = "boy" in unit) }))) . b)
(if (pred ((a as Nat) (iszero "boy"))) then (fix (true := (let e = a in true))) else (let { A , b } = ({ c = unit , d = true }) in (a . b)))
(succ (({ * (All A : Star . Nat) , (let a = c in false) } as C) ((succ b) := a)))
({ e = (iszero ({ a = (pred c) , b = true })) , a = ((iszero (let e = false in c)) := ({ a = ({ b = c , c = true }) , a = (let { A , b } = true in b) })) })
(succ ((let c = ({ a = c , b = a }) in unit) as (Float Float)))
(ref (let b = (if b then (iszero 1) else "boy") in (\ c : String . "apple")))
(fix (! (true [ Nat ])))
(succ ({ b = (pred "apple") , b = ({ c = 1 , b = (ref b) }) }))
(ref (\ a : ({ Some B : Star , Float }) . (({ * C , 0 } as A) := 0)))
((if (fix (0 [ ({ Some E : Star , Unit }) ])) then ({ d = "boy" , d = c }) else (if ((if "boy" then a else true) := (1 . a)) then ((2 a) := (\ b : B . false)) else ("apple" := "apple"))) . a)
(ref (succ (if (succ b) then ({ a = 2 , a = "apple" }) else ({ e = false , d = a }))))
(if (iszero (let e = "apple" in (succ b))) then ((pred c) := ({ * B , a } as B)) else (if (if 0 then c else true) then (\ A : Star . unit) else (fix "boy")))
(({ e = (iszero b) , c = (b . e) }) := (let a = ({ * (\ C : (Star => Star) . ({ a : A , e : B })) , (fix true) } as ({ b : C , c : String })) in ((pred 1) . c)))
(! (! (\ C : (Star => Star) . b)))
((\ A : ((Star => Star) => Star) . ((succ "boy") as (A -> Float))) ((if 2 then 2 else (2 as String)) . e))
(let { B , b } = ((fix "boy") := (fix false)) in ({ e = (if true then 2 else 0) , d = (let e = "apple" in true) }))
(! (fix (fix (let e = false in true))))
(let { B , c } = (\ a : ((Ref Nat) ({ a : B , d : String })) . (\ c : (All A : Star . Float) . "apple")) in (let { B , e } = (2 := a) in (b [ String ])))
(\ a : (\ B : (Star => Star) . (B Float)) . (if ({ b = "boy" , e = 0 }) then (\ E : Star . 1) else (\ D : Star . c)))
((\ a : (C (String C)) . (0 . b)) := (\ a : (Ref (All C : Star . Unit)) . (pred (succ (succ 2)))))
(! ((\ e : Bool . unit) as ({ Some C : (Star => Star) , (A A) })))
(iszero (("apple" . b) . c))
(succ (let { A , b } = (fix 0) in (false "boy")))
(ref (let b = (if (let b = (1 := c) in ({ c = false , d = b })) then ("boy" . a) else (ref "boy")) in (! (let b = b in a))))
((! (ref false)) := ((fix 2) := (unit := true)))
((! ((pred unit) . d)) (! ({ * A , false } as (All A : Star . Nat))))
(\ A : (((Star => Star) => Star) => (Star => Star)) . ((ref c) [ (Nat -> (\ B : Star . Unit)) ]))
(ref (ref (\ a : B . (if false then false else "apple"))))
(fix ({ * (\ D : Star . (String -> Bool)) , (a . b) } as (All B : ((Star => Star) => (Star => Star)) . ({ e : B , d : Nat }))))
(\ b : (Ref ({ b : (\ B : Star . Bool) , a : ({ Some D : Star , Nat }) })) . ((! (if unit then "apple" else true)) [ ({ d : (All E : Star . Float) , b : ({ a : Bool , c : String }) }) ]))
({ d = (iszero (ref (if unit then true else (unit as Bool)))) , c = (("boy" [ (\ C : Star . A) ]) [ ({ Some B : Star , (\ B : Star . B) }) ]) })
(pred (("boy" unit) ((if b then "apple" else a) as ({ a : Bool , d : A }))))
({ * (\ D : (Star => Star) . ({ Some B : Star , Unit })) , (! ({ d = 2 , a = (iszero 2) })) } as (\ A : (Star => (Star => Star)) . ({ d : Float , d : B })))
(! (\ A : (((Star => Star) => Star) => (Star => (Star => Star))) . (succ (\ b : Bool . "boy"))))
(if (if (\ d : ((\ A : Star . A) String) . ({ d = a , e = b })) then (succ (iszero 1)) else (2 [ ({ Some A : Star , B }) ])) then (pred ((iszero "boy") (ref b))) else ({ b = ((succ 2) c) , b = (fix (\ C : Star . 0)) }))
({ b = ((let c = (if "boy" then 1 else unit) in ("apple" 2)) . c) , c = (succ (pred (\ b : Bool . 1))) })
(succ ((c . c) [ (Float Nat) ]))
((let e = ((let c = a in b) [ C ]) in ((let e = 0 in b) . c)) . b)
(if (ref ((\ b : String . b) := (unit unit))) then (! ((ref (iszero 2)) as (Ref Unit))) else (fix (\ A : ((Star => Star) => Star) . ((\ A : Star . true) [ ({ c : Nat , c : C }) ]))))
(! (if (if c then c else "boy") then (\ e : (C Unit) . ("apple" [ Unit ])) else (ref (fix b))))
({ a = ({ d = (iszero "apple") , a = ({ c = true , a = unit }) }) , d = ({ c = (! ({ * Float , c } as String)) , b = (! ((true [ C ]) . a)) }) })
((("boy" as B) as (Ref A)) as ({ Some B : (Star => Star) , (\ A : Star . A) }))
(\ D : (((Star => Star) => (Star => Star)) => (Star => Star)) . (fix ({ * (\ E : Star . B) , ({ c = a , d = unit }) } as ({ b : C , e : Float }))))
(! (let d = (pred (! 2)) in (iszero (let { E , a } = a in b))))
(iszero (\ c : (\ D : Star . B) . (let { B , d } = "boy" in 1)))
(let b = (\ E : (Star => Star) . (let c = (! false) in a)) in (((0 false) as (All E : Star . String)) := ((let b = b in b) as ({ a : String , b : Nat }))))
(! (iszero ((ref (\ a : String . unit)) [ ({ Some B : (Star => Star) , A }) ])))
(if (iszero (a [ Unit ])) then ({ * (C (All D : Star . Unit)) , ({ * (Nat -> Nat) , (\ b : Float . "boy") } as (Ref String)) } as (({ Some C : (Star => Star) , (Ref Unit) }) -> ({ Some E : (Star => Star) , (Nat Nat) }))) else ((let { C , e } = unit in "boy") ({ * (\ C : Star . Nat) , (let { A , b } = 0 in "apple") } as Unit)))
({ e = ((\ D : (Star => Star) . b) . e) , c = (if (pred (succ false)) then (let e = c in b) else (let d = false in 2)) })
(let b = (succ (a . b)) in (pred ((1 . b) "apple")))
(let { E , b } = (\ d : (Unit -> String) . (if c then 1 else b)) in (! (2 . c)))
(({ * ({ Some B : (Star => Star) , (\ D : Star . (Ref C)) }) , ((! (succ 1)) := (let b = 2 in 2)) } as (({ e : B , a : B }) -> (Float String))) := (\ B : (Star => Star) . (iszero 1)))
(pred ({ b = (! 2) , b = (1 . d) }))
(let b = ((pred (c [ Bool ])) as (C -> (All E : Star . C))) in (let { C , c } = ((! 0) . d) in (iszero unit)))
(if (ref (let { D , a } = "apple" in true)) then (iszero (pred (succ a))) else (ref (if (a [ Nat ]) then (a 1) else (a . b))))
(((("apple" . c) . e) as (Ref B)) as (All E : (((Star => Star) => Star) => (Star => Star)) . ({ Some E : Star , ({ a : Unit , b : C }) })))
((iszero (let a = (iszero true) in (\ A : Star . a))) (let e = (\ e : (Bool Bool) . (fix 2)) in ((let e = 2 in unit) [ ({ e : C , b : B }) ])))
(iszero (\ E : ((Star => Star) => Star) . ((if 1 then unit else c) [ (({ Some D : Star , Nat }) (B Unit)) ])))
(let e = (\ D : (Star => Star) . (let { E , d } = true in 1)) in (succ (let d = a in "boy")))
(\ a : ({ d : ((Nat String) C) , d : ({ b : A , a : Unit }) }) . (let d = (fix (b as Bool)) in (\ b : (All E : (Star => Star) . (Ref Unit)) . (fix 0))))
((fix (let { B , d } = (pred "boy") in (\ a : Unit . "apple"))) := (\ d : (Ref Bool) . (b [ A ])))
(let b = (ref (! "boy")) in (if (iszero "boy") then (iszero (if 2 then a else unit)) else (let { C , a } = 0 in b)))
(let { E , b } = (! (pred 1)) in ((2 b) := (! "boy")))
(((let b = ({ * A , false } as Nat) in 0) . c) . b)
((let c = (pred "apple") in ({ * B , a } as ({ Some B : Star , Bool }))) ((1 (false 1)) as ((Float -> A) -> ({ b : String , c : B }))))
((ref (let c = 1 in 2)) ((0 . e) := ({ d = true , b = 1 })))
(let { B , a } = (\ b : ({ Some B : Star , Nat }) . (if true then 1 else 2)) in (let { A , b } = (1 . e) in (unit := b)))
((pred (\ d : (Float Nat) . ((\ c : B . false) . a))) as ((C Unit) ({ Some C : Star , C })))
(\ e : (All A : ((Star => Star) => Star) . (\ D : Star . B)) . (\ d : ({ Some D : Star , Float }) . ({ * Float , b } as Float)))
((\ a : ({ Some B : Star , Bool }) . (let d = "boy" in false)) . c)
(iszero (\ a : ({ b : Bool , c : Float }) . (if ({ a = b , a = b }) then ({ * Nat , true } as String) else true)))
(\ d : (All E : (Star => Star) . ((\ A : Star . Float) ({ e : A , c : Nat }))) . ({ * (\ D : Star . A) , (iszero 2) } as ({ c : A , e : Nat })))
((let { E , a } = (pred unit) in ("apple" ({ * C , 1 } as A))) as ((All A : Star . A) -> ({ b : Nat , d : Float })))
((iszero (\ a : (String -> Unit) . (iszero c))) as ((Ref Bool) -> (({ Some A : Star , Nat }) Nat)))
((pred (true . b)) . b)
({ e = (! ({ a = ({ * B , ({ d = c , c = false }) } as ({ d : C , c : Bool })) , b = (unit [ Nat ]) })) , d = (\ A : ((Star => Star) => (Star => Star)) . ((ref (b as C)) [ (C B) ])) })
({ * (\ C : (Star => Star) . ((Ref (Ref C)) ({ b : Bool , d : String }))) , (pred (! a)) } as ((All A : (Star => Star) . ({ e : String , e : A })) (\ C : Star . String)))
({ d = (\ d : (C Bool) . ("apple" := unit)) , c = (ref (\ B : Star . 1)) })
((iszero (let b = unit in a)) as (Ref (Ref (String String))))
((\ E : (Star => Star) . (iszero 0)) as ({ Some C : ((Star => Star) => (Star => Star)) , (\ C : (Star => Star) . ({ Some D : Star , C })) }))
((({ * (String B) , (fix c) } as (\ B : Star . Nat)) := (\ C : (Star => Star) . ((ref false) as Bool))) as ((All D : (Star => Star) . B) -> ({ Some C : (Star => Star) , ({ a : (Float Float) , a : String }) })))
(\ b : (\ B : ((Star => Star) => Star) . (Ref ({ c : ({ b : C , d : Unit }) , d : Nat }))) . ({ * (\ A : (Star => Star) . (C String)) , (pred (c [ B ])) } as (({ Some B : (Star => Star) , (Ref Bool) }) (Ref String))))
(\ c : (\ B : (Star => Star) . ((\ C : Star . String) (All B : Star . Unit))) . (let c = (true as Bool) in ({ * Nat , (let b = 1 in 0) } as (Unit -> A))))
(let { E , a } = (ref (succ unit)) in (((false [ Unit ]) := (\ b : Unit . 0)) [ (Ref (\ B : Star . B)) ]))
((! (let { C , a } = ("apple" 1) in (true 1))) as ({ e : (\ E : (Star => Star) . (Ref C)) , b : ({ Some A : Star , Unit }) }))
(let { A , e } = (! (ref "apple")) in (! ((\ B : (Star => Star) . (unit := a)) (let { B , b } = unit in c))))
(! (iszero (\ E : (Star => Star) . (fix 2))))
(let c = ((succ (\ a : A . 2)) [ (All D : (Star => Star) . (B String)) ]) in ((let c = (0 . a) in (ref 1)) . e))
(let c = ({ d = (let { D , d } = ({ c = "apple" , b = true }) in b) , a = (ref ("boy" . d)) }) in (! (let { E , e } = (\ b : Nat . "apple") in (fix 0))))
(\ B : ((Star => Star) => (Star => Star)) . (let b = (iszero 1) in (! "apple")))
((let c = (ref 1) in (\ E : Star . 1)) := (fix (0 as Unit)))
(ref (((0 := "apple") (iszero 1)) ((let { D , e } = 0 in 2) := ({ * A , c } as Float))))
({ * (\ E : (Star => Star) . (\ E : Star . Nat)) , (pred ({ b = "boy" , b = (\ B : Star . "apple") })) } as ({ b : (Ref ({ c : Bool , c : Float })) , c : (({ Some A : Star , String }) -> ({ b : Unit , b : B })) }))
(pred ((b 1) as (Bool Unit)))
(let e = (succ (succ a)) in (let b = ({ * (Ref String) , (iszero b) } as (Float -> String)) in (\ b : Bool . unit)))
({ * ({ e : (All C : ((Star => Star) => (Star => Star)) . ({ Some D : Star , C })) , a : ({ e : A , b : C }) }) , (if (if b then 0 else "apple") then (pred "apple") else (let { B , d } = true in "apple")) } as ({ e : (All B : (Star => Star) . (\ C : Star . A)) , e : (All A : ((Star => Star) => Star) . (Ref (All E : Star . Bool))) }))
((let { D , d } = (succ a) in (! true)) := (! ("boy" as C)))
(if (iszero (let c = (a as ({ b : A , d : B })) in ({ * (Ref B) , ({ a = "apple" , d = 1 }) } as (\ C : Star . C)))) then (fix (\ d : (\ C : Star . C) . (unit . d))) else ((false := false) := (iszero a)))
(if ({ c = (true [ Unit ]) , d = ((b := 2) := (\ C : Star . b)) }) then (pred ((ref (succ 1)) as ({ c : (Ref B) , e : (Ref Bool) }))) else (! (let d = (c := "boy") in (a . e))))
(! (fix ({ * (All E : Star . C) , (iszero "boy") } as Unit)))
(! (! ({ * (Ref Float) , b } as Bool)))
((let a = (ref (! b)) in (succ "boy")) . a)
({ * (\ E : (Star => Star) . (Unit A)) , ((! "boy") as (All C : Star . Bool)) } as (\ E : (Star => Star) . ({ Some A : (Star => Star) , ({ Some E : Star , Unit }) })))
(ref (let e = (fix 2) in (ref (c := true))))
((\ B : (Star => Star) . (pred "apple")) := ((iszero b) as ({ Some D : Star , B })))
(let e = (pred (let { E , c } = (a := 0) in (true [ String ]))) in (let { A , d } = (({ * String , "apple" } as C) := (let a = "boy" in 1)) in ((b as String) := (1 [ C ]))))
({ * ({ e : (All B : Star . Unit) , c : (({ b : C , d : A }) ({ b : String , b : Float })) }) , (fix (ref ((succ false) [ C ]))) } as ({ b : (All A : Star . Unit) , b : (All A : (Star => Star) . (\ B : Star . B)) }))
(\ b : ({ a : ((\ D : Star . Nat) -> (\ D : Star . Float)) , e : ({ b : Unit , a : Float }) }) . (iszero (\ d : String . (let { A , d } = 1 in 2))))
(let { E , b } = (let c = (! (\ B : Star . 2)) in ({ * ({ a : Unit , b : Float }) , (ref false) } as (({ e : C , c : Bool }) -> C))) in (let { A , b } = (let e = (pred "boy") in (fix false)) in (iszero (ref (if a then "apple" else "boy")))))
(let e = (let d = ((\ B : Star . "boy") [ Float ]) in (let c = c in c)) in (pred (ref (\ B : Star . "apple"))))
({ a = (((ref false) := (\ C : (Star => Star) . (pred 1))) := (({ b = 0 , d = a }) true)) , d = (let b = (let { E , e } = (\ B : Star . false) in (fix a)) in (ref c)) })
(! (("boy" 2) [ ({ d : B , c : Float }) ]))
(ref (if (2 . c) then (succ 1) else ("boy" . e)))
(! (if (! unit) then (let d = (iszero "boy") in (2 . b)) else (ref ({ e = ({ e = unit , b = "boy" }) , b = (unit "apple") }))))
(let { E , d } = (({ d = (false := c) , a = ({ * Nat , false } as Nat) }) (pred 1)) in (pred ((c as Nat) as ({ c : (B Bool) , b : (A -> C) }))))
((\ b : (\ C : (Star => Star) . (String -> C)) . (if (ref true) then c else (ref 2))) [ ((\ D : ((Star => Star) => (Star => Star)) . (Ref A)) ({ Some D : (Star => Star) , (All E : (Star => Star) . (String -> Bool)) })) ])
((succ (! false)) := (let { D , c } = (let { D , c } = (false := true) in 1) in (pred (let c = (pred false) in (let a = false in "apple")))))
(! ({ a = (ref "apple") , a = ({ c = "boy" , a = a }) }))
(if ((fix (let c = true in 2)) := (({ c = 2 , d = 2 }) as (All D : Star . Unit))) then (pred (ref unit)) else (iszero (ref ("apple" true))))
(fix (pred (ref true)))
(fix ((succ (let d = 0 in "boy")) . a))
(\ e : ((\ A : Star . Unit) -> (Ref Nat)) . (let b = (succ (c c)) in (\ b : (All C : Star . Unit) . "boy")))
(ref ((\ E : Star . a) := (succ (c true))))
(\ d : ((Ref String) -> (\ A : (Star => Star) . C)) . (iszero (if b then false else c)))
(\ C : (((Star => Star) => (Star => Star)) => (Star => Star)) . ((iszero (1 . e)) . e))
(! (let b = (if ("apple" [ ({ c : Float , c : Float }) ]) then (\ c : Float . b) else ({ * B , "apple" } as Bool)) in (let c = (pred a) in (succ 0))))
({ d = (pred (ref "apple")) , a = (\ b : (Bool ({ c : B , c : B })) . (let { A , e } = "boy" in true)) })
({ e = (ref ({ * Bool , unit } as (\ B : Star . String))) , d = (fix ({ a = false , c = (succ 1) })) })
({ a = (succ ("boy" [ String ])) , b = (fix (0 "boy")) })
(\ B : (((Star => Star) => (Star => Star)) => ((Star => Star) => (Star => Star))) . (succ (let a = "apple" in 2)))
(succ (ref ({ c = b , c = a })))
({ * ((Ref A) -> ((Ref Unit) -> Bool)) , ((pred (\ c : A . a)) (0 [ Bool ])) } as ({ Some A : ((Star => Star) => (Star => Star)) , (Ref (Bool -> Nat)) }))
((ref (pred (! b))) . a)
(pred (\ D : (Star => Star) . (iszero (ref true))))
(if (\ e : (Float Nat) . (pred 1)) then ((iszero "apple") (! 2)) else (succ (let { A , b } = "apple" in c)))
(\ E : (((Star => Star) => Star) => (Star => Star)) . (let b = ((a := 1) (1 [ String ])) in ({ d = 1 , a = true })))
(\ b : (\ D : ((Star => Star) => (Star => Star)) . (All B : (Star => Star) . ((C -> Bool) (C Float)))) . (fix (iszero a)))
(if ({ * ((All A : Star . Float) -> String) , (true [ Bool ]) } as (String Unit)) then (! (succ "boy")) else ((pred "apple") . b))
(! (pred ((true 0) [ Unit ])))
(\ C : ((Star => Star) => (Star => Star)) . (\ b : ({ b : A , d : C }) . (! a)))
((if (0 [ Float ]) then (fix false) else (let { C , b } = (let a = 2 in "apple") in (pred true))) [ (\ C : (Star => Star) . (Ref String)) ])
(\ b : ((Ref ({ Some E : Star , Float })) (Ref C)) . ((a (let c = "boy" in false)) as (({ Some B : (Star => Star) , (Float -> C) }) ({ Some D : Star , B }))))
({ c = ((\ A : (Star => (Star => Star)) . (fix "apple")) (fix ({ d = (b [ String ]) , b = 1 }))) , d = (\ d : (All B : ((Star => Star) => Star) . (String String)) . (let e = a in false)) })
(if (iszero (ref "apple")) then ((\ C : Star . "apple") as (String -> Nat)) else (({ a = (ref b) , d = (1 . d) }) := (fix false)))
({ c = ((pred 0) (pred 0)) , c = (iszero ((if a then 1 else true) := (\ D : Star . true))) })
({ b = ((let { D , c } = (fix (let { E , e } = 1 in unit)) in (! false)) [ ({ Some B : ((Star => Star) => Star) , ((B -> Bool) -> String) }) ]) , a = ({ d = ((ref a) 1) , c = ({ * Bool , true } as Unit) }) })
(fix ({ b = (! b) , c = ((pred "boy") . b) }))
({ * (Ref ({ Some B : Star , A })) , ((let { E , c } = ({ c = c , e = "boy" }) in (({ * A , b } as Float) := 0)) [ ({ Some E : (Star => Star) , String }) ]) } as (All E : (Star => Star) . (All D : Star . Nat)))
(fix (ref (let e = (let a = a in "apple") in 1)))
(pred (\ a : (All D : Star . Float) . (fix unit)))
(succ (pred ((let { C , d } = c in true) (succ (iszero "apple")))))
(let c = (if (\ a : (Bool B) . (! false)) then (let a = 0 in "apple") else (let { E , e } = (b [ Bool ]) in true)) in (fix (\ A : Star . "apple")))
(! ((succ 2) . e))
((succ ((let { D , c } = b in b) := c)) := (pred (fix (let c = 0 in unit))))
(pred (\ B : ((Star => Star) => Star) . (succ "apple")))
(iszero (pred (let { B , a } = a in c)))
((let { D , c } = (! false) in ("apple" . d)) := (fix ({ * Nat , (fix 2) } as String)))
((succ (ref 0)) [ (Ref (\ E : (Star => Star) . (\ D : Star . Unit))) ])
(\ E : (((Star => (Star => Star)) => ((Star => Star) => Star)) => (((Star => Star) => (Star => Star)) => ((Star => Star) => (Star => Star)))) . (((fix b) [ (Ref C) ]) := ((fix (\ A : Star . c)) (if true then 1 else false))))
((! ((fix c) (true [ C ]))) as ({ Some D : (Star => Star) , (B Bool) }))
(\ c : ({ b : (\ E : (Star => Star) . (All C : Star . (C Float))) , b : (\ E : Star . ({ c : Unit , b : B })) }) . (((a [ C ]) . e) . c))
(((pred 1) . b) (({ e = 2 , e = 2 }) . b))
({ a = (! (succ (1 [ C ]))) , e = (iszero (iszero (iszero unit))) })
(if (iszero (\ b : (Unit -> A) . (ref 2))) then ((succ "boy") as ((All D : (Star => Star) . Unit) (Ref Unit))) else (((let c = 2 in "apple") as A) [ ({ c : ({ e : (All A : Star . Unit) , a : (\ A : Star . Bool) }) , b : (Ref C) }) ]))
(let { E , c } = ((ref true) as (A (Ref A))) in (ref (let { B , e } = true in b)))
(succ (pred (pred (if false then (! "boy") else 1))))
((iszero (if (! a) then (! false) else ("boy" := b))) as (All B : (((Star => Star) => Star) => (Star => Star)) . (\ C : Star . ({ Some B : Star , A }))))
(pred ((fix false) as (({ e : A , c : Nat }) (Float C))))
(! (let { D , e } = (c as String) in (\ e : Unit . 2)))
((\ A : (Star => Star) . (succ (iszero unit))) [ ({ c : (Ref ({ Some B : Star , (Nat -> String) })) , e : (\ E : ((Star => Star) => (Star => Star)) . (Ref C)) }) ])
({ c = (let { C , d } = (let { B , e } = (c as Nat) in 1) in (iszero "boy")) , b = (fix (\ d : ({ Some C : Star , B }) . ((1 "boy") as B))) })
({ * (\ E : (Star => Star) . ({ Some C : (Star => Star) , A })) , ({ * (\ A : (Star => Star) . (\ C : Star . String)) , (succ (ref 2)) } as ({ Some D : Star , ({ d : B , b : Unit }) })) } as ({ Some C : ((Star => Star) => (Star => Star)) , (C ({ Some D : Star , Unit })) }))
({ e = ((let { E , b } = b in false) (let { D , a } = "apple" in true)) , a = (! (\ a : B . "apple")) })
(let { A , b } = ((\ a : ({ a : B , b : Unit }) . (let { B , a } = "apple" in true)) as (Ref (All A : (Star => Star) . B))) in (fix (("apple" := false) (ref "boy"))))
(if (pred (\ C : Star . "boy")) then (succ ("boy" := unit)) else ((true . a) as ({ Some A : (Star => Star) , (All A : Star . C) })))
(let e = (\ a : (Nat String) . (let { C , c } = "boy" in b)) in (iszero (c [ C ])))
(ref ({ a = (iszero (unit [ B ])) , a = (succ (let b = 2 in c)) }))
((("apple" := "apple") . e) := ((iszero true) [ ({ Some D : (Star => Star) , (\ B : Star . Float) }) ]))
(if (\ D : (Star => Star) . ({ e = "apple" , d = b })) then ({ c = (succ (iszero c)) , e = ((pred "boy") (let { A , a } = ({ d = a , e = "apple" }) in "boy")) }) else (\ b : (All D : ((Star => Star) => Star) . (All B : (Star => Star) . ({ b : Nat , b : Bool }))) . ((\ B : Star . unit) [ (\ D : (Star => Star) . ({ Some D : Star , String })) ])))
(\ D : ((Star => Star) => (Star => Star)) . ({ * (Unit Float) , (\ E : (Star => Star) . (let { E , a } = b in c)) } as (Ref (Ref A))))
(((fix a) := (let e = "apple" in "boy")) . e)
((\ b : (String -> (C -> B)) . ((let a = 2 in 0) . a)) := (! ({ d = (fix 1) , a = 1 })))
((iszero (let { A , b } = (let { A , c } = 2 in true) in "apple")) [ (Ref (({ d : B , c : A }) -> (\ B : Star . Float))) ])
(let { E , a } = (succ (let c = c in (pred false))) in (iszero ((if 2 then unit else b) as (Ref (\ C : Star . Nat)))))
(\ a : (Ref (C -> Float)) . (succ (pred 0)))
(! ({ * (All A : (Star => Star) . (All C : (Star => Star) . (Bool A))) , (if ({ * Nat , ({ c = unit , d = 1 }) } as (String Bool)) then (fix unit) else (! 2)) } as (A -> (Nat -> B))))
(let { E , d } = ((iszero 2) (let { B , b } = (1 as Nat) in (ref "boy"))) in (\ B : ((Star => (Star => Star)) => (Star => Star)) . (a as (String -> C))))
(iszero (ref (pred 0)))
(! (succ (succ (let { C , c } = c in "boy"))))
(let e = (((a as C) := (\ b : Float . unit)) . d) in (let { B , c } = (c [ A ]) in ((ref false) [ (Nat -> Nat) ])))
(let b = (((true . a) . c) := (! "boy")) in (ref (\ b : (Ref Unit) . (0 [ B ]))))
((succ (succ 0)) as ((B -> Bool) -> (All E : Star . Float)))
(iszero (\ C : (Star => Star) . (2 := true)))
(\ c : (\ A : (Star => (Star => Star)) . (All E : Star . Nat)) . (((a [ Float ]) [ ((All B : Star . String) -> B) ]) . b))
({ a = (iszero (succ true)) , b = ({ a = (pred unit) , c = (true as B) }) })
((\ E : ((Star => Star) => (Star => Star)) . (let b = "apple" in "apple")) as (All A : ((Star => Star) => ((Star => Star) => (Star => Star))) . (\ B : (Star => Star) . ({ Some B : Star , C }))))
(let a = (iszero (c 0)) in (succ ((pred b) := 2)))
(let { A , c } = (\ a : (\ C : (Star => Star) . ({ c : Bool , c : Unit })) . (\ B : Star . false)) in ((\ E : (Star => (Star => Star)) . (\ c : A . true)) [ (B -> (All C : Star . String)) ]))
(fix (pred ((b := 2) (! (ref true)))))
(\ c : (({ Some C : Star , B }) -> (Bool -> Unit)) . (ref (ref ({ c = true , d = c }))))
(\ e : (\ A : (Star => Star) . (All E : Star . B)) . (let e = (succ "boy") in (ref "boy")))
(if (\ C : ((Star => Star) => Star) . (\ D : (Star => Star) . (iszero b))) then ({ e = (ref (false . c)) , e = ({ * (\ D : Star . A) , (let c = 1 in "boy") } as ({ c : Nat , e : String })) }) else (! (("apple" := unit) as B)))
(({ * (All D : (Star => Star) . (All A : Star . A)) , ((fix unit) := (unit := unit)) } as (\ B : (Star => Star) . A)) . d)
(let { D , e } = (let d = (! (iszero b)) in (("apple" as A) := (\ C : Star . "boy"))) in ((ref b) . d))
(succ (let b = (\ C : Star . "apple") in (\ B : (Star => Star) . (succ c))))
({ * ((All D : Star . ({ b : Float , b : B })) -> (Nat -> (Ref Unit))) , ((if (\ B : Star . true) then (if 2 then "boy" else "apple") else false) ((false as Nat) as (\ B : Star . String))) } as ({ b : (Float A) , c : (Ref Float) }))
({ * (((B C) -> (({ Some B : Star , A }) -> ({ Some A : Star , Nat }))) ({ Some C : Star , Float })) , ({ * ((String Float) C) , (pred "boy") } as ({ Some E : Star , Bool })) } as (Ref (All A : (Star => Star) . Bool)))
(\ a : ((\ B : Star . B) (C -> Unit)) . (succ (succ (\ b : Bool . "apple"))))
(pred (pred ({ * (All E : Star . String) , (b . b) } as (\ D : Star . Bool))))
(((ref (({ d = c , d = false }) := "apple")) as ({ Some E : (Star => Star) , String })) as ((Ref Bool) (String -> (B -> Bool))))
(let a = (fix (a c)) in ({ b = ("apple" (fix c)) , e = ({ * Nat , 0 } as Float) }))
({ d = (! (if (succ c) then (pred c) else (iszero true))) , c = (((let c = "apple" in false) as ({ d : Bool , a : B })) [ (All C : Star . Float) ]) })
(ref (ref ("apple" [ C ])))
(\ b : ({ Some C : (((Star => Star) => Star) => (Star => Star)) , (\ B : ((Star => Star) => (Star => Star)) . (\ D : Star . ({ Some B : Star , Bool }))) }) . (let c = (c [ Nat ]) in (b [ A ])))
(let { B , a } = ({ * (Ref (All E : Star . Unit)) , (fix false) } as (\ D : (Star => Star) . (A Nat))) in ({ e = (pred (ref 2)) , b = (let { E , e } = ((succ a) [ ({ Some B : Star , Unit }) ]) in ({ c = true , a = c })) }))
(if ({ a = (! (iszero 0)) , c = (ref c) }) then (! (2 unit)) else (ref (iszero ({ * Float , c } as A))))
((let { C , a } = (fix (0 as C)) in (succ (let { B , e } = "boy" in 2))) as ({ Some D : ((Star => Star) => Star) , ({ Some C : (Star => Star) , (All C : Star . String) }) }))
(fix (! (1 as (String -> Float))))
(\ E : (((Star => Star) => (Star => Star)) => (Star => Star)) . (\ D : (Star => Star) . (false . d)))
({ a = (if (let { E , b } = "boy" in 0) then (if "apple" then 2 else (let d = "apple" in b)) else (! "boy")) , b = (if (if (let d = 1 in "apple") then b else ({ * B , false } as String)) then ("boy" a) else ((pred b) := (false := b))) })
({ * ((All A : (Star => Star) . (\ C : Star . Unit)) ({ e : (({ Some C : Star , Nat }) B) , d : (All A : Star . Nat) })) , (pred ({ * Float , unit } as Bool)) } as (\ A : (Star => Star) . ({ Some A : Star , (All B : Star . String) })))
(let e = (ref (true "apple")) in (if (iszero 1) then (pred (if 0 then unit else true)) else (\ a : (Float -> A) . (pred "boy"))))
(fix (let { A , d } = (ref unit) in (iszero (1 as Nat))))
(let { B , c } = (\ B : ((Star => Star) => Star) . ((let d = 0 in 0) . b)) in ({ * ({ b : ({ c : B , c : Float }) , e : (Float -> Float) }) , (\ b : (B Float) . c) } as (Float -> Bool)))
(pred ((("boy" := unit) "boy") ((a [ Unit ]) true)))
((iszero (\ E : Star . 0)) := (((a . e) := (! c)) (let { B , a } = true in b)))
(\ D : ((Star => (Star => Star)) => ((Star => Star) => (Star => Star))) . (({ b = "boy" , e = b }) . e))
(((\ D : Star . (let { B , b } = unit in 1)) (pred "apple")) as ((All B : (Star => Star) . (\ D : Star . Float)) -> (\ E : Star . A)))
(((let a = 2 in (succ unit)) as (Ref C)) := (fix ((iszero 2) as ({ Some D : Star , Bool }))))
(let { B , d } = (iszero (if "apple" then 0 else a)) in (succ ((\ c : Unit . b) [ String ])))
(if ({ b = (a as Float) , d = (! "apple") }) then (let d = ({ d = c , d = "boy" }) in (2 b)) else (\ d : ({ e : (All B : Star . Nat) , b : ({ d : C , d : String }) }) . (let b = (if a then unit else "boy") in ({ b = (pred "boy") , c = a }))))
(! (ref (\ C : ((Star => Star) => (Star => Star)) . (fix "apple"))))
(let { E , c } = ({ * (A B) , (iszero a) } as (Bool (C String))) in (if (\ d : (A String) . true) then (if ({ e = (iszero a) , b = (fix c) }) then (pred "apple") else (\ e : Nat . (\ E : Star . 2))) else (ref ({ * B , (pred 1) } as A))))
({ * (\ C : (Star => Star) . (All E : (Star => (Star => Star)) . (All B : Star . Nat))) , (({ * ({ b : Nat , b : B }) , true } as (Ref Bool)) as (Ref String)) } as ({ b : ((All C : Star . String) -> A) , a : (All E : (Star => Star) . (\ D : Star . String)) }))
((fix (let c = a in (true . a))) as ({ e : (\ D : (Star => Star) . (A Nat)) , d : (All C : ((Star => Star) => (Star => Star)) . ({ c : String , b : B })) }))
(fix ((let { C , d } = (\ a : B . c) in "apple") [ (({ a : A , a : Unit }) -> Float) ]))
((({ a = (true as A) , d = "apple" }) (let b = (let { D , d } = 2 in "apple") in (b 2))) ((0 c) [ ({ Some B : Star , String }) ]))
((if ((succ c) true) then (\ d : (All D : Star . Unit) . ({ a = 0 , b = 2 })) else ((if (ref "apple") then "boy" else "apple") ({ e = true , d = a }))) := (ref (fix "boy")))
(succ (ref (\ A : ((Star => Star) => (Star => Star)) . ("boy" as B))))
(if (iszero (iszero (! false))) then (iszero (if (let a = 0 in 1) then (0 . a) else 1)) else ({ b = ({ c = ({ * Nat , "apple" } as Bool) , d = ("boy" . b) }) , e = (\ B : Star . 1) }))
((let b = (false 1) in (false := (iszero false))) . b)
(\ E : ((Star => (Star => Star)) => ((Star => Star) => ((Star => Star) => (Star => Star)))) . (((succ (let c = false in a)) . e) (if 0 then c else "apple")))
(fix ((\ B : Star . (2 . a)) . b))
(fix (let { E , e } = (\ B : Star . 0) in (let b = 1 in "apple")))
(iszero ((let c = 1 in 2) ({ * (\ A : Star . Float) , (fix 0) } as (C -> Bool))))
(let e = (\ b : ({ Some E : Star , Bool }) . (pred (\ E : Star . c))) in ((pred ("apple" := c)) ((\ B : (Star => Star) . 2) := ((0 as B) := (\ e : Nat . "boy")))))
(ref (let { E , a } = (\ e : Nat . false) in ({ * Unit , b } as String)))
(iszero (iszero (succ (true [ C ]))))
(fix ({ * ({ b : (\ D : Star . C) , b : Float }) , (! 2) } as (A C)))
((succ (fix b)) ({ e = ({ * Float , false } as Float) , a = (if ("apple" := unit) then ("boy" as Unit) else a) }))
({ * (Ref ({ d : A , a : String })) , (pred (let { C , c } = "apple" in (c c))) } as ((A -> Bool) ({ b : ({ d : Unit , e : (Ref B) }) , a : (All B : Star . Float) })))
(succ ((! 0) as (Float -> Unit)))
(((succ b) (pred (fix 0))) (fix (ref 0)))
(succ ({ c = ({ * Unit , 2 } as String) , c = (a := true) }))
(pred (let b = (succ "apple") in (true [ ({ a : A , e : Unit }) ])))
(fix (! (iszero 1)))
(fix (if (let e = 0 in 0) then ((! unit) . d) else ("apple" := "boy")))
(iszero (pred (pred "apple")))
(\ D : (((Star => Star) => (Star => Star)) => (Star => (Star => Star))) . (succ (fix (succ a))))
(succ (succ (let c = "boy" in (1 as Nat))))
({ * (Ref (All B : Star . C)) , (\ A : (Star => (Star => Star)) . (if (fix "apple") then (a as Nat) else (\ e : ({ a : B , d : Unit }) . 0))) } as (\ A : ((Star => Star) => (Star => Star)) . ((All B : Star . Float) -> (Ref A))))
(let { E , d } = ({ d = (! c) , d = (iszero 2) }) in (ref ((\ D : Star . 1) := (ref "boy"))))
(ref (\ B : (Star => (Star => Star)) . (\ C : (Star => Star) . (b . b))))
(! (if ((pred 0) := (ref false)) then (! 1) else ((pred b) as (A Nat))))
({ * (Ref (Ref Float)) , (! ((pred true) (iszero false))) } as (\ C : (Star => (Star => Star)) . (C -> (Ref C))))
(let { C , d } = (pred (! (2 0))) in (fix (let c = c in true)))
(let { E , d } = (let e = (pred "boy") in (\ b : C . true)) in (let { C , b } = (ref "apple") in (true [ B ])))
(succ (let e = (c 2) in (true := a)))
(succ ((succ c) as ({ Some D : (Star => Star) , (Float -> C) })))
