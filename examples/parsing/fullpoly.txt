(let a = (fix ({ d = (let e = unit in "boy") , a = unit })) in (({ * Float , "apple" } as A) (if (\ d : B . unit) then 0 else true)))
(let { E , d } = (succ (if ({ d = "apple" , b = (\ D . 2) }) then (if 1 then 1 else c) else ({ * (A -> Unit) , c } as Unit))) in ((unit a) as ({ Some E , C })))
(let { E , a } = (\ b : ({ Some E , ({ b : Bool , c : String }) }) . (pred (pred 1))) in (\ A . (pred (let { D , a } = "apple" in false))))
(let { B , d } = ({ a = (c [ Bool ]) , b = (\ d : Unit . c) }) in (\ B . (if unit then "apple" else 1)))
(let d = (pred (\ d : C . "boy")) in (\ D . ({ d = c , a = c })))
(fix (\ d : ({ Some C , Unit }) . ({ b = a , d = unit })))
(\ b : (({ Some B , String }) -> ((All E . Float) -> ({ Some A , (String -> C) }))) . (\ A . (1 a)))
(((\ d : ({ Some C , C }) . (false as String)) [ (({ Some C , (All A . Float) }) -> (Float -> String)) ]) as ((C -> Float) -> ({ Some E , Nat })))
(fix (fix (fix true)))
((((succ (pred true)) as ({ c : String , d : (All E . A) })) [ ({ a : ({ b : B , b : String }) , c : (All C . String) }) ]) (let c = (\ b : Unit . false) in (pred ("apple" . b))))
(((\ b : A . (if a then 2 else "apple")) as (All A . ({ Some C , A }))) . a)
((let d = ((false [ Float ]) . b) in (succ 1)) as ({ Some C , (C -> ({ Some A , Nat })) }))
((let { C , a } = (fix ("boy" as Nat)) in (let { B , b } = c in 1)) as ({ b : ({ Some E , A }) , c : ({ Some B , (All C . Nat) }) }))
(\ c : ({ Some E , ({ c : B , a : ({ a : Float , b : Unit }) }) }) . ({ * ({ Some E , A }) , (a as Nat) } as (All C . B)))
(((succ (let { C , b } = "apple" in c)) [ ((String -> (B -> Bool)) -> (All C . Unit)) ]) [ ({ c : ({ a : (All A . Unit) , c : (All B . Nat) }) , d : (All D . ({ Some D , C })) }) ])
(succ ((\ B . a) as (All A . (A -> A))))
(succ (\ d : ({ a : (All D . String) , b : (All D . B) }) . (let { B , d } = a in true)))
((\ C . ({ * C , "boy" } as String)) (succ ((let a = c in 2) . d)))
(fix (if (\ C . (0 as C)) then (let a = (if 1 then true else 0) in (let { C , b } = 2 in false)) else ((pred "boy") [ ({ Some E , ({ d : Float , e : Float }) }) ])))
(if (let { D , a } = (fix 2) in (iszero (fix 0))) then (let { C , c } = (if (if (iszero a) then 1 else (b as C)) then (let { C , b } = (pred c) in 1) else ({ * Float , 2 } as A)) in (fix ("apple" as A))) else (let e = ((succ b) [ ({ d : B , e : B }) ]) in ({ * (All B . C) , (pred (b as Nat)) } as ({ d : ({ Some D , Bool }) , d : C }))))
(fix (if (false [ Float ]) then (\ E . (b . b)) else (iszero unit)))
(fix ({ d = (false . b) , b = (iszero true) }))
(if ((b (fix "apple")) as ({ b : Nat , c : Nat })) then (let a = ({ * String , (let e = "apple" in 1) } as Unit) in (false as Nat)) else (\ A . (\ a : (Float -> String) . (\ E . a))))
(pred (let { B , b } = ((b . d) . c) in (0 [ A ])))
(if ((let { D , e } = ((if "apple" then b else 1) [ Nat ]) in (\ e : ({ Some A , Unit }) . (let b = c in "apple"))) . c) then (iszero (false (a as Nat))) else ({ * ({ Some E , Float }) , (iszero "boy") } as ({ c : A , e : String })))
(iszero (if (let { A , d } = ("apple" true) in 2) then (let a = unit in (if "apple" then b else true)) else (\ b : ({ e : String , e : C }) . ({ * (All D . Float) , 1 } as ({ Some C , A })))))
(let { E , b } = ((pred unit) [ ({ e : Float , c : B }) ]) in (fix (let d = (let c = c in false) in (\ D . (0 a)))))
(if (if (let { E , b } = b in a) then (a [ C ]) else ({ b = "apple" , e = 0 })) then ((({ e = b , d = 1 }) 1) (pred (b . c))) else (fix (\ b : ({ b : Float , a : B }) . (({ b = unit , b = 1 }) [ Unit ]))))
(if ({ * (All C . C) , ({ a = b , b = 0 }) } as ({ Some A , C })) then (let { B , b } = (if 0 then (a unit) else "boy") in (iszero b)) else (fix ((succ c) . d)))
(\ b : ({ e : ({ a : C , a : B }) , d : (Unit -> ({ c : Nat , c : Bool })) }) . (succ (let d = b in true)))
(pred (let c = (a a) in (c as Unit)))
({ e = ((\ C . (fix true)) (succ true)) , b = (pred (let { B , d } = unit in true)) })
(((\ b : (All D . B) . (fix 0)) as ((All E . Nat) -> A)) (((iszero ({ d = true , c = false })) . a) . a))
(if (\ E . ((if a then "boy" else "apple") (0 . c))) then (pred ((unit b) (let d = (b as B) in b))) else ((pred 0) [ (All C . String) ]))
(\ c : (All A . ((String -> Unit) -> ({ c : Unit , b : Nat }))) . (pred (("apple" 0) as ({ e : ({ Some C , Unit }) , b : ({ a : Bool , e : Unit }) }))))
(iszero ((unit . b) [ ({ c : B , e : Bool }) ]))
((pred (iszero (pred c))) [ ({ Some C , ({ b : ({ c : (All C . String) , a : ({ Some D , String }) }) , a : ({ Some A , A }) }) }) ])
(pred ({ d = (if (pred a) then (\ E . unit) else "boy") , c = (\ B . "apple") }))
({ b = ({ * ({ c : (All D . Float) , e : (All B . (All A . C)) }) , (let { B , a } = ({ e = false , b = a }) in (if "apple" then 2 else unit)) } as (({ Some C , B }) -> String)) , b = ((let e = 1 in true) as ({ a : String , a : Bool })) })
(pred (if ({ e = (iszero unit) , c = (\ c : Unit . c) }) then (succ "boy") else (let { A , c } = (a "apple") in a)))
(let d = (let { C , a } = (\ d : B . true) in (iszero true)) in (({ b = (0 . b) , b = (succ "apple") }) as (All E . (A -> Bool))))
(\ E . (succ (fix unit)))
(fix ({ * ({ Some E , C }) , (\ D . 1) } as ({ d : String , c : Nat })))
(if (let { B , b } = (\ D . a) in (if ("apple" . c) then "apple" else unit)) then ((\ E . (false . d)) [ ({ Some D , (All E . A) }) ]) else (iszero ((iszero c) (if ({ c = c , a = 1 }) then (iszero c) else c))))
(if (let { C , d } = ((iszero 2) [ (C -> String) ]) in (1 as B)) then ((iszero (succ b)) as (All D . ({ Some C , C }))) else (\ d : ({ a : ({ Some D , B }) , c : A }) . ((let { E , b } = c in "boy") a)))
(iszero (\ E . ({ a = ({ * Unit , c } as Nat) , a = c })))
(pred (\ e : ({ b : ({ Some C , Unit }) , e : Bool }) . ((\ c : Float . "boy") . c)))
(succ ((1 "apple") as (A -> (Float -> C))))
(if (iszero (iszero (1 . a))) then ((\ d : ({ Some D , ({ Some B , Bool }) }) . (if unit then "apple" else true)) ({ * (({ c : Unit , a : B }) -> Unit) , (iszero true) } as (All E . String))) else (\ c : (Bool -> ({ Some C , B })) . (if (\ D . "apple") then "apple" else (let { B , d } = "boy" in true))))
(pred ((succ b) (let a = (let { B , b } = "boy" in 2) in 1)))
(if (if (b . b) then ("apple" as A) else ({ * Unit , a } as ({ e : A , a : A }))) then (\ d : ({ Some A , String }) . (if (pred 2) then 0 else (let { A , e } = unit in 1))) else ((let { E , c } = "boy" in 2) [ ({ a : (All C . C) , b : A }) ]))
((\ b : ({ Some B , (All B . Nat) }) . (\ b : (A -> Nat) . (let { E , b } = b in 1))) as ((All D . ({ Some B , C })) -> (All E . B)))
(let c = (let e = (c . c) in (\ e : ({ a : Float , a : C }) . false)) in (if ({ * C , true } as Float) then (pred "apple") else (let b = a in b)))
(if (succ ({ * Float , false } as B)) then (let { A , b } = (\ b : ({ c : Float , c : Unit }) . (fix 1)) in ({ d = (\ b : String . unit) , e = b })) else (succ (\ a : Float . c)))
(let d = (let d = (let d = (\ e : Nat . b) in ("boy" as String)) in (iszero false)) in ({ * (All C . (All C . C)) , (\ c : (Nat -> Unit) . b) } as ({ Some A , C })))
(\ B . ((a [ A ]) . d))
(((succ a) (iszero ("apple" [ A ]))) (\ E . (iszero false)))
(succ ((\ e : (Float -> Bool) . "boy") as (B -> Bool)))
(let { E , c } = (if (c [ Float ]) then (if a then "boy" else b) else (let d = 2 in "boy")) in (\ C . (iszero (let d = b in a))))
(let { B , c } = (\ a : (All C . Nat) . (((let { B , b } = false in unit) as ({ e : Nat , b : B })) as (A -> ({ Some A , B })))) in ((\ C . 2) as ({ Some D , C })))
((let { A , b } = (2 [ Nat ]) in (unit . d)) ((\ d : Bool . 2) . e))
((let b = (fix false) in (\ B . true)) as (All C . ({ d : (A -> B) , a : ({ Some A , B }) })))
(\ e : (All B . ({ Some E , (All C . Nat) })) . (iszero (let b = 1 in unit)))
({ d = (if (\ D . (false [ ({ b : A , d : Bool }) ])) then ("boy" as String) else (succ "apple")) , e = ((let { B , d } = (1 . e) in ("apple" as Nat)) ({ e = (iszero 0) , e = b })) })
(let { A , c } = (fix (\ e : (Float -> B) . unit)) in ({ e = (\ D . 1) , b = (\ D . 0) }))
(((\ a : ({ Some E , C }) . (2 a)) [ ({ a : B , b : A }) ]) . a)
((succ (let d = (fix 1) in (if unit then 2 else 1))) . c)
(fix (let { D , b } = (iszero (pred (\ a : String . 1))) in ((unit as Unit) as ({ a : C , e : C }))))
({ a = ({ b = (1 [ Float ]) , b = ((let a = unit in (\ b : Float . c)) . e) }) , b = (if (\ d : ({ e : Bool , e : Float }) . c) then (false as String) else (0 as Unit)) })
(let d = ({ e = (succ 2) , b = (\ a : C . "apple") }) in (fix (let { D , b } = (succ false) in (b . a))))
(\ D . (((iszero 2) as ({ c : C , d : Float })) . c))
({ * ({ e : (All B . C) , e : ({ Some A , Float }) }) , (({ d = a , a = 0 }) ((let a = (succ 0) in 0) ((pred false) [ B ]))) } as (All C . (A -> Unit)))
({ b = ((\ e : ({ a : Nat , d : Bool }) . (\ A . 1)) as (C -> String)) , e = (if (pred c) then (let { B , b } = 2 in (unit "boy")) else (pred false)) })
(\ c : (({ Some C , Float }) -> ({ Some C , B })) . (\ C . (fix a)))
(({ d = (succ (fix (let { D , e } = 2 in false))) , b = ((iszero false) (iszero true)) }) . c)
((fix ({ * (All A . B) , (iszero a) } as ({ Some D , Unit }))) (\ C . ({ d = (b [ Nat ]) , b = (c as String) })))
(let a = (let { C , d } = (if 1 then "apple" else unit) in (\ e : (All C . A) . (true 1))) in (let e = (c unit) in ({ c = unit , a = "boy" })))
((pred (let { A , d } = c in (pred "boy"))) as (((All C . String) -> ({ Some B , String })) -> ({ Some C , ({ Some E , Unit }) })))
({ a = (fix (false as C)) , a = (\ D . (\ B . "apple")) })
((pred (false 2)) ({ d = (fix (iszero c)) , b = ({ e = a , c = "apple" }) }))
(iszero (fix (fix false)))
(if (pred ((\ d : Bool . false) . c)) then (if ({ b = (let a = 2 in 0) , d = (\ D . true) }) then (\ C . (b 0)) else ("boy" . d)) else (fix (\ A . true)))
({ c = (({ * Nat , 0 } as Bool) (\ E . "apple")) , b = (\ D . ((0 0) [ B ])) })
(pred ({ a = (fix 1) , d = (let c = "apple" in true) }))
(succ (let d = (succ unit) in ((iszero a) [ (All C . Bool) ])))
(fix (if (pred c) then (succ (\ B . "boy")) else (let { B , a } = 2 in ({ a = 0 , c = unit }))))
({ d = (let { B , a } = ((pred false) as String) in (\ D . a)) , e = (if (\ d : A . c) then (iszero (2 1)) else (true 2)) })
({ a = (let { A , c } = ((pred "boy") (\ C . (let { B , d } = 0 in true))) in (pred (\ e : Nat . c))) , b = (let { E , b } = ({ * B , "apple" } as B) in (\ D . false)) })
({ * ((All A . B) -> ({ Some A , Float })) , (let c = ((({ e = a , b = 2 }) [ (C -> Nat) ]) as (All B . B)) in (\ A . (succ ("boy" unit)))) } as (({ Some E , Float }) -> (All A . B)))
(iszero (let c = (let e = ({ c = 0 , c = unit }) in ({ e = true , a = true })) in (unit . e)))
({ * ({ a : (Bool -> C) , e : ({ Some B , C }) }) , ({ a = (iszero 1) , e = (if (iszero 2) then ({ d = 2 , e = false }) else 0) }) } as (({ c : Nat , d : A }) -> (All A . Unit)))
(if (let { B , a } = (succ (iszero b)) in (({ * Float , 2 } as B) ({ d = unit , c = (fix unit) }))) then ((let { D , e } = (succ false) in (succ 0)) (\ a : ({ Some B , ({ Some C , C }) }) . (succ a))) else (\ c : (All D . A) . (fix (\ D . unit))))
({ b = ((0 [ C ]) [ (Float -> A) ]) , e = ({ * ({ d : ({ Some C , ({ Some E , A }) }) , b : ({ Some E , B }) }) , (pred 1) } as ({ b : B , d : Bool })) })
({ * ({ Some E , ({ Some A , (All A . Float) }) }) , ((\ D . (iszero c)) [ ({ Some B , String }) ]) } as ({ Some E , ({ Some B , ({ a : C , a : A }) }) }))
({ * ({ b : (All B . Unit) , a : (({ e : B , d : Unit }) -> String) }) , (if (if c then true else 1) then ("boy" as Nat) else (false 0)) } as (All E . (({ Some C , Float }) -> (Bool -> (All C . Float)))))
(succ (\ a : ({ Some A , (Float -> ({ Some D , C })) }) . (\ b : ({ Some B , String }) . unit)))
(if ((succ true) (pred ({ a = "apple" , e = c }))) then ((\ b : (B -> Bool) . (c [ Bool ])) . d) else (({ * Nat , "apple" } as String) ({ d = (let d = true in (fix "boy")) , e = (fix true) })))
(let { A , b } = (fix ({ e = "boy" , a = ({ b = "apple" , a = false }) })) in (succ ({ a = (pred "boy") , a = a })))
(\ e : (All C . ({ b : (A -> (Unit -> B)) , e : ({ e : B , d : B }) })) . (iszero (false [ Bool ])))
({ b = (succ (fix "boy")) , c = (iszero (let { B , d } = unit in "apple")) })
((let { D , c } = ({ * Float , b } as B) in (iszero c)) ((if unit then "apple" else 2) (true . e)))
(\ d : ({ Some C , ({ a : Nat , c : Nat }) }) . ({ * ({ c : Float , a : Unit }) , (fix ("apple" c)) } as (All E . B)))
((pred (if b then "apple" else 2)) as (All B . ({ a : B , a : (All D . A) })))
(let c = ((fix (iszero a)) (let c = (\ b : ({ Some E , String }) . 1) in (let { B , d } = (if false then a else unit) in true))) in (if (pred true) then (let d = "apple" in (iszero "apple")) else (if "apple" then b else 0)))
((succ (\ a : (All D . B) . (false [ String ]))) as ({ b : (Nat -> Float) , c : ({ d : ({ Some B , Unit }) , d : C }) }))
(fix (if ({ * Bool , unit } as ({ Some E , Bool })) then ({ * (Nat -> Float) , (if 0 then "apple" else true) } as ({ d : Float , e : C })) else (iszero c)))
(\ E . ((let { D , c } = unit in b) as ({ c : String , c : B })))
((if (\ b : C . (iszero a)) then (let { C , d } = (succ 0) in (let { E , a } = (let { D , c } = 2 in a) in 1)) else (iszero (iszero "apple"))) . c)
(\ b : ({ Some D , ({ Some E , ({ Some D , ({ d : String , b : B }) }) }) }) . (fix ({ a = true , a = false })))
(\ B . ({ e = (let c = false in "boy") , e = (iszero unit) }))
(iszero (let c = (fix (let { E , c } = 0 in false)) in ({ * ({ Some C , A }) , (0 [ C ]) } as (All A . A))))
({ * ({ Some B , ({ Some C , (All C . (All D . String)) }) }) , (\ e : ({ Some C , Unit }) . ({ * C , 1 } as String)) } as (All B . ({ d : String , d : A })))
(\ A . (({ * ({ Some E , String }) , "boy" } as Float) [ (All E . ({ b : Bool , a : Unit })) ]))
(((unit [ Float ]) as (All A . C)) . d)
(((let { E , c } = 0 in b) as (All B . C)) (fix (\ a : ({ c : Bool , a : Unit }) . 1)))
(({ c = (2 . c) , c = (pred (succ 2)) }) . e)
(\ e : (All E . (All B . (B -> String))) . (let d = ({ b = ((\ B . 2) [ ({ Some A , A }) ]) , b = ("boy" as (B -> Bool)) }) in (succ true)))
(\ b : ({ d : ({ Some A , Bool }) , a : ({ b : Float , a : ({ Some D , Bool }) }) }) . (let { C , a } = ((pred (\ e : A . "boy")) . d) in (let e = (pred b) in (\ E . (let { E , d } = b in true)))))
(\ C . (\ A . ({ * Bool , 1 } as Nat)))
(succ ({ * (All E . (Float -> Bool)) , (if true then 2 else ({ c = false , c = unit })) } as ((All A . Float) -> (All D . Nat))))
({ d = (pred ((if 1 then "boy" else a) . c)) , b = ((c as ({ Some A , C })) . c) })
(pred ((pred (iszero b)) [ (Nat -> String) ]))
((if (pred ({ b = true , d = 1 })) then ((b a) as Unit) else (let a = "apple" in false)) . a)
(let { B , a } = (\ A . ({ e = b , b = c })) in ({ a = (fix (1 as (All E . Unit))) , d = (let { D , b } = (\ e : Unit . 0) in (iszero 1)) }))
((\ B . ({ a = b , e = 2 })) as ({ Some B , (All A . B) }))
(if (succ ({ * (B -> Unit) , b } as (A -> Bool))) then ((if (2 as Float) then false else (a false)) . d) else (\ c : ({ d : C , c : ({ Some B , Nat }) }) . (\ c : Nat . false)))
(\ c : ({ d : ({ Some B , (B -> Unit) }) , c : ({ b : A , a : Float }) }) . ((let b = "boy" in 0) (let { B , e } = c in a)))
(succ (if (fix "apple") then (c [ String ]) else ((b [ Unit ]) . d)))
((fix (\ A . (b . a))) [ ((All D . Nat) -> ({ b : ({ Some C , B }) , e : ({ Some C , B }) })) ])
(if (if (\ C . 0) then (\ B . "apple") else ({ * B , a } as C)) then (({ * (All C . Float) , (\ b : (All A . Bool) . (\ D . c)) } as ({ e : Bool , d : Nat })) . b) else (iszero (if true then c else a)))
(iszero (iszero (let { C , c } = "apple" in 2)))
({ e = ((let d = 0 in 2) . d) , b = ({ d = (succ "boy") , d = (if (false . d) then (\ D . false) else (let b = 0 in a)) }) })
(({ * ({ Some E , Float }) , ((iszero 2) as ({ b : Nat , e : Unit })) } as (Unit -> A)) ((succ (true [ A ])) (iszero 1)))
(\ d : ({ Some C , (All D . ({ d : String , e : A })) }) . (let c = (fix unit) in (if 0 then (let { E , a } = 1 in true) else (let d = "apple" in b))))
((\ e : (All D . Nat) . ({ * Unit , 2 } as Unit)) (iszero (0 (\ c : String . 0))))
((let { C , e } = (if a then unit else unit) in ((false as Unit) . d)) [ (All C . ({ Some C , A })) ])
(let { A , c } = (fix ((succ c) [ A ])) in (let { C , c } = ((let { C , b } = (succ 2) in ({ b = 0 , c = true })) as (Unit -> Bool)) in (\ d : ((Float -> String) -> Float) . (pred (let { E , c } = a in a)))))
(\ C . (let { C , e } = ({ a = (fix 2) , e = (let { B , d } = false in "apple") }) in (\ d : (A -> String) . (let c = b in false))))
(let { C , e } = (pred (iszero (if 2 then unit else (\ b : A . "apple")))) in (("apple" [ (All C . C) ]) as (All E . C)))
(if ((let { E , b } = ({ c = "apple" , a = a }) in (succ 1)) . d) then ((let e = (if (let { D , b } = unit in a) then ("boy" [ A ]) else (fix "boy")) in (let { E , c } = a in 0)) as ({ Some B , ({ Some E , ({ Some C , Bool }) }) })) else (fix ((\ d : C . a) . d)))
(\ E . (fix ({ a = 1 , c = b })))
(pred (succ (let c = ({ * B , true } as Bool) in (let b = "boy" in (fix c)))))
(succ (\ A . (let { B , a } = (succ b) in a)))
((({ b = "apple" , d = 2 }) as (A -> (All B . C))) . a)
(pred ((\ E . (fix ({ * C , false } as String))) [ (All C . String) ]))
(succ (succ ((pred (c . e)) (succ unit))))
((let e = (fix "apple") in (if b then "apple" else (let { B , a } = false in "boy"))) [ ((Unit -> B) -> ({ a : Nat , b : Float })) ])
(let d = (\ b : (All C . ({ c : Unit , b : String })) . (fix ({ b = unit , e = 1 }))) in ({ * (({ Some B , Bool }) -> A) , (fix ({ d = true , d = c })) } as (({ b : Float , c : Bool }) -> Bool)))
({ a = ({ c = (2 false) , b = (fix 2) }) , b = ((succ (pred 1)) [ ({ Some C , String }) ]) })
((pred (let { C , d } = "boy" in "boy")) [ ((C -> (All A . A)) -> ({ Some D , Float })) ])
(iszero (({ c = ({ b = "boy" , d = 0 }) , a = (fix unit) }) . b))
(({ * ({ Some D , (All B . A) }) , ((succ true) as ({ Some E , ({ Some D , Nat }) })) } as ({ a : ({ e : (All C . Float) , a : (String -> Float) }) , c : (All D . (All C . A)) })) (fix (iszero "boy")))
(((if c then 2 else false) (fix true)) [ (All B . ({ b : Bool , e : Unit })) ])
(fix ({ c = ({ * C , unit } as ({ Some C , Nat })) , a = (let d = b in a) }))
(let a = (\ B . (succ false)) in (let { A , a } = (fix (let { A , d } = unit in (1 [ B ]))) in (pred ("boy" . a))))
({ * ({ a : ({ e : (All A . Bool) , c : (C -> Float) }) , e : ({ b : Unit , d : (All A . Float) }) }) , (if (if (pred 1) then (\ A . 2) else ({ b = 0 , d = a })) then (let b = (iszero (pred 1)) in (false . c)) else ((fix c) . b)) } as ({ Some D , ({ d : ({ e : Float , c : B }) , d : (All B . B) }) }))
(({ a = (let d = 0 in false) , a = (let { C , c } = true in 0) }) ((1 as C) [ ({ Some D , B }) ]))
(succ (iszero (\ a : C . (succ false))))
(if (pred (\ E . false)) then ((let b = false in "boy") [ (All D . ({ d : Bool , d : Nat })) ]) else ({ * ({ d : Float , e : A }) , ((\ d : A . false) as (A -> Unit)) } as (C -> B)))
(succ ((\ b : (All B . C) . (fix ({ b = "apple" , a = "apple" }))) [ ({ Some E , ({ d : C , b : B }) }) ]))
(\ D . (let c = (succ b) in (\ D . false)))
(succ (let { A , c } = (iszero (0 [ ({ Some B , C }) ])) in ("apple" c)))
((fix (true 1)) [ ((A -> Nat) -> ({ b : (All D . C) , c : (Bool -> C) })) ])
(if ((fix (fix unit)) . a) then (pred (let a = 0 in true)) else ((false . c) as ({ e : ({ b : A , d : C }) , d : ({ b : Bool , b : B }) })))
(pred ((pred 0) [ (Unit -> Unit) ]))
(fix ({ e = (succ (let { C , b } = false in "boy")) , e = ("boy" . d) }))
(let a = (iszero (2 . a)) in (\ e : (All E . (C -> A)) . (iszero (let { C , d } = false in true))))
(if ({ * ({ Some E , (Unit -> C) }) , ((c b) . e) } as ((A -> (Bool -> A)) -> (String -> String))) then (let b = ({ * ({ c : (C -> A) , d : Bool }) , (succ c) } as (All B . String)) in (let { B , a } = (succ 1) in (let d = false in "boy"))) else ((pred c) [ ({ Some A , ({ Some D , C }) }) ]))
((succ ({ e = 1 , a = unit })) . d)
((pred (false 1)) [ ({ Some A , ({ d : Float , a : Float }) }) ])
(\ C . ({ * ({ e : Nat , e : Float }) , (fix "apple") } as (All E . Unit)))
({ * (All E . ({ Some D , ({ Some B , Unit }) })) , (let { D , d } = ((fix unit) [ Bool ]) in (\ b : (Unit -> Bool) . (a [ B ]))) } as ({ Some C , ((All A . Bool) -> (Nat -> Bool)) }))
((\ B . ("boy" (\ d : Bool . 0))) . c)
((succ (succ (let c = b in c))) [ (({ b : (All D . Bool) , e : ({ Some A , ({ Some C , String }) }) }) -> ({ c : A , d : (All A . Unit) })) ])
((pred ((iszero b) [ (All E . C) ])) . e)
(pred (({ a = 0 , d = a }) as ({ c : Float , b : Bool })))
({ * (All A . ({ Some D , (All A . B) })) , ((let { A , e } = "boy" in 2) (\ D . 2)) } as (All B . ({ Some A , String })))
(pred ((iszero false) as ({ b : Float , c : Float })))
(((iszero (fix (fix false))) . e) [ ({ d : (All A . Bool) , d : (All C . B) }) ])
(\ C . (if (\ d : (All E . (String -> A)) . ("apple" . e)) then (if (succ a) then ("boy" b) else 2) else ({ d = 0 , b = b })))
((\ E . (unit as String)) as ({ a : ({ Some B , Unit }) , b : (All B . C) }))
(\ b : (All B . (All E . ({ Some D , Bool }))) . ((pred "boy") [ ((Nat -> A) -> (All C . Bool)) ]))
((if (1 2) then (let d = unit in "boy") else (succ "boy")) [ ({ Some C , ({ d : Bool , a : Nat }) }) ])
(let b = (iszero (c false)) in (succ (\ B . "apple")))
(\ A . (if ("apple" as Bool) then ((if 2 then b else b) [ ({ d : String , c : A }) ]) else (iszero false)))
(((let { B , b } = "boy" in unit) [ ((All C . A) -> Unit) ]) as ({ Some A , ((Bool -> Nat) -> ({ e : A , b : Nat })) }))
(let c = (let a = (unit b) in ({ a = 0 , c = true })) in (pred (pred (false [ String ]))))
(if (let { B , e } = (if (fix unit) then (fix 2) else "boy") in (pred true)) then (succ (a unit)) else (\ D . (\ a : Nat . c)))
((let b = ({ e = c , b = b }) in (\ A . "boy")) as ({ Some D , ({ Some E , Nat }) }))
({ * ({ e : ({ c : ({ c : Unit , a : Float }) , e : String }) , b : ({ Some A , (All C . Bool) }) }) , (fix ("boy" . d)) } as ((All C . Nat) -> (All C . Bool)))
(let a = (if (fix (fix unit)) then (\ B . 1) else (\ e : Float . (c . a))) in (\ A . (({ * B , "boy" } as Float) as (All B . Float))))
(\ c : ({ a : ({ e : ({ b : Nat , c : Unit }) , c : (All E . Bool) }) , c : ({ Some C , (Bool -> C) }) }) . (((let { D , d } = (unit as Unit) in true) [ (Float -> B) ]) as ({ a : ({ Some B , ({ b : String , e : Float }) }) , e : (All B . (All B . A)) })))
((("boy" as Bool) . d) as (All B . ({ d : String , a : (String -> String) })))
(if ({ * (A -> (String -> B)) , (a (\ C . unit)) } as ({ Some B , B })) then (("boy" [ (All C . String) ]) as (All A . ({ Some C , ({ a : C , a : String }) }))) else ({ * (All B . (Nat -> Nat)) , (if a then (unit as Bool) else (fix false)) } as ({ Some E , C })))
(let { E , b } = (let e = (2 unit) in (\ A . 0)) in ({ b = (fix ((\ b : B . 1) (a 1))) , e = (let { D , c } = (succ 0) in unit) }))
(\ E . ((b . e) [ (All A . (All E . C)) ]))
(iszero (((if b then (pred "boy") else ({ b = true , e = true })) . b) (let c = a in (a . b))))
({ * (All B . (All B . A)) , (let c = ({ e = 0 , b = (pred c) }) in (let { B , d } = (pred "boy") in a)) } as (All A . ((All E . ({ c : Float , b : String })) -> ({ d : A , b : String }))))
(if (pred ((let { B , e } = 2 in c) as Nat)) then (let { A , b } = (succ "apple") in (\ C . 2)) else (\ B . (\ B . false)))
(succ (iszero (let { B , c } = false in b)))
(\ c : ({ Some D , (({ Some D , Unit }) -> (All C . C)) }) . ((if a then ({ * String , b } as String) else 1) . d))
(let a = (fix (succ 1)) in (let d = (a as (All E . Float)) in ("apple" . c)))
((let b = (a . e) in (let a = c in false)) . c)
(let d = ((let { B , d } = (fix 0) in "boy") [ ({ Some B , C }) ]) in ((iszero ({ d = "apple" , c = (pred false) })) as (All C . C)))
(\ e : (({ a : ({ a : Bool , b : Unit }) , b : ({ Some A , String }) }) -> (({ a : Bool , d : B }) -> Bool)) . (({ * Bool , "boy" } as Float) . a))
((if (\ a : (Nat -> A) . (succ false)) then ({ * ({ Some E , String }) , (let { C , b } = "boy" in "boy") } as ({ b : Float , e : B })) else (let b = true in true)) (\ B . (\ b : (B -> Float) . (b as C))))
(\ a : (((All D . C) -> ({ Some A , Float })) -> (All D . (All C . (All B . Float)))) . ({ b = (({ * String , 1 } as Bool) [ ({ Some D , Float }) ]) , a = (let a = "apple" in unit) }))
(\ C . (pred (\ E . (succ "boy"))))
(if (let { B , d } = (let e = (b 2) in ({ b = a , d = "boy" })) in (let e = b in 1)) then ((if true then false else 2) (let b = (iszero c) in (pred false))) else (pred (b (iszero true))))
(fix (\ C . (let { C , c } = (if unit then 2 else 0) in (pred b))))
(let { B , c } = (fix (succ b)) in (succ (\ B . (if 2 then "apple" else unit))))
((if ((let d = "boy" in a) (false [ B ])) then (if (\ d : C . 1) then a else 2) else (if 0 then true else unit)) ((iszero (if b then 2 else 2)) ((\ B . 2) [ ({ Some A , String }) ])))
(\ A . (succ (pred (iszero unit))))
({ a = (pred ({ * ({ b : ({ Some A , String }) , e : (Float -> B) }) , (succ (fix a)) } as ({ b : String , d : Unit }))) , d = ({ * (Unit -> Float) , ("apple" [ B ]) } as ({ a : (A -> Unit) , e : (All E . Float) })) })
({ a = (fix (\ E . (iszero unit))) , b = ({ a = (((let { C , d } = 0 in 1) . d) . d) , d = (let { C , b } = (fix false) in (\ c : A . false)) }) })
(succ ({ e = (if (unit [ Nat ]) then "apple" else c) , e = (\ A . "apple") }))
((fix (\ B . ({ a = false , c = a }))) . c)
(iszero (if (\ b : ({ Some C , Float }) . (false as Bool)) then (pred (let d = a in c)) else (succ (iszero 1))))
(pred ((succ true) . a))
(pred ((succ (2 2)) [ (All A . ({ e : String , d : Nat })) ]))
(\ d : ({ e : ({ Some B , (C -> Bool) }) , d : (All E . A) }) . (\ a : ({ Some E , Unit }) . (let { C , a } = true in "boy")))
(let { D , e } = (let a = ({ * ({ a : A , d : (All B . Bool) }) , (true as String) } as (All B . Unit)) in ({ c = (let e = "apple" in 2) , e = (let c = "boy" in 2) })) in (let b = (c [ ({ Some D , A }) ]) in (((let a = 0 in "boy") . d) [ ({ e : Float , a : String }) ])))
(let { E , c } = (let { A , a } = ((if true then 0 else "apple") as ({ b : Float , e : Unit })) in (fix (0 [ C ]))) in (({ b = 2 , b = (if 0 then unit else false) }) [ ({ b : ((String -> Nat) -> ({ Some B , Float })) , d : (({ a : Nat , b : Nat }) -> ({ Some E , Nat })) }) ]))
(fix (((\ A . (fix c)) [ (All B . ({ Some B , Unit })) ]) (let { E , b } = (fix (\ a : String . 2)) in (false as Nat))))
(({ * ({ Some C , ({ a : String , e : Bool }) }) , (\ D . (c [ Float ])) } as ({ Some D , (All D . B) })) as (All C . (All E . ({ e : String , e : Float }))))
({ * ((All C . ({ Some A , Float })) -> (All C . (All B . String))) , ({ c = ("boy" false) , b = ("apple" [ (String -> Nat) ]) }) } as ({ d : (C -> B) , a : (All B . ({ Some C , Nat })) }))
(\ a : (All E . ({ b : (Unit -> A) , e : (Float -> String) })) . (pred (\ b : Bool . unit)))
(let { B , d } = ((let { E , d } = 1 in a) as ({ a : String , d : Bool })) in ({ * ({ Some A , (C -> Nat) }) , (fix (pred true)) } as ((A -> A) -> B)))
(succ (if (let d = unit in true) then ({ d = 2 , d = (fix "apple") }) else (let c = (pred (let { E , d } = 2 in 0)) in ({ * C , (succ a) } as String))))
((fix ((\ C . (pred 2)) ({ * Unit , false } as C))) ({ * (({ Some E , Bool }) -> C) , (pred true) } as ({ Some D , ({ Some D , String }) })))
({ e = (({ * ((All D . Unit) -> A) , ("apple" as String) } as ({ Some E , (String -> Float) })) as ((A -> B) -> Bool)) , b = ((fix (fix c)) [ ({ b : Unit , c : ({ Some D , Float }) }) ]) })
({ e = ({ * ({ c : ({ Some C , (All B . Float) }) , d : (All A . String) }) , ({ * (Nat -> Float) , 2 } as (All C . C)) } as ({ e : ({ b : Bool , c : Unit }) , c : (All B . B) })) , d = (let { B , e } = (false . a) in (\ B . ({ * (All C . B) , c } as A))) })
((((if ({ b = 0 , d = 1 }) then b else unit) as ({ c : Bool , e : Float })) (if "boy" then ({ e = a , e = 0 }) else (if b then 0 else c))) (\ a : ({ b : C , d : Float }) . (a . d)))
(succ (if (let c = (let b = a in 2) in (if a then unit else 2)) then ("boy" . c) else (pred (if 2 then 0 else 0))))
(((if unit then (succ true) else 1) [ (Unit -> Nat) ]) [ ({ Some B , ({ Some A , Nat }) }) ])
(iszero ((if unit then "apple" else c) [ (All E . (All E . String)) ]))
({ a = (succ ((pred 0) ({ d = a , b = false }))) , c = ((if (\ D . 2) then unit else (pred 0)) [ ({ Some A , B }) ]) })
((iszero (let b = b in 1)) [ ({ b : ({ Some A , ({ Some C , Unit }) }) , a : ({ Some A , A }) }) ])
(fix (fix ({ a = (\ d : A . "apple") , d = (if 2 then 2 else 1) })))
(fix ({ * (Float -> (Bool -> Float)) , ((iszero c) unit) } as ((All D . (All C . Nat)) -> (All D . Bool))))
((succ (unit . b)) ((pred unit) [ ((B -> Bool) -> String) ]))
(\ c : ({ a : ({ Some B , (B -> C) }) , c : ({ b : String , e : ({ e : A , a : Nat }) }) }) . ({ b = ((\ C . c) [ C ]) , c = (let { C , a } = ({ c = false , a = a }) in false) }))
(let { A , d } = (pred (pred (pred "apple"))) in (let { C , a } = ({ * B , ({ a = "boy" , d = true }) } as Unit) in ((iszero c) [ C ])))
(pred ({ * (B -> ({ Some B , C })) , (false ({ d = b , d = b })) } as ({ Some D , String })))
(({ * ({ Some E , Float }) , ({ * C , unit } as Bool) } as ({ Some C , B })) . e)
(\ d : (All A . (A -> Float)) . (let { E , a } = (if c then (b [ String ]) else b) in ("boy" b)))
(\ C . (let { D , d } = (a as Float) in (true as Float)))
(\ d : (All B . ({ Some B , (C -> C) })) . (\ a : ((Unit -> String) -> ({ a : Float , a : Float })) . (1 [ C ])))
(let d = (fix (\ c : (All B . B) . (\ c : B . false))) in ((if 2 then c else true) . b))
((\ b : (({ Some B , Bool }) -> ({ c : B , a : Nat })) . ({ * (Bool -> Float) , (let { E , e } = "apple" in (pred "apple")) } as ({ Some E , ({ d : B , d : Bool }) }))) . e)
(pred (((let b = b in unit) false) (succ ({ a = ({ * Float , true } as A) , e = (a [ Bool ]) }))))
(fix ((succ (c a)) (if (iszero c) then 1 else 2)))
(iszero (\ e : ({ Some C , (Float -> A) }) . ((\ D . false) . c)))
({ * (({ a : (B -> Nat) , d : ({ e : (C -> C) , c : ({ Some A , Bool }) }) }) -> ({ d : ((String -> Unit) -> Bool) , c : (All E . Bool) })) , (succ ("apple" c)) } as ({ b : (All A . ({ Some E , Unit })) , c : (All B . ({ Some E , B })) }))
(({ * ({ d : ({ d : Bool , d : Nat }) , b : ({ Some C , A }) }) , (fix (pred a)) } as ({ Some C , (All E . Float) })) [ ((({ Some E , A }) -> (String -> String)) -> (All D . C)) ])
(let c = (\ a : ((All E . Nat) -> ({ Some B , String })) . (let { E , e } = (pred 2) in 2)) in ({ * (({ Some B , Float }) -> (All E . String)) , (iszero 2) } as ((All A . (All D . Nat)) -> (All A . ({ Some A , Float })))))
(if (let { B , a } = ("boy" 0) in (let { D , a } = "apple" in 1)) then (let { A , d } = (let { A , e } = 0 in (\ B . "apple")) in (((iszero false) ("apple" . c)) as (A -> C))) else ((let a = ({ * ({ c : Unit , e : Bool }) , (pred true) } as (Bool -> Unit)) in ("boy" [ Unit ])) ((unit . b) as (All C . String))))
(if (let c = (fix (\ d : A . "boy")) in (let d = (succ "apple") in (succ true))) then (iszero (false . c)) else (pred (\ d : C . (\ C . "boy"))))
(({ b = (\ E . ({ * C , true } as (Unit -> A))) , c = (let c = (let e = false in c) in ({ d = 1 , e = a })) }) (\ c : ({ Some A , Nat }) . (let { C , e } = true in (pred "boy"))))
(pred ((let c = 2 in a) . c))
(({ d = (0 as Bool) , e = (iszero false) }) (((succ "apple") . c) . e))
(let e = (pred ({ * A , 0 } as Bool)) in ((let e = (fix b) in (iszero b)) as ({ Some B , ({ e : ({ Some A , Bool }) , a : Bool }) })))
(\ c : (({ e : C , e : B }) -> ({ a : Nat , d : Nat })) . ((if (b as Unit) then 1 else (\ C . 0)) (\ D . (fix "boy"))))
({ e = (fix ((\ E . "boy") . b)) , d = (let { D , b } = (let e = a in (let a = "apple" in "boy")) in (\ C . b)) })
(let c = ((pred a) [ ({ Some B , C }) ]) in (let b = (2 (unit as Bool)) in ({ * ({ b : Float , a : String }) , (\ B . false) } as Float)))
(\ e : ((All C . ({ Some B , Unit })) -> ({ d : Nat , b : (String -> String) })) . ((pred ((b [ A ]) as Bool)) ((let { C , c } = (\ a : B . "apple") in a) (fix c))))
({ * ({ a : ({ Some D , B }) , b : (All B . (Unit -> String)) }) , ((iszero ({ * String , b } as A)) ((let d = (succ 0) in (\ E . b)) [ ({ Some B , B }) ])) } as (All A . ({ Some A , Unit })))
(let { E , a } = (if (succ c) then (let d = "apple" in c) else (\ B . unit)) in (((pred b) [ (Bool -> Float) ]) ((fix unit) [ ({ d : B , e : C }) ])))
(iszero ((let { E , c } = ({ d = a , b = c }) in false) as ({ Some A , ({ Some D , A }) })))
(let { D , b } = (\ d : ({ b : Nat , c : Float }) . (\ B . "boy")) in (let { E , c } = ((let b = unit in 1) as C) in ({ * Bool , "boy" } as Unit)))
((let { B , b } = ({ * (All A . B) , (1 . e) } as (All D . B)) in ({ e = (\ B . a) , b = (\ D . 0) })) . c)
(\ A . (if (let b = "apple" in unit) then ((fix 2) [ (Unit -> A) ]) else ("apple" . a)))
({ c = ({ * (({ Some D , Float }) -> ({ c : (String -> Unit) , a : String })) , (pred c) } as ({ a : Float , b : String })) , b = (\ E . (if "apple" then true else b)) })
(succ (let a = ({ e = true , c = unit }) in (if ({ e = "apple" , a = "boy" }) then (1 [ Unit ]) else "boy")))
({ b = ((\ C . (if (c . b) then a else ({ * A , unit } as Unit))) as ({ Some A , ({ b : Nat , b : Float }) })) , d = (\ c : (All E . Unit) . ("apple" as A)) })
(succ ((\ d : (String -> Bool) . (succ "boy")) . c))
(iszero ((succ b) (\ e : ({ Some A , Bool }) . c)))
(let { A , a } = ((if a then 0 else c) ("apple" . d)) in (pred (let e = (pred "apple") in (false 1))))
({ * (({ d : Bool , a : C }) -> (Nat -> B)) , (if (fix (if 2 then "apple" else 1)) then (\ c : (Nat -> Unit) . false) else (pred ({ * Nat , unit } as String))) } as ({ b : ({ b : (Bool -> A) , b : A }) , e : ({ Some C , Nat }) }))
(let { E , c } = (\ d : ({ Some E , Unit }) . (unit [ Unit ])) in ((let { A , e } = b in 2) . a))
(pred ((pred (let c = false in (fix false))) (succ c)))
((iszero ((false [ Bool ]) [ (B -> Nat) ])) as (((({ e : B , e : A }) -> (Float -> Float)) -> (Nat -> B)) -> ({ b : Bool , c : Unit })))
(fix ((1 . b) (\ a : Float . (\ c : Nat . "apple"))))
(iszero (fix (pred (\ e : Float . "boy"))))
(\ d : ({ Some C , (All B . Unit) }) . ((succ 2) [ (A -> C) ]))
(\ b : (((Float -> Float) -> Float) -> ({ Some B , Nat })) . (succ ((\ D . true) as (Bool -> String))))
((iszero ((unit [ Unit ]) 2)) . b)
((let { A , b } = (let a = (\ d : B . 0) in (let { C , c } = 2 in b)) in (\ E . (if a then true else (let { C , a } = "boy" in 0)))) as ({ d : ({ Some B , (All D . Float) }) , b : ({ b : ({ a : Bool , b : (A -> String) }) , c : (All E . String) }) }))
((({ * Nat , unit } as Nat) . a) as (All B . ({ a : (B -> B) , b : (All C . Unit) })))
(if (\ a : ({ Some B , ({ Some E , ({ b : A , b : B }) }) }) . (("boy" as (String -> B)) (\ C . a))) then (fix (true (fix a))) else ({ * (({ Some C , Unit }) -> (({ a : String , c : B }) -> (Nat -> C))) , (2 [ C ]) } as ({ d : (Nat -> Bool) , d : (Float -> String) })))
({ * ({ b : ({ Some C , ({ e : B , d : A }) }) , d : (All A . ({ e : Unit , a : ({ b : A , b : Float }) })) }) , ((succ (pred 0)) . c) } as (All C . ({ a : ({ Some B , ({ a : Nat , c : Unit }) }) , b : ((All A . Unit) -> (All C . Nat)) })))
(iszero (let d = (2 [ Nat ]) in (false . b)))
(if (fix (\ D . c)) then ((let e = b in true) as (All E . String)) else (pred (b as B)))
({ d = (((\ E . c) as Nat) . a) , e = ((\ b : (String -> B) . ((unit [ Float ]) 0)) [ ({ b : ({ a : Nat , a : C }) , d : ({ d : Float , c : A }) }) ]) })
((let a = ("apple" . e) in ({ b = (iszero unit) , e = 0 })) [ ((C -> ({ e : String , a : B })) -> (All E . Float)) ])
((pred (({ * B , false } as Bool) . c)) ({ c = (iszero ((\ e : Nat . 1) . e)) , b = (let c = (\ A . c) in ((fix unit) . d)) }))
(pred (if (\ D . false) then ("apple" as Unit) else (2 as Nat)))
({ * ((String -> ({ d : String , c : String })) -> ({ Some B , Float })) , (let { A , a } = (iszero (iszero true)) in ((2 as A) (let d = false in (iszero 0)))) } as ({ e : (All B . ({ Some B , Bool })) , c : ({ b : Nat , a : (All C . Bool) }) }))
((fix (succ "boy")) . d)
(let c = (succ (a 2)) in ((\ e : (All E . Float) . (let { E , e } = (\ B . b) in (c [ Nat ]))) [ ((Unit -> C) -> ({ Some B , (Bool -> Unit) })) ]))
(\ D . (pred (iszero (let { E , d } = b in 0))))
(let { C , d } = ({ * ({ b : Bool , a : Bool }) , (iszero (\ d : B . c)) } as (({ a : A , a : A }) -> (Bool -> C))) in (("boy" . b) . b))
(succ (\ d : (All C . ({ Some C , B })) . (let c = 1 in a)))
({ * (All E . ({ Some A , C })) , (\ c : (Unit -> Bool) . (\ D . false)) } as ({ Some D , (({ Some A , A }) -> ({ Some B , Bool })) }))
(let a = ((unit as String) [ ({ c : Unit , a : Unit }) ]) in (fix (unit [ B ])))
((if (succ (true . d)) then (pred 2) else (succ false)) (let { B , b } = ({ e = 0 , a = ({ * Bool , true } as Bool) }) in (let { A , b } = c in unit)))
(((1 (if 0 then false else a)) . a) as ({ Some B , (Nat -> C) }))
(fix ((\ D . (let { C , e } = "boy" in "apple")) . e))
((iszero (succ false)) as ({ b : ({ Some D , ({ c : C , c : C }) }) , c : (C -> C) }))
(if (((1 . e) as (C -> Nat)) as ({ d : (All B . Nat) , d : ({ Some D , B }) })) then (\ d : ({ a : String , b : Unit }) . (\ e : String . b)) else (let e = ({ d = 0 , b = true }) in (\ B . (1 false))))
(let b = (iszero (pred false)) in (let { B , e } = ({ * A , "boy" } as A) in (if (let a = true in c) then c else 2)))
(iszero (("apple" . a) (succ c)))
({ * (({ Some C , (All B . Float) }) -> (All E . (All C . Bool))) , (if (false [ C ]) then (iszero (succ 1)) else (0 as A)) } as ({ d : ({ d : A , d : Nat }) , d : (All A . Bool) }))
(let a = (pred ({ b = b , a = a })) in (succ ({ e = ({ * C , unit } as Float) , a = (\ E . c) })))
(pred ({ b = (if ({ b = "apple" , b = (true "boy") }) then (b "boy") else (iszero (pred b))) , e = (let { E , b } = (fix unit) in (\ A . unit)) }))
(pred (\ A . (\ b : ({ Some C , A }) . "boy")))
(pred ((\ D . (if 1 then b else 2)) as ({ c : A , b : ({ Some D , C }) })))
((iszero ({ * (Bool -> A) , (fix 1) } as ({ Some B , Bool }))) [ ((All A . ({ e : C , d : B })) -> (All E . Nat)) ])
(let a = ({ a = (\ D . ((let { A , a } = true in "boy") c)) , a = (iszero ({ c = unit , d = 2 })) }) in (({ * ({ a : String , d : C }) , (let d = b in "boy") } as ({ a : Float , e : Unit })) [ ({ d : (All C . Nat) , e : ({ Some E , Bool }) }) ]))
(pred (\ C . (\ d : Nat . 1)))
({ a = ((let a = false in (\ C . b)) [ ({ Some B , Bool }) ]) , b = (let { C , c } = (iszero ("boy" false)) in ({ * String , unit } as C)) })
((let c = (0 as Bool) in (b [ Unit ])) . b)
((if (\ c : C . a) then (iszero (\ D . c)) else (let { B , b } = (\ D . c) in (pred a))) [ (({ Some E , (All D . Bool) }) -> (All B . (String -> C))) ])
(let d = ({ b = (\ A . c) , d = (let a = ("boy" [ Nat ]) in ({ * B , c } as Nat)) }) in ((let { B , c } = 0 in false) [ ({ e : Unit , d : B }) ]))
((let { A , d } = ("apple" a) in (\ c : ({ e : A , a : C }) . (if false then true else (2 as Float)))) . d)
((iszero (succ unit)) as ({ c : (All D . C) , b : (({ Some D , Unit }) -> String) }))
((pred (false [ C ])) [ (All E . (All E . (Unit -> B))) ])
((succ (pred true)) . a)
(fix (let d = (iszero b) in (\ A . 2)))
(iszero ({ * ({ Some B , (Bool -> A) }) , (succ ({ c = c , d = 0 })) } as (All B . Unit)))
(pred (({ c = true , e = "apple" }) as (All A . ({ Some C , Float }))))
((let b = (succ (c . b)) in (1 as String)) (succ (pred (b . a))))
(iszero ({ * (Bool -> ({ Some A , Nat })) , ({ b = (let { D , c } = true in 2) , b = (unit as A) }) } as ({ e : (All C . String) , e : Nat })))
({ b = ({ d = ((pred false) as ({ Some D , String })) , d = (fix "apple") }) , e = ((fix (a [ String ])) as (All E . (Unit -> ({ Some D , Float })))) })
((pred (0 . b)) as (All D . ({ Some E , ({ d : Unit , d : Nat }) })))
(fix (iszero (let c = (iszero "apple") in "boy")))
(({ * (All C . B) , ((\ a : Float . b) c) } as (All C . B)) . e)
(\ e : ({ d : ((All E . ({ Some E , Nat })) -> (Nat -> C)) , c : ({ b : (A -> C) , d : A }) }) . ({ * ({ Some B , ({ d : (Nat -> Nat) , d : Unit }) }) , (if ({ * B , ("boy" . a) } as C) then (succ (c . a)) else (\ C . unit)) } as (All A . Nat)))
({ e = (("boy" [ B ]) . c) , d = ({ * ({ b : (All E . Unit) , e : ({ b : A , d : C }) }) , ({ * (Unit -> ({ Some E , Float })) , ((iszero c) (false as C)) } as (({ Some C , B }) -> A)) } as (All C . ({ b : Float , e : B }))) })
(let { D , a } = ((pred (1 . a)) . e) in ((\ a : (B -> A) . (c . b)) [ ({ Some E , (All E . String) }) ]))
({ c = (let b = (succ (iszero unit)) in ((b false) as C)) , b = (\ b : ({ a : (All A . Float) , c : ({ d : Nat , a : C }) }) . ((\ d : ({ Some C , Unit }) . 2) (succ "apple"))) })
(succ ((false [ ({ Some D , C }) ]) as ({ c : Unit , d : String })))
(let b = (let { C , e } = ("apple" . a) in (if false then "apple" else 1)) in ({ e = (pred c) , c = (fix b) }))
(iszero ({ b = (let { E , d } = ("boy" [ String ]) in (\ B . (let d = c in true))) , b = (("apple" "boy") [ (B -> C) ]) }))
((({ * ({ c : String , b : Float }) , (let { B , d } = (c 1) in (succ b)) } as ({ Some C , C })) [ (B -> ({ e : Unit , d : String })) ]) as (({ Some D , (All B . ({ Some B , Unit })) }) -> ((All D . (Unit -> Unit)) -> ({ Some E , B }))))
({ a = ((succ 0) as ({ Some B , (All B . C) })) , d = ({ * (All C . (String -> Unit)) , ({ * ({ a : C , b : Unit }) , (let { E , e } = a in "apple") } as B) } as ({ c : B , d : String })) })
((succ (iszero unit)) as ({ Some C , (Bool -> C) }))
(succ ({ * ({ Some D , A }) , (succ 2) } as ((All D . Float) -> Nat)))
((\ D . (iszero ({ e = unit , a = 0 }))) (succ (pred (succ 2))))
({ a = (fix (let { E , c } = b in 2)) , b = (fix (b as Nat)) })
(((pred 1) as ({ e : ({ Some E , Nat }) , a : (All D . String) })) [ ({ Some B , ({ Some A , B }) }) ])
(fix (iszero ("boy" . c)))
(pred (\ D . ({ d = (iszero 0) , c = (succ a) })))
(let { D , e } = ((let { A , d } = "apple" in b) as (All D . ({ Some C , String }))) in ({ * ((Float -> Float) -> Nat) , ({ * (All A . Nat) , ({ b = c , b = "boy" }) } as Nat) } as (All E . String)))
(iszero ({ c = (if (let { B , b } = unit in 0) then (\ b : String . unit) else 2) , a = ("boy" as Unit) }))
({ * ({ Some B , (All A . String) }) , ((let { B , a } = (\ E . false) in (\ e : String . 1)) (iszero (\ e : Float . unit))) } as (All A . (All C . ({ Some B , String }))))
(\ b : (All B . ({ a : B , c : Nat })) . (({ a = (let { A , a } = b in (b as Nat)) , e = ({ e = (fix c) , c = (iszero c) }) }) . b))
(let { A , e } = (fix (fix c)) in ({ e = ((iszero true) [ ({ b : C , e : Nat }) ]) , d = ((let b = true in unit) as ({ e : Unit , e : A })) }))
(let b = (succ (\ D . b)) in ((if c then "apple" else 0) [ (All A . Float) ]))
((iszero ("boy" . c)) (if (pred ({ b = unit , c = "apple" })) then (\ D . b) else (false . d)))
(\ C . (let { D , e } = (let { B , e } = (a [ A ]) in false) in (pred c)))
(let d = ((let { D , b } = a in "boy") . d) in (succ (fix (\ D . c))))
(let { C , c } = ((\ b : ({ Some B , A }) . (fix false)) [ ({ Some E , (All D . Float) }) ]) in (iszero (0 [ B ])))
(succ ((if "apple" then (iszero "apple") else false) (\ a : (A -> Unit) . (\ A . 0))))
(fix (\ E . (let { E , d } = (true . d) in (if c then false else b))))
(pred (\ c : (Float -> String) . (iszero b)))
((pred (iszero (b as Nat))) (fix (\ A . (1 . a))))
(({ c = (iszero 2) , a = (let { B , d } = false in b) }) as ({ c : (String -> B) , e : (All A . C) }))
(fix (\ D . ((b . e) . b)))
(if ((\ D . (let { D , e } = "apple" in 2)) . b) then ({ a = (true [ Nat ]) , b = ({ d = unit , e = 2 }) }) else ((succ true) [ ({ d : String , c : Nat }) ]))
(\ b : ({ Some C , (Float -> B) }) . ({ * ({ c : ({ c : Unit , e : Bool }) , c : ({ e : C , d : String }) }) , ({ a = (\ B . false) , a = (unit as String) }) } as ({ e : B , c : String })))
(if (if (pred ({ * Float , unit } as Unit)) then (let { B , b } = (let { C , b } = unit in "apple") in true) else ({ * ({ d : Unit , b : Bool }) , (\ b : Unit . 2) } as (String -> Unit))) then ((({ c = unit , b = true }) [ (All C . Nat) ]) as (All C . Float)) else (\ D . ((let { E , d } = 0 in a) (fix (false "apple")))))
((\ e : ({ b : B , e : (C -> B) }) . (\ A . "apple")) (fix (unit [ ({ Some E , C }) ])))
(\ b : ((All D . Bool) -> (String -> B)) . (\ B . ((let { E , b } = 0 in "boy") . a)))
(\ B . (({ * ((B -> Unit) -> A) , (pred "boy") } as (All E . B)) . e))
(({ c = (fix (if true then 1 else "boy")) , a = ((c true) [ ({ c : Float , e : Bool }) ]) }) . e)
(if (let c = (2 [ B ]) in (\ C . unit)) then (\ A . ({ c = (0 as Nat) , b = c })) else ({ a = (let { E , d } = false in (unit as Float)) , d = (if ({ * Bool , "boy" } as Unit) then (c as C) else (fix "apple")) }))
(iszero ((if c then 0 else true) as ({ c : Bool , e : Bool })))
((let c = (\ E . ((true . b) as Nat)) in ({ * (Nat -> Unit) , (\ a : (All A . A) . (let b = 2 in 0)) } as (Float -> (Float -> Nat)))) [ (All E . ((B -> B) -> ({ Some E , B }))) ])
(succ (if ({ * String , (iszero c) } as C) then ({ e = c , a = (fix c) }) else ({ * ({ Some D , ({ Some D , C }) }) , (pred false) } as (String -> B))))
({ * ({ c : ({ Some B , (All B . B) }) , b : ({ b : Nat , b : A }) }) , ((2 as ({ e : Nat , a : Unit })) . d) } as (All B . (Bool -> A)))
((let { B , c } = ({ a = "apple" , e = 1 }) in ({ d = 1 , c = 2 })) [ ({ Some A , ({ Some E , C }) }) ])
((if (\ b : ({ a : B , e : Nat }) . 1) then (unit unit) else ({ * ({ d : Bool , e : String }) , ("apple" "boy") } as ({ Some B , B }))) as ({ Some A , ({ b : C , e : (All B . Unit) }) }))
(let d = ({ * ({ Some B , ({ Some B , Float }) }) , ("apple" "apple") } as ({ c : B , e : String })) in (\ D . (c as Bool)))
((if (let a = a in 1) then (pred (false true)) else (a as B)) . d)
(\ E . ((let { E , e } = c in true) . c))
((let d = (b (0 [ B ])) in ({ * String , 1 } as (All C . String))) [ (All E . (All B . ({ e : Float , e : Nat }))) ])
(\ b : (All B . ({ Some D , (Float -> (All B . C)) })) . (fix ({ * A , (unit . c) } as Bool)))
(let { A , e } = (let { A , c } = ((succ b) as ({ Some B , A })) in (({ c = unit , a = 0 }) as ({ Some A , Bool }))) in ({ d = (succ (if ("boy" 2) then (\ b : Nat . true) else c)) , b = ("boy" . e) }))
(let { C , e } = (if (let { D , a } = b in "apple") then (succ ({ * Nat , 2 } as String)) else (succ unit)) in (fix (let b = 1 in 2)))
(pred (if (b true) then (succ c) else ({ * Nat , 0 } as Nat)))
(let c = (pred ({ * C , "apple" } as A)) in ({ e = (unit [ (B -> Nat) ]) , c = (iszero (iszero 2)) }))
(let c = (((iszero (iszero 2)) . c) as ({ a : Bool , c : (All A . Float) })) in (pred (let { A , a } = unit in true)))
({ * ({ Some C , ({ a : ({ c : String , d : String }) , e : (Nat -> String) }) }) , ((fix a) [ (({ d : Unit , d : String }) -> ({ b : A , b : C })) ]) } as ({ e : (All E . (String -> B)) , e : (({ Some B , (All B . Nat) }) -> (All B . String)) }))
((succ (fix (2 . a))) (\ A . (iszero true)))
(let { A , d } = (succ (iszero 1)) in (({ b = (unit true) , d = (\ E . false) }) as (All B . Nat)))
((pred ((let { A , a } = b in "boy") false)) [ ({ d : ((B -> C) -> ({ a : Nat , e : (All C . String) })) , a : (({ Some A , Nat }) -> (All B . Unit)) }) ])
(fix (({ d = (let e = "boy" in ({ c = true , e = false })) , e = (pred ("apple" true)) }) [ ({ c : A , b : (C -> Nat) }) ]))
(succ (succ (pred true)))
(if (let { C , e } = (2 [ B ]) in (\ B . 1)) then (let { D , e } = ((2 [ Nat ]) . a) in ({ b = (let d = "apple" in b) , e = (b . d) })) else (iszero (let b = 0 in (b . c))))
((fix (\ B . b)) [ ({ Some E , ({ Some E , Unit }) }) ])
({ e = ((iszero (2 1)) ((1 as Unit) . a)) , c = (\ b : ((Unit -> B) -> C) . ({ * A , "boy" } as Nat)) })
((\ c : (Float -> String) . (let d = (succ (\ A . unit)) in ((a [ C ]) as (C -> C)))) . d)
(if (let { A , c } = (unit as Bool) in (c . b)) then (\ D . ((pred false) (a . e))) else (\ a : ({ c : (C -> String) , a : ({ Some A , Bool }) }) . (let b = (iszero 2) in (let b = 1 in true))))
(iszero (((unit [ Float ]) . e) as ({ c : (All A . Nat) , e : ({ Some D , String }) })))
(let c = (succ (iszero (fix b))) in (\ e : (B -> (Unit -> Float)) . (succ 1)))
(let { B , b } = ((let { B , b } = "boy" in (\ e : Bool . 1)) as ({ c : ({ Some E , Bool }) , d : ({ Some D , String }) })) in (pred (succ (pred b))))
(succ (("apple" [ B ]) [ ({ Some E , Unit }) ]))
(succ (((if (a 0) then (1 [ Unit ]) else true) . d) . b))
({ e = ({ b = (succ (false . c)) , e = (true . e) }) , c = ({ * (Float -> ({ d : String , b : Unit })) , ((\ c : A . 2) [ ({ a : Nat , c : Nat }) ]) } as (All C . (All D . Nat))) })
(fix (pred (let c = c in false)))
(({ c = ({ * (Bool -> Unit) , (true as String) } as (All E . A)) , a = ({ * (All B . Unit) , 2 } as Unit) }) as (((String -> Nat) -> (Nat -> Nat)) -> ({ Some A , Unit })))
(pred (fix (pred unit)))
((let { C , c } = ({ a = ({ * Unit , false } as C) , c = b }) in (let { A , d } = (\ d : Float . unit) in 2)) as ({ e : ({ Some B , Bool }) , a : (All D . A) }))
(({ * ((Bool -> Nat) -> (All C . Bool)) , (iszero (\ A . "apple")) } as ({ Some C , ({ Some D , B }) })) as ({ Some C , (All B . Unit) }))
(\ C . ({ * (All A . C) , ((\ E . false) ({ d = b , b = 0 })) } as (All E . ({ Some B , Float }))))
((\ d : (All E . ({ b : B , c : C })) . (true . e)) . b)
(iszero (let { E , a } = ({ * (All C . B) , ("boy" as B) } as Nat) in (let d = unit in (c [ A ]))))
((\ b : (All E . (All A . Float)) . ((iszero "boy") ({ * String , 1 } as String))) . b)
((let { C , d } = (pred ({ * String , a } as Float)) in ({ * ({ c : C , d : Bool }) , (if true then false else "boy") } as Bool)) ({ b = (succ ({ * Bool , c } as Unit)) , b = (succ true) }))
(\ a : (({ Some A , (All D . ({ Some C , Nat })) }) -> ({ Some A , Bool })) . ((pred 2) . e))
(\ a : ({ Some D , (String -> Unit) }) . ((pred (pred b)) . d))
((\ B . (let c = 0 in 2)) (if (fix 1) then ((if "boy" then "boy" else unit) (fix 2)) else (({ * Nat , a } as String) . c)))
(iszero (\ C . (iszero (unit . e))))
(if ((\ A . unit) (iszero a)) then ((({ * Bool , unit } as A) . b) . b) else ((let a = (pred c) in (\ D . (0 . e))) (let a = (1 as Nat) in (c "apple"))))
(iszero (\ c : (All B . (Unit -> Float)) . (iszero (pred 0))))
({ b = (let { D , b } = (fix ({ c = 0 , a = b })) in (if (\ c : Unit . true) then 0 else (iszero "apple"))) , e = (fix (\ b : Float . 2)) })
({ * ({ Some E , (Bool -> (All B . Nat)) }) , (let c = (fix (let { A , c } = "apple" in 2)) in ((2 . b) (2 as Unit))) } as (All A . ({ Some E , (All B . ({ Some A , Nat })) })))
(let { B , c } = ({ d = (let { E , b } = (iszero (\ B . 0)) in ({ * Nat , a } as B)) , d = (let { A , b } = (iszero 2) in (pred 2)) }) in (let { C , b } = (c [ ({ a : C , e : String }) ]) in ((iszero 0) . a)))
(if (fix (\ e : A . (unit false))) then (succ (fix unit)) else (iszero (let d = (c . a) in ({ * String , b } as A))))
(let e = (\ a : (B -> (Unit -> A)) . (succ (false (let { E , b } = "boy" in false)))) in (let e = (fix b) in (if (let b = a in c) then unit else a)))
(succ ((if ({ * Bool , 1 } as Nat) then ("apple" [ String ]) else ((succ 1) b)) . c))
({ * (All A . ({ a : (All A . (A -> Unit)) , b : ({ Some E , C }) })) , (((false . c) as ({ Some B , (C -> Nat) })) [ ({ Some D , (Bool -> Float) }) ]) } as ({ Some E , (All C . Float) }))
(let b = (\ b : (B -> Nat) . (\ d : (Float -> B) . 2)) in ((succ "boy") . d))
(let d = ((fix (let a = "boy" in 2)) [ (({ Some B , A }) -> ({ b : Unit , b : A })) ]) in (succ ((iszero "apple") [ (All E . A) ])))
(\ E . (let { E , e } = ({ * (All A . A) , b } as ({ e : B , b : Unit })) in (pred (pred c))))
({ * ({ Some D , (B -> Nat) }) , (fix (\ A . (\ c : Float . c))) } as (({ Some B , ({ b : B , a : A }) }) -> (({ d : Nat , a : Float }) -> Unit)))
(fix ((let d = (fix (let a = 1 in true)) in (let c = 1 in b)) . e))
((succ (pred c)) . a)
(if (succ (let { D , b } = (0 . d) in 1)) then (succ (if (\ a : (String -> Nat) . b) then (\ A . c) else (let c = false in unit))) else (if (false . a) then (unit [ ({ b : Float , e : A }) ]) else (fix c)))
(let { C , c } = (let { A , c } = (let d = b in "boy") in (pred "apple")) in (let { A , d } = (let c = (let a = a in "boy") in (\ c : String . b)) in (a b)))
(({ a = (let d = ((a . d) . e) in (iszero 0)) , c = (\ C . ({ * B , (0 . a) } as (Unit -> Float))) }) [ ((Nat -> String) -> (All B . B)) ])
(if (if (succ c) then ((true as String) [ (All B . C) ]) else ((c [ B ]) [ ({ c : Nat , b : ({ c : Unit , c : String }) }) ])) then (if ((let a = b in c) . a) then ((iszero (succ "boy")) (\ a : Unit . 1)) else (({ * ({ c : String , d : Float }) , (pred false) } as String) as ({ a : (All A . C) , a : ({ b : Unit , b : Bool }) }))) else (\ c : (All E . (All E . Nat)) . (let { B , b } = "boy" in a)))
({ a = ((\ c : (A -> Bool) . 2) [ ({ c : (Unit -> (Bool -> A)) , a : ({ Some B , Bool }) }) ]) , c = (succ ((\ e : A . false) as ({ Some C , (All B . A) }))) })
({ * (All B . (All D . Bool)) , ({ * ((C -> Nat) -> (B -> B)) , ({ d = true , a = a }) } as (Unit -> C)) } as ({ b : ({ c : ({ Some A , Bool }) , c : (B -> Unit) }) , c : (C -> A) }))
(\ E . (let b = ((fix "apple") (let { E , e } = "boy" in a)) in ((fix "apple") as B)))
(\ A . ((let { C , c } = b in unit) as (All C . Bool)))
(succ (let a = (if "apple" then 0 else unit) in (if 2 then (a "boy") else false)))
(\ A . (({ * ({ e : Bool , e : Unit }) , (let { D , c } = unit in b) } as ({ b : ({ b : A , b : Float }) , b : ({ Some C , B }) })) (iszero (1 unit))))
(let { A , a } = ({ e = ((succ true) as ({ e : Bool , c : B })) , b = (succ (b [ A ])) }) in (succ (let { E , c } = (succ true) in (\ c : Bool . b))))
(\ d : ({ a : ({ Some A , Bool }) , a : ({ Some C , Bool }) }) . ((succ c) (a . d)))
(succ (iszero (succ "boy")))
(succ (iszero (false [ (Unit -> Nat) ])))
({ c = ((let e = (pred 2) in (0 as ({ Some E , B }))) as ({ d : B , b : ({ Some C , A }) })) , b = (({ * C , 0 } as Float) as ({ a : B , b : Bool })) })
({ b = (if ("boy" 0) then (fix ("boy" as B)) else (pred (\ b : String . c))) , a = ((succ a) as ({ d : Bool , b : A })) })
(((fix (let e = ("boy" as C) in (if c then "boy" else b))) as (All E . (C -> ({ Some E , Unit })))) as (All B . ({ Some E , B })))
(let { A , e } = ((iszero 0) [ (String -> String) ]) in (if ((succ 2) as String) then (if "apple" then (\ A . false) else (true [ Float ])) else ({ d = unit , a = unit })))
(iszero (iszero (let { E , a } = (let { E , c } = false in true) in (let { E , b } = "apple" in "boy"))))
(pred ({ * ((All C . Float) -> (All E . Bool)) , ("apple" as A) } as ({ c : B , d : String })))
({ c = (\ b : (All A . ((All A . A) -> ({ Some A , Bool }))) . ({ * (All C . Float) , (iszero 0) } as Nat)) , c = (fix (({ * C , b } as Unit) . d)) })
((\ A . (let c = true in false)) as ({ c : ({ Some C , Bool }) , b : ({ d : (All E . Float) , c : (Bool -> B) }) }))
(succ (let e = ({ * ({ e : Nat , a : Nat }) , (let d = 2 in 0) } as Nat) in (let b = (\ C . 2) in (if (succ c) then (2 [ Bool ]) else 2))))
(\ C . ({ c = (\ e : Nat . 1) , a = (fix b) }))
({ b = ((let a = 2 in (let d = unit in 1)) . d) , e = (let { B , c } = (let e = (fix (pred true)) in (fix 1)) in (succ 1)) })
({ * ((All A . A) -> ({ Some E , Nat })) , (let { A , b } = (((pred c) as Bool) . d) in ({ * (Bool -> Unit) , (b as String) } as String)) } as ((All D . String) -> (({ Some A , C }) -> A)))
((((iszero unit) [ Float ]) [ ((Unit -> Bool) -> ({ Some E , Nat })) ]) ((\ a : Nat . c) (fix 1)))
((\ c : (All A . ({ Some A , (All A . String) })) . (if 0 then unit else (c . b))) (let c = ((iszero (true true)) [ (({ e : Bool , b : Unit }) -> Nat) ]) in (2 [ C ])))
(((\ a : (All D . (Nat -> Bool)) . (0 [ ({ Some D , Nat }) ])) ({ a = (true . c) , c = 1 })) [ (All D . (Float -> C)) ])
({ d = (fix (\ A . ({ * C , 1 } as String))) , b = (let { D , e } = (((b as Nat) [ (Bool -> C) ]) (if 1 then a else 1)) in ((b [ String ]) [ ({ a : Nat , c : Float }) ])) })
(\ c : ({ d : (({ Some A , C }) -> (Nat -> String)) , a : (Unit -> (Bool -> Bool)) }) . ({ * (All B . ({ d : Bool , c : B })) , (succ false) } as ({ a : String , e : (C -> Unit) })))
(iszero (\ e : ({ a : ({ e : A , b : Bool }) , b : (All D . Nat) }) . (let c = (if 2 then (let e = 1 in b) else (\ a : Unit . 1)) in ({ * (Nat -> Bool) , (pred 0) } as ({ Some D , B })))))
(if (iszero (let c = "apple" in 1)) then (iszero ({ a = (2 0) , b = (let a = b in 0) })) else (\ c : (Nat -> Bool) . (2 [ Nat ])))
(\ D . (("apple" true) [ ({ b : (B -> Bool) , b : ({ Some A , C }) }) ]))
(let { A , d } = (\ d : ({ Some B , Unit }) . ((let e = a in false) . c)) in ((pred (succ c)) (pred 0)))
((let { B , e } = ((a [ String ]) [ ({ c : A , b : String }) ]) in (pred (false as Float))) [ (All C . (All D . ({ Some B , C }))) ])
(pred ((if true then true else c) . d))
(if (let d = ("boy" . b) in (b . c)) then (let c = (("boy" as Nat) as (Float -> B)) in ({ a = 0 , d = b })) else ((fix (b as Float)) . e))
({ * ({ Some C , (({ Some A , ({ d : Nat , d : Bool }) }) -> (All D . ({ Some A , A }))) }) , ((let { A , a } = (false [ A ]) in (false c)) as ({ Some D , Unit })) } as (((All C . C) -> (Float -> Unit)) -> ({ b : (All C . B) , d : (All B . Float) })))
(succ (\ E . ("apple" . e)))
(fix ((if a then false else 0) . d))
({ a = (let b = ({ a = "apple" , b = ({ * A , "apple" } as C) }) in (let d = 0 in 1)) , b = ((iszero ({ b = c , c = a })) . c) })
((succ (pred 0)) . d)
(fix ((fix (c [ Unit ])) [ ({ e : B , c : B }) ]))
(({ * (All E . ({ d : ({ Some E , Nat }) , c : A })) , ((if b then c else b) [ ({ Some E , (Unit -> A) }) ]) } as (All A . (Unit -> A))) [ ({ b : (({ Some B , String }) -> B) , d : ({ b : ({ c : C , e : B }) , e : (B -> A) }) }) ])
((if (pred (\ d : A . "boy")) then (let { A , d } = 2 in false) else (fix unit)) . b)
(((if unit then 0 else (\ E . b)) [ (All A . Nat) ]) [ (({ Some B , (String -> Nat) }) -> ({ Some D , (Bool -> A) })) ])
((let { B , e } = (iszero "boy") in (fix ({ a = (true . b) , a = (a as B) }))) [ ({ d : ({ c : C , e : (All E . Float) }) , d : ({ a : ({ Some D , Float }) , e : (All D . (String -> Nat)) }) }) ])
((let c = (iszero unit) in (\ B . "boy")) [ (All C . (All B . ({ Some E , String }))) ])
(if (succ (("apple" a) [ A ])) then (\ B . (0 as (B -> B))) else (iszero (0 as C)))
(((\ e : String . true) [ ({ Some C , Unit }) ]) as (All E . ({ Some D , ({ Some D , Nat }) })))
(let c = (if (false a) then ((fix 0) [ (All D . (All E . A)) ]) else (let e = a in c)) in ((\ a : (All E . Bool) . (unit . d)) [ ({ Some D , Nat }) ]))
(iszero (let { C , a } = (iszero 1) in (succ (succ "boy"))))
(let { D , d } = (fix ({ c = ({ * C , a } as Unit) , b = (if (let { E , e } = a in unit) then (iszero "boy") else (1 as A)) })) in (fix (0 as B)))
(\ B . ({ c = (pred (let e = b in "boy")) , d = ({ b = a , c = (false . b) }) }))
(iszero ((0 as (B -> Unit)) as (Unit -> String)))
(pred (pred ((let { B , e } = "apple" in 1) . a)))
({ * ({ c : (All A . ({ e : Nat , a : A })) , b : (Nat -> ({ Some D , A })) }) , (if ({ b = ("boy" . d) , c = (succ (iszero 0)) }) then (let { D , a } = ((\ b : B . b) . e) in ({ * B , false } as C)) else (let { C , a } = b in (let { D , a } = "apple" in 2))) } as (All D . ({ Some D , A })))
(\ C . (fix ((pred ({ * A , unit } as Nat)) as ({ Some D , A }))))
(let b = (pred (\ b : (All E . B) . (pred (\ B . "apple")))) in (\ C . ((pred a) (true a))))
(iszero (fix (if b then (\ e : Unit . false) else (if true then a else a))))
({ b = (let { A , a } = (let e = (let a = b in 0) in ("apple" "boy")) in (\ B . (let d = "apple" in b))) , d = ((({ * A , false } as Float) [ (String -> Unit) ]) . b) })
((\ E . ((if "boy" then 1 else a) as ({ e : (String -> Float) , b : Unit }))) (let { D , b } = (if (1 . d) then ("apple" as A) else ((fix "apple") as (All D . B))) in ((let { C , b } = c in 2) [ ({ Some A , ({ Some E , Unit }) }) ])))
(iszero ({ e = (iszero false) , d = (fix true) }))
(succ (let { D , a } = (unit . d) in (let { D , e } = 2 in true)))
(\ B . (\ E . ((\ E . c) false)))
(let a = (if (let b = 1 in 2) then (c [ Bool ]) else (if 2 then a else 0)) in ({ c = ("apple" unit) , e = (if ("apple" . a) then b else 0) }))
(iszero (if (succ (if 0 then true else unit)) then (succ (c . a)) else (pred (\ E . true))))
(iszero ({ * (String -> Bool) , ({ a = "apple" , e = "apple" }) } as (All B . Nat)))
((({ a = (fix true) , e = (succ b) }) as ({ Some D , ({ Some E , C }) })) [ ((All C . B) -> (All D . String)) ])
(let e = (let { C , a } = (iszero b) in ({ b = c , c = a })) in (\ c : (({ Some A , Nat }) -> ({ Some C , Nat })) . (succ (iszero unit))))
((if (({ * Bool , false } as Float) [ (All C . Nat) ]) then (iszero (let { B , c } = (let { C , a } = unit in unit) in (\ E . "boy"))) else (pred (\ d : B . "boy"))) [ (All A . (({ Some D , Bool }) -> Bool)) ])
({ e = (let { B , e } = (let a = "boy" in "boy") in (\ E . unit)) , d = ((\ a : (All B . ({ e : String , b : Bool })) . (iszero 0)) (\ a : (All E . A) . (iszero "apple"))) })
((\ A . (iszero "apple")) . a)
(fix (iszero (let b = (iszero 2) in ({ * A , 2 } as Nat))))
(pred ({ b = (iszero 2) , c = (0 (fix b)) }))
(if (fix (2 [ Bool ])) then (\ E . ((let { B , c } = "apple" in true) as Unit)) else (if (let { E , d } = b in (\ b : C . unit)) then (fix a) else (pred b)))
(((let { D , c } = unit in false) . c) (fix (unit (b [ Nat ]))))
(succ (({ * ({ Some E , String }) , (c as Bool) } as ({ Some A , A })) ({ * Unit , a } as B)))
(succ (({ e = 1 , c = "boy" }) . e))
((pred (1 . b)) [ ({ d : ({ Some D , Bool }) , a : (All B . Nat) }) ])
(({ * ({ Some C , ({ c : String , e : Nat }) }) , ((let d = a in 2) (fix unit)) } as ({ b : Bool , d : B })) ({ a = ({ c = ({ * A , "apple" } as String) , a = unit }) , d = (pred (succ "boy")) }))
(((let b = unit in c) (1 as ({ c : C , d : Unit }))) . e)
(let c = (\ b : (All E . B) . (fix (iszero true))) in ({ e = (\ d : String . (iszero "boy")) , c = (fix ("boy" . b)) }))
((let d = (succ (\ c : ({ Some E , A }) . (let b = "apple" in 1))) in (((iszero 2) 1) (let { B , a } = false in "boy"))) . e)
((fix (\ e : (Float -> Float) . (iszero c))) as (All C . ({ d : ({ d : String , b : Float }) , c : C })))
({ d = ((if a then "boy" else 2) . e) , a = (pred (iszero (b as B))) })
(let d = (iszero (c [ Bool ])) in (iszero (\ E . c)))
((pred (if c then (let { B , b } = unit in true) else (let { B , b } = c in a))) . d)
(pred (\ E . (\ a : ({ d : Bool , d : Nat }) . b)))
(if (pred (\ C . "apple")) then (\ D . (let { E , a } = c in (let c = 1 in "boy"))) else (fix (pred a)))
(\ d : ({ d : (Unit -> B) , c : ({ b : String , d : ({ a : C , b : Float }) }) }) . (let a = (\ D . b) in (1 (2 0))))
(((succ 2) as (A -> C)) (iszero (0 . d)))
(fix (pred (\ b : (B -> Float) . (1 as B))))
(let e = (({ * C , "boy" } as Float) . a) in (fix ((fix true) (false 0))))
({ b = (\ D . (let { D , a } = ({ * Float , (succ "boy") } as A) in (true a))) , b = (let e = (iszero (succ unit)) in (let { E , b } = (pred "apple") in (succ 0))) })
(let { D , c } = (iszero (\ b : (All D . Unit) . 0)) in (iszero (pred 0)))
(if (succ (let a = (fix b) in ("boy" . d))) then (let { A , e } = (let { B , b } = unit in false) in (\ E . true)) else (\ C . ((\ c : Float . 1) . a)))
(fix (\ D . (\ C . (iszero b))))
(iszero (pred (let { B , d } = (pred true) in (succ (succ true)))))
({ e = ((if "boy" then unit else true) . b) , c = (pred (succ (1 as C))) })
(fix (let c = (succ 0) in (if 1 then (0 . b) else (c . e))))
(((({ * A , unit } as Unit) [ (String -> Nat) ]) [ (All C . (All D . String)) ]) (let { B , b } = ("apple" . b) in (let a = "apple" in 0)))
(fix ({ * ({ Some A , ({ d : ({ a : Unit , a : String }) , c : ({ Some C , A }) }) }) , ({ * ({ Some C , A }) , (unit as B) } as B) } as ({ Some D , ({ Some B , Float }) })))
({ * ({ d : ({ Some B , ({ Some D , (All A . Bool) }) }) , e : ((All C . Float) -> String) }) , ((false . e) as (({ Some C , C }) -> String)) } as ((Float -> Bool) -> (String -> Bool)))
(iszero (let { E , d } = ({ a = (let { D , e } = "apple" in 2) , a = 1 }) in (let a = (pred 0) in (let d = b in "boy"))))
(iszero (succ (pred ({ * C , 2 } as Float))))
(succ (succ ((let { E , d } = "apple" in "apple") [ Float ])))
(((\ D . (\ C . "boy")) ((\ e : Unit . true) (pred unit))) as ({ Some C , ({ a : Float , a : A }) }))
(iszero ((0 [ B ]) . e))
({ * ({ Some B , (All B . B) }) , ({ b = (\ e : A . c) , a = ((if false then a else 2) as B) }) } as (All D . (({ Some C , Nat }) -> (Float -> Unit))))
((pred (\ e : ({ a : A , a : B }) . (1 true))) [ ({ Some A , ({ Some C , (Nat -> Bool) }) }) ])
(\ d : (All E . (All D . Float)) . (let { A , a } = (let e = 0 in (\ E . true)) in ({ d = 2 , b = b })))
(\ c : (All C . ({ Some E , ({ c : String , c : A }) })) . (let b = (pred "boy") in (let b = c in c)))
((pred ((false [ B ]) [ (Unit -> A) ])) . d)
((({ a = ("apple" as Float) , a = (1 . d) }) [ ({ e : ({ Some D , Float }) , b : Unit }) ]) [ (({ d : Unit , c : ({ c : Float , e : B }) }) -> ({ Some E , Nat })) ])
(pred ({ * (All A . String) , (let b = (let { A , a } = unit in 0) in "boy") } as ({ Some A , String })))
(\ e : ({ Some D , ({ Some E , ({ a : (Bool -> Unit) , d : (All D . A) }) }) }) . (((if "boy" then unit else c) (pred 1)) [ ({ Some D , B }) ]))
({ c = (pred (pred "boy")) , b = (let d = (let { C , a } = a in (if false then "apple" else 1)) in (fix (1 as Nat))) })
({ * (({ Some D , A }) -> (All E . C)) , (let { B , a } = (iszero (pred a)) in (fix 0)) } as (All C . ({ Some D , Unit })))
(let d = (fix (let { C , a } = (fix a) in "apple")) in ((let e = (if b then "boy" else false) in 0) [ ({ a : Bool , e : String }) ]))
(\ c : ({ c : ({ Some D , String }) , e : ({ Some B , A }) }) . ((\ e : Unit . 2) ({ d = (a as Bool) , d = (let { C , c } = c in false) })))
((if (\ c : Bool . false) then ({ b = (\ a : A . unit) , c = (c as Bool) }) else (iszero "boy")) . a)
(let { D , b } = (let a = (succ (let a = 2 in b)) in (succ "apple")) in (let { D , a } = ({ * Float , b } as String) in ((\ b : C . c) as (All E . Unit))))
(iszero ((pred 0) . d))
(\ a : (All B . ({ c : ({ Some C , Unit }) , a : C })) . (iszero ({ c = "apple" , c = (fix c) })))
(let a = ((succ ((true . e) as (Float -> Bool))) . c) in (\ A . (if (1 true) then (let e = true in 2) else (let c = (iszero c) in "boy"))))
(iszero ({ e = ({ d = (1 . b) , e = (false unit) }) , e = (iszero 2) }))
(((\ D . (pred (let b = b in true))) [ (All B . (Float -> Unit)) ]) [ ((All E . (Float -> String)) -> ({ d : B , e : ({ Some E , String }) })) ])
(pred (pred (\ e : (C -> String) . ({ c = a , d = 2 }))))
(\ d : (All B . ({ Some C , String })) . (fix (\ b : ({ Some D , Float }) . b)))
(succ (\ b : (All C . Nat) . (succ 1)))
(pred (if ({ b = ({ * Bool , c } as Float) , a = (\ a : A . "boy") }) then (false as C) else (if 0 then "boy" else (\ c : Float . "boy"))))
(fix ({ e = (b . b) , b = ({ c = c , d = c }) }))
(\ C . (\ D . ((if b then 0 else unit) . c)))
((\ d : (All D . Bool) . (succ 1)) . b)
(((b as Unit) as (All C . (A -> Float))) (fix (let { E , a } = a in ({ d = false , a = b }))))
((if (pred 0) then (iszero 1) else (if "boy" then (succ false) else b)) (pred (\ B . (false [ String ]))))
((let d = (let b = (\ c : Unit . unit) in (let { C , b } = "boy" in (fix unit))) in (succ b)) . b)
(succ ((\ a : Unit . 1) as ({ Some C , A })))
(iszero ((let { E , d } = a in a) . a))
(let { E , a } = (iszero (pred c)) in (\ a : ({ Some C , Unit }) . (pred (let b = false in 2))))
((({ * ({ b : Nat , d : Bool }) , (if unit then c else b) } as ({ Some A , Unit })) [ (All C . B) ]) [ ({ c : (Unit -> ({ Some A , C })) , e : (B -> ({ Some A , Unit })) }) ])
(pred (\ D . ({ e = ({ * String , 0 } as Float) , a = unit })))
((\ e : (All E . Nat) . (\ C . 1)) as ({ b : (A -> Float) , d : (C -> Float) }))
(pred ((\ D . ("apple" [ Float ])) as ((All A . Bool) -> (All C . C))))
(succ (succ (succ (\ c : C . 1))))
({ a = (pred ((succ 2) [ Bool ])) , a = ((\ A . "apple") . e) })
(let { D , a } = (({ c = (true as String) , e = (b [ A ]) }) ({ * (Nat -> Bool) , (iszero (let d = false in 0)) } as ({ d : Float , d : Nat }))) in ((\ B . "apple") [ ({ c : Nat , b : C }) ]))
((succ (iszero (1 . d))) as ({ Some C , (Bool -> C) }))
(iszero (pred (b as A)))
(iszero (let b = (fix (succ "apple")) in ((iszero (succ 1)) as ({ Some C , B }))))
(if ((c as A) [ (Unit -> B) ]) then ((succ (pred false)) as (All A . (All A . A))) else ((let { C , b } = (succ "boy") in (iszero 2)) (2 as C)))
({ * (({ c : (String -> B) , b : Nat }) -> ({ Some D , String })) , (pred (c [ Float ])) } as (All D . (({ c : Float , d : Float }) -> A)))
(succ (pred ({ a = (let e = "boy" in 2) , d = ((succ true) . d) })))
(pred ((let { D , b } = "apple" in (2 [ Unit ])) [ (All D . C) ]))
((succ ((let { C , e } = c in 0) (1 . b))) as ({ a : ((All D . Unit) -> (B -> String)) , e : ({ Some A , ({ b : Nat , e : Bool }) }) }))
(let { A , a } = ((iszero (\ c : C . false)) as (All D . ({ Some E , String }))) in (iszero (\ E . true)))
(succ ((2 [ Unit ]) . c))
((({ * ({ Some C , Float }) , false } as ({ Some B , Nat })) as ({ Some D , String })) . e)
(pred (if (c [ Bool ]) then (2 as ({ a : Unit , c : String })) else ({ * C , 0 } as Unit)))
(let { A , d } = ({ * ({ c : ({ a : B , b : A }) , d : (All C . (C -> C)) }) , (0 [ (All D . String) ]) } as ({ Some C , ({ a : Bool , d : String }) })) in (succ ({ b = 2 , b = c })))
(succ ((if c then a else a) . c))
(let e = ({ b = (pred ("apple" [ Unit ])) , e = (\ C . (let { C , a } = true in 1)) }) in (let { C , a } = (let a = ("boy" [ C ]) in (pred unit)) in (unit as (Float -> B))))
(((pred 1) as ({ Some A , (Float -> Bool) })) as (All D . ({ Some E , ({ c : B , a : B }) })))
(\ E . ((succ "apple") [ (A -> ({ c : C , a : Nat })) ]))
((let d = (\ d : (All A . Nat) . (true . c)) in (fix 0)) . b)
(((fix false) (succ 2)) (\ D . (let a = "boy" in "apple")))
(let e = (\ b : ({ e : Float , e : A }) . (if (unit . d) then false else (pred "boy"))) in (let { E , d } = ((iszero (b as Nat)) as ({ Some C , ({ Some B , Nat }) })) in (\ a : ({ b : Float , b : B }) . (\ C . ("apple" as Bool)))))
(iszero (succ ({ e = (succ (succ 1)) , d = (let { B , d } = true in unit) })))
(\ b : ({ e : ({ a : (All D . A) , a : (All C . Unit) }) , d : (All A . (String -> Float)) }) . ({ d = (if 1 then true else 2) , e = (\ A . "apple") }))
((if (iszero true) then ({ d = (1 . e) , d = ({ * ({ Some A , A }) , (if true then 1 else a) } as Float) }) else (iszero (if 0 then false else "boy"))) [ (({ d : Bool , b : Unit }) -> (Unit -> String)) ])
(\ c : ({ a : ({ Some E , C }) , d : (All D . C) }) . (let { E , a } = ({ * ({ d : String , d : A }) , 2 } as Unit) in ((iszero a) [ (All D . B) ])))
(succ (succ (let a = (c [ ({ c : A , a : C }) ]) in (\ C . a))))
(\ B . (let { A , a } = (false (1 as Bool)) in (succ true)))
(let { B , e } = ((succ b) [ ({ d : String , a : Nat }) ]) in (fix (if false then b else a)))
(if (iszero (c as Bool)) then (if ({ * (A -> B) , unit } as Float) then (\ D . "apple") else (let e = (if c then 0 else c) in 2)) else (\ c : ({ Some C , String }) . (succ "boy")))
(\ a : (All E . ((All E . Unit) -> ({ a : B , e : String }))) . (succ (succ (true b))))
(\ B . (let e = ((let b = false in c) as (({ d : C , d : Unit }) -> ({ Some D , C }))) in (let { E , c } = ((2 c) [ ({ Some C , Unit }) ]) in (if 1 then unit else b))))
(let { A , c } = ((let b = (let d = c in 2) in (\ d : String . a)) as ({ Some A , (Float -> C) })) in ((({ c = 0 , b = c }) . d) [ ({ Some A , ({ Some A , String }) }) ]))
(\ b : ({ Some C , ({ Some C , Unit }) }) . (fix (pred ({ * C , 2 } as Nat))))
(succ (let e = (let { A , c } = a in 2) in (let e = unit in b)))
(\ c : ({ d : ({ Some C , ({ e : Bool , d : Bool }) }) , a : (All E . (All A . Unit)) }) . (pred (\ A . (let { B , b } = false in "apple"))))
(\ e : ({ Some A , (C -> ({ Some A , B })) }) . (succ (pred "apple")))
((fix ({ c = (succ "apple") , d = ({ d = a , d = c }) })) . e)
((pred (iszero "apple")) as (All E . (All B . B)))
((succ (true . a)) . c)
({ * ({ Some A , ({ b : Nat , d : Bool }) }) , ({ * (All E . B) , (let c = false in 1) } as (All C . String)) } as ((String -> (All B . String)) -> (String -> Unit)))
(({ * (({ d : Nat , b : A }) -> String) , (fix ({ a = true , e = b })) } as ({ Some C , (All C . C) })) as (All D . (All B . (Float -> Bool))))
(fix (let { B , c } = ({ d = true , e = ({ * Nat , "boy" } as A) }) in ((\ d : Unit . 2) (c as B))))
({ * ({ Some E , (({ e : Nat , b : Unit }) -> ({ e : (All E . B) , d : ({ Some E , String }) })) }) , (\ E . (c [ B ])) } as (All E . ({ e : (B -> String) , a : (Float -> B) })))
(({ * ({ Some B , (Float -> C) }) , ((1 c) (succ a)) } as (All B . ({ e : String , e : B }))) as ({ Some B , ({ a : String , a : B }) }))
(succ ({ * ({ Some B , (({ c : A , b : Unit }) -> (String -> Nat)) }) , (pred c) } as ((All C . A) -> ({ Some B , Bool }))))
(succ (if (let a = true in 1) then (if (succ false) then "apple" else (true . c)) else (let { C , e } = c in 1)))
(\ E . ((true . a) as (Unit -> B)))
(let a = (\ A . ({ d = ({ c = 0 , a = 2 }) , d = unit })) in (\ b : (All D . ({ Some A , Nat })) . ("boy" as (All B . Float))))
(\ d : (({ b : Nat , e : Unit }) -> ({ Some B , Bool })) . ((pred c) [ ({ d : C , d : B }) ]))
(({ a = (succ false) , d = (fix 1) }) as (All E . ({ e : Bool , d : Float })))
(iszero ({ * (All C . B) , (if (pred unit) then (iszero 2) else (c [ Float ])) } as (All B . Bool)))
((let { D , c } = (unit [ Nat ]) in ({ e = b , b = (1 as Float) })) as ({ Some B , ({ e : B , a : ({ d : Nat , e : A }) }) }))
(\ C . (fix (if (fix b) then "apple" else (let b = unit in true))))
(succ (\ A . ((if "apple" then false else 1) . b)))
((\ b : (B -> B) . (2 as (All E . A))) . e)
(if (let { D , c } = (fix b) in ((fix true) "apple")) then ((iszero (succ true)) (c . e)) else (let a = (fix b) in ({ * ({ Some B , Nat }) , ("apple" . a) } as ({ Some D , A }))))
(iszero ({ c = (\ B . unit) , e = (\ B . ((let { B , e } = 0 in unit) [ (A -> Float) ])) }))
(let { D , c } = (\ c : ((All B . A) -> ({ Some A , Unit })) . (succ c)) in ((pred (\ E . "boy")) . c))
(let b = (\ D . (pred 2)) in (succ (let e = b in 2)))
(if ((iszero (\ d : C . "apple")) [ ((B -> B) -> ({ Some C , Bool })) ]) then ({ * ({ Some D , ({ Some A , C }) }) , (a as (All E . B)) } as ((String -> Float) -> ({ c : Unit , e : Bool }))) else (\ D . (let { C , b } = c in a)))
(let { A , d } = ((succ (\ D . false)) . d) in ((0 [ ({ a : Bool , c : B }) ]) as ({ b : Unit , c : Unit })))
(\ c : ((All B . Float) -> ({ a : ({ Some A , String }) , d : Float })) . (let b = (succ (iszero true)) in (("apple" as Unit) as (String -> Bool))))
((\ E . (\ E . (if false then 0 else unit))) . d)
(if (let { E , b } = ({ * Float , (let { D , c } = true in 0) } as C) in ({ e = (iszero (\ b : Unit . c)) , e = (c as A) })) then (let { E , c } = (let { A , e } = (unit (\ B . "apple")) in (iszero false)) in (pred ((succ "apple") as String))) else (({ * ({ e : C , b : Unit }) , (0 1) } as ({ Some E , C })) [ ((Nat -> A) -> (B -> C)) ]))
(let b = (fix (if (fix a) then (fix true) else a)) in (let { A , e } = (if "boy" then unit else a) in (true [ ({ a : Float , d : Bool }) ])))
((fix (pred ({ * Bool , unit } as A))) as ({ c : (All D . (All D . (All D . C))) , e : (Unit -> ({ Some D , B })) }))
(let { B , e } = (let d = (if ({ * Float , a } as String) then "boy" else (\ C . true)) in (let { D , e } = ({ * B , 2 } as A) in ({ * Bool , b } as Unit))) in ((\ E . false) [ ((All C . A) -> C) ]))
({ b = (iszero ((if 0 then false else unit) . b)) , d = (iszero (let { E , e } = (pred "boy") in (succ c))) })
((let { E , b } = (succ b) in (a "boy")) (pred ({ * ({ a : B , b : Bool }) , (\ A . 2) } as ({ a : Float , e : Unit }))))
(\ D . (let e = (unit . a) in (pred a)))
(\ E . ({ d = ({ b = (\ e : A . b) , c = false }) , e = (1 . d) }))
({ a = (succ (\ e : Float . c)) , d = (let { E , e } = (succ (\ b : String . false)) in (let { E , b } = a in (fix "apple"))) })
(if (let { A , a } = (if (1 as Float) then (\ A . true) else (true as A)) in (iszero (if "apple" then false else false))) then (fix (pred 2)) else (\ a : ({ c : (All B . Bool) , d : ({ d : Float , e : C }) }) . (true . b)))
((if (\ a : (({ c : Float , b : Unit }) -> (All E . Nat)) . (let { D , a } = 2 in "boy")) then (iszero (let d = 2 in true)) else (let b = a in (pred true))) [ (({ Some C , String }) -> ({ Some E , (Float -> B) })) ])
(succ (pred ({ d = (let b = "apple" in c) , d = "apple" })))
(fix (({ * ({ b : B , a : Unit }) , (\ a : String . b) } as A) as ({ c : C , d : Bool })))
(if ((pred true) as (All A . Nat)) then (let e = ({ * (All B . A) , (iszero true) } as (All B . Unit)) in (a as C)) else ((iszero (unit "apple")) as (All C . A)))
(let d = (((2 as C) [ (Float -> String) ]) . c) in ({ * (({ b : C , a : Float }) -> (All A . Float)) , (unit . d) } as (All B . Unit)))
((({ b = (if c then false else true) , a = 1 }) [ (({ Some A , B }) -> (({ a : String , a : String }) -> C)) ]) . e)
((if ({ b = c , a = false }) then (\ A . c) else (pred true)) as (All E . ({ Some E , ({ c : Bool , e : Float }) })))
(iszero (fix ({ d = a , a = a })))
({ d = (iszero ((unit . d) [ ({ Some A , C }) ])) , b = (succ (fix false)) })
((let b = (succ (\ B . "boy")) in (iszero 0)) as (All A . ({ c : (All B . A) , c : ({ b : A , a : Unit }) })))
(pred ((succ (succ a)) ({ d = false , d = 0 })))
((let d = (c [ String ]) in (pred 0)) as ({ a : ({ a : C , c : String }) , d : ({ b : A , a : A }) }))
(\ D . (iszero (\ C . (fix "apple"))))
(\ c : ({ Some C , ({ b : Unit , e : C }) }) . (succ (iszero a)))
((fix (pred unit)) (({ * ({ b : B , d : B }) , (iszero (succ unit)) } as ({ Some D , String })) as ({ Some E , ((All D . C) -> Float) })))
(if ((unit [ C ]) (let c = true in (false as C))) then (if (let { B , c } = true in true) then (succ 0) else (fix (let b = true in 0))) else (pred ({ e = (2 [ Float ]) , c = (c as (All A . Bool)) })))
(fix ({ * ({ a : Float , a : B }) , (pred b) } as (All A . ({ d : Nat , d : B }))))
(let { E , c } = (iszero ((\ b : String . "boy") 0)) in (({ c = 2 , c = c }) as ({ Some D , (A -> Bool) })))
(iszero (if (a [ Bool ]) then (let e = 1 in c) else (if 1 then false else 0)))
(iszero (if (\ d : ({ c : Unit , e : Nat }) . ((if a then b else "apple") [ Float ])) then ({ b = (\ C . unit) , e = b }) else (\ a : A . true)))
(succ (\ a : ({ c : (All D . Unit) , b : ({ Some B , String }) }) . ({ * B , 1 } as Float)))
((\ b : (All A . (All C . String)) . (\ c : ({ Some E , C }) . 0)) as ({ Some B , (All D . Unit) }))
(((\ a : (All A . B) . c) as ({ c : Unit , d : C })) as ((All B . (All D . B)) -> ((String -> Float) -> ({ c : Nat , b : Nat }))))
(succ ((if (let { D , d } = "boy" in unit) then a else (0 [ C ])) (succ 0)))
((fix (pred 0)) . b)
({ * (({ Some B , Unit }) -> (All D . (All B . Unit))) , ((\ e : A . "boy") as ((String -> String) -> (All A . C))) } as (((All D . Unit) -> ({ Some E , ({ Some A , C }) })) -> (All E . ({ Some B , Nat }))))
(if (let { D , e } = (fix "apple") in ({ c = c , c = 2 })) then (pred (let { E , d } = (if false then unit else "boy") in (if false then "apple" else c))) else (({ * (All D . Bool) , (b . b) } as (All E . String)) [ ((Nat -> B) -> Bool) ]))
(pred ((pred (a . b)) . a))
(\ b : ({ Some A , (All A . ({ Some A , Float })) }) . (\ a : ({ Some C , String }) . ({ a = (succ 1) , c = false })))
(let e = (((a . d) as (All B . String)) . d) in (let { B , c } = (iszero (0 2)) in (let b = (unit as String) in (fix unit))))
(if ((\ b : ({ d : String , d : Nat }) . "apple") . e) then ((false [ C ]) . b) else (\ D . (fix (0 [ (Bool -> Unit) ]))))
(pred ((if (\ e : A . 0) then (unit . c) else (0 . b)) as (A -> String)))
((({ e = a , e = "boy" }) (false [ Unit ])) (\ A . ((\ b : C . 0) as ({ d : B , c : Float }))))
((iszero (let e = 1 in a)) [ ({ Some A , ({ Some B , (All E . A) }) }) ])
(((iszero ((pred b) as ({ Some B , Unit }))) (pred ({ e = (succ b) , b = ({ c = 2 , e = unit }) }))) . c)
((let b = (false 2) in (\ c : Unit . unit)) as (({ Some D , ({ e : Unit , b : String }) }) -> (All B . String)))
((iszero (({ d = unit , c = "apple" }) [ (B -> B) ])) . a)
(((\ A . a) as ({ Some D , (All C . String) })) . a)
(\ C . (let b = (fix a) in (pred (false as C))))
(if (succ (({ b = (succ "apple") , c = b }) as ({ Some E , Bool }))) then (("boy" as Bool) [ ({ Some B , Float }) ]) else ((iszero unit) . b))
(((\ d : ({ Some D , Nat }) . b) ((\ c : B . 1) [ C ])) as ({ Some C , ({ c : ({ Some B , C }) , c : ({ e : C , c : Unit }) }) }))
((\ b : ({ Some E , A }) . ((iszero b) . e)) ({ * ({ Some B , String }) , ({ * Float , false } as C) } as (Unit -> (All B . B))))
(pred (succ (iszero 1)))
(fix (succ (1 . e)))
(iszero ({ * ({ Some B , (All A . Float) }) , ({ * (Nat -> C) , (\ D . a) } as ({ Some A , Bool })) } as (All C . Bool)))
({ d = ((succ 0) [ (All A . Bool) ]) , e = (if (succ unit) then (\ E . ("apple" 2)) else ((\ D . true) (\ d : Float . unit))) })
({ * (All E . ({ e : B , a : Unit })) , (\ A . (\ d : String . 2)) } as ((B -> (All C . Nat)) -> (C -> A)))
(\ a : (All B . (All C . String)) . ({ c = (a as (Unit -> B)) , a = (iszero a) }))
((let b = ((1 2) . b) in ((fix a) . c)) . e)
({ * (All D . ({ Some B , Float })) , ((\ c : (All C . C) . (c c)) as ({ d : ({ Some D , Nat }) , e : B })) } as ({ b : ({ c : ({ Some B , B }) , d : (All E . Unit) }) , a : ({ Some C , ({ Some C , B }) }) }))
(succ ((pred 2) as (All E . B)))
(succ ((c (0 . c)) as ({ a : Bool , d : C })))
({ e = (let { A , d } = (a as A) in (if 0 then a else "apple")) , a = (iszero (let { D , d } = c in false)) })
(if ((pred true) . a) then (succ (fix true)) else (fix (pred ({ d = (fix "apple") , e = (fix b) }))))
(((false . e) . b) . c)
(\ d : ((All B . C) -> (All C . B)) . ((let { B , a } = (succ a) in 0) [ ({ a : ({ Some C , Bool }) , d : ({ d : Float , d : String }) }) ]))
({ d = (succ (let { D , b } = "apple" in unit)) , d = ({ * (All C . Float) , (\ b : ({ d : Float , e : B }) . ((let e = 2 in 1) (\ b : Nat . b))) } as (({ Some D , A }) -> ({ a : String , b : Float }))) })
(succ ((\ e : ({ d : C , e : Float }) . b) . b))
((let b = (b . a) in ({ * String , (\ B . false) } as (All A . Float))) as (All B . (Nat -> Unit)))
((iszero (let e = b in "apple")) as (All B . ({ d : ({ Some A , B }) , e : C })))
({ a = ({ * (All E . ({ d : (Bool -> Float) , c : (String -> Unit) })) , (let { D , b } = (b . c) in (\ B . b)) } as ({ a : ({ d : Bool , c : String }) , b : (All D . ({ Some C , B })) })) , e = ((iszero 1) [ ({ b : Float , d : B }) ]) })
(if (\ E . (let { E , d } = (succ 0) in (pred 0))) then (\ A . (({ a = false , a = (\ d : B . c) }) as ({ Some C , Float }))) else ((\ d : B . false) . b))
(pred ((iszero 1) as ({ e : Unit , c : Float })))
(iszero (succ ((let { B , c } = 1 in 1) as ({ Some A , B }))))
(iszero (pred (succ a)))
(pred (iszero ({ d = "apple" , c = 0 })))
(succ (({ * String , (iszero "boy") } as ({ a : Unit , c : String })) (pred "apple")))
(let d = (({ * A , a } as Bool) ({ * Float , c } as Nat)) in (\ B . (let { C , c } = b in c)))
((if (fix (iszero (let { E , b } = a in c))) then (let e = unit in (if 1 then "boy" else "apple")) else ("boy" as Unit)) (\ D . (\ A . (unit . c))))
((let a = (fix 2) in (\ E . (pred false))) as ((({ a : C , b : ({ Some C , Unit }) }) -> (Unit -> (All B . Bool))) -> ({ Some D , Unit })))
(\ D . ((true . e) as (String -> Float)))
((succ ((let { B , b } = "boy" in c) . d)) [ (All D . ({ d : ((All D . Bool) -> (A -> Unit)) , a : (All D . (Unit -> String)) })) ])
(((\ D . "boy") (unit as ({ Some B , C }))) as ({ Some C , (Float -> Nat) }))
(if (iszero (fix ({ d = (c as C) , b = (let e = "apple" in "apple") }))) then (\ D . (fix 2)) else ((let { C , d } = (succ 0) in (fix false)) (2 unit)))
(let { E , d } = (\ D . (fix (let e = a in b))) in (if (fix 0) then (fix (if 2 then true else 0)) else (let d = (\ A . "apple") in (pred false))))
(succ (iszero (\ e : (String -> String) . (let { A , e } = "apple" in "boy"))))
(\ E . (iszero (let { C , c } = (succ 1) in unit)))
(pred (succ (iszero ({ c = a , a = 1 }))))
(fix (\ b : (Unit -> A) . (c [ B ])))
(((succ 1) ({ * (All B . Bool) , 1 } as C)) [ (({ e : B , e : (All E . Nat) }) -> ({ b : (All A . B) , b : String })) ])
(\ C . (succ ({ * ({ Some B , Bool }) , ({ * Nat , false } as Bool) } as (Float -> A))))
((\ c : ({ Some A , (Unit -> Unit) }) . (2 [ Float ])) as (All D . (({ c : Float , d : Unit }) -> ({ Some C , ({ d : Float , b : C }) }))))
(\ a : ({ Some E , (({ b : Unit , a : B }) -> Unit) }) . ({ * (All A . (All E . B)) , (true as Float) } as ((A -> A) -> A)))
({ c = (\ A . (succ ({ * Float , "boy" } as Nat))) , c = (let b = (let { E , b } = (true as Nat) in "apple") in (if (let { A , e } = c in c) then (2 as String) else (pred c))) })
(let d = (succ (pred (\ D . 2))) in ((iszero 0) [ (((Unit -> Float) -> (All E . B)) -> (All D . Bool)) ]))
(\ A . (iszero (b as C)))
(pred (if (\ B . true) then (let { D , b } = c in 0) else ({ e = "boy" , c = false })))
(((let { D , e } = a in 0) . d) [ ({ Some C , (Bool -> Unit) }) ])
(({ e = (pred true) , d = (\ B . (if unit then 2 else "boy")) }) . b)
({ d = (((({ * Unit , 2 } as Nat) . b) as (A -> A)) . a) , d = (let e = (let { B , e } = true in 2) in (iszero b)) })
({ d = (let a = (pred (let { B , d } = (succ 2) in (if "boy" then true else unit))) in (\ A . (succ (fix "boy")))) , c = (let a = (let { E , b } = 1 in unit) in (\ C . "apple")) })
(((let { E , a } = (\ C . "boy") in b) as (Nat -> String)) as ({ e : ({ c : ({ e : A , c : A }) , b : A }) , c : ({ d : String , a : ({ Some B , C }) }) }))
(fix (iszero (fix b)))
(\ E . (let b = (\ e : C . unit) in (let a = c in ({ c = 0 , a = false }))))
(\ d : ({ a : (All A . (All B . Bool)) , a : (All B . String) }) . ({ * (All B . Unit) , ((let { E , b } = true in 0) as String) } as (Unit -> A)))
(\ C . ((pred (a false)) [ ({ Some A , ({ b : Bool , e : C }) }) ]))
(fix (\ c : ({ Some D , Nat }) . ({ a = b , c = 1 })))
(succ (((fix false) as ({ Some B , Float })) [ (({ Some B , A }) -> (All D . Nat)) ]))
((\ B . (if c then b else 1)) as ({ Some C , (({ c : Bool , c : Unit }) -> ({ Some E , A })) }))
((\ A . ((pred (let b = true in "apple")) [ (({ a : Unit , e : C }) -> ({ d : Bool , e : Nat })) ])) . b)
(((succ (\ e : C . (let e = false in 2))) as ({ Some D , ({ a : Bool , c : Nat }) })) (\ d : (Float -> (Unit -> Float)) . (b [ String ])))
(let { C , d } = (\ e : ({ Some B , Nat }) . (if (\ a : Float . false) then (iszero (if false then true else c)) else (b [ ({ c : A , c : String }) ]))) in (succ (pred (true unit))))
((let e = ((2 as Float) . e) in ((if (b . b) then ("apple" [ A ]) else 0) as (B -> A))) as ({ Some E , (All C . C) }))
(\ B . ((iszero (iszero a)) ({ * ({ e : Float , d : Unit }) , (true as Bool) } as (Float -> B))))
(fix ((if "boy" then a else (if false then c else b)) . e))
({ * (All B . (All A . Float)) , (\ c : ({ b : (All A . Nat) , e : ({ Some B , (Nat -> A) }) }) . (let d = (iszero "boy") in (fix "apple"))) } as ((All C . B) -> ({ c : C , c : A })))
(let c = (\ E . ((fix "apple") [ Float ])) in ({ b = (let { E , d } = (1 "apple") in a) , a = (fix unit) }))
(let { A , b } = (succ (if unit then 0 else unit)) in ({ b = ({ b = c , e = 0 }) , d = (let { B , d } = (\ B . unit) in true) }))
(if (\ E . (iszero (fix 2))) then ({ e = (\ E . 2) , c = (let b = (pred 2) in (if 2 then c else 1)) }) else (if (let d = (false as ({ Some A , C })) in (if false then 2 else "apple")) then (if b then true else c) else ((succ 0) ("boy" as B))))
((pred ({ a = (iszero "boy") , b = c })) (iszero (({ e = unit , b = true }) [ (All D . String) ])))
(\ c : (All A . (A -> Float)) . (let { A , a } = (let { E , d } = (false . e) in 2) in ({ d = (let { C , c } = "apple" in c) , d = a })))
((fix (fix 0)) [ ((Nat -> (All C . Bool)) -> ({ a : ({ d : Unit , c : Nat }) , e : ({ Some A , Nat }) })) ])
(pred (\ B . (fix true)))
((pred (if b then 1 else 1)) (iszero (let { E , a } = (succ (\ E . unit)) in (succ 1))))
(succ (fix ({ c = (if "apple" then b else 0) , e = 1 })))
(\ B . (let { E , b } = (fix true) in ({ * C , 1 } as Bool)))
(\ b : (All D . ({ Some C , C })) . (iszero ({ * Unit , 2 } as Unit)))
({ a = (\ E . (0 . d)) , b = (let c = (succ (\ B . (let a = false in 1))) in ({ d = 1 , c = (c . e) })) })
(let d = (let a = ((\ d : B . "boy") as Unit) in ((\ B . c) . c)) in ({ * (All C . String) , (\ D . (succ c)) } as ({ Some C , (All D . C) })))
((\ C . (if 1 then a else "apple")) [ ({ c : (All C . ({ b : Unit , e : String })) , a : (All D . (All D . B)) }) ])
((\ d : ({ a : Bool , c : C }) . (if (let { E , b } = c in false) then (\ C . "apple") else (if (\ c : C . "boy") then ({ e = c , a = false }) else (\ E . true)))) . b)
(iszero (\ d : ({ Some B , B }) . (unit "apple")))
(let c = (("apple" . c) as ({ a : A , a : ({ e : Unit , a : Float }) })) in (let a = (1 [ Float ]) in (pred (succ 0))))
(fix ((let d = 0 in (\ E . 1)) as ({ Some A , ({ d : Unit , c : C }) })))
(fix ((let { C , b } = c in unit) as ((Float -> B) -> String)))
(succ (\ C . (0 . a)))
(iszero (iszero (iszero (let { A , e } = a in 1))))
(succ (fix (let c = ("apple" . d) in (\ A . 2))))
((let c = ({ * Bool , "boy" } as Bool) in (("boy" . a) . a)) (fix ({ * Bool , unit } as Nat)))
(iszero ((\ B . ({ d = (2 false) , c = b })) . d))
(let a = (fix (\ E . 0)) in (iszero (iszero c)))
(succ (({ * Float , false } as Float) as ({ d : Bool , e : A })))
(pred (\ a : ({ c : ({ e : ({ Some C , A }) , c : Unit }) , b : (All A . Bool) }) . ((\ C . unit) . b)))
(let { D , a } = ({ * ({ e : ({ Some E , Nat }) , a : C }) , (\ C . 1) } as (All A . ({ d : Nat , d : String }))) in (let { C , a } = (fix "apple") in (fix ({ b = false , b = b }))))
({ * ({ Some E , ({ b : Float , a : A }) }) , (\ B . (let b = ("boy" [ Unit ]) in (c as Float))) } as (({ d : (C -> (All E . Unit)) , c : (All C . C) }) -> ({ d : ({ Some D , A }) , b : Float })))
((((\ c : Bool . "apple") [ A ]) [ ({ d : ({ e : Bool , b : Unit }) , b : (Unit -> ({ Some B , Bool })) }) ]) [ ({ b : (All C . (B -> ({ e : Float , a : A }))) , c : ({ d : C , c : ({ Some B , Nat }) }) }) ])
(({ * ({ a : (Unit -> A) , d : ({ Some B , A }) }) , (iszero (pred true)) } as (A -> ({ e : Nat , d : B }))) . b)
(if (pred (fix ({ a = 0 , d = true }))) then (succ ({ a = unit , b = (let { D , b } = 0 in true) })) else ((if (succ (1 . a)) then ({ * Nat , 1 } as B) else (\ c : A . a)) [ (All D . (All B . Bool)) ]))
((\ c : (Float -> (All A . Float)) . ((let b = 2 in "apple") . a)) . b)
(\ b : ({ e : (A -> A) , c : ({ Some A , B }) }) . (\ A . (iszero (iszero "boy"))))
((fix ({ d = (if a then true else 2) , a = ({ c = c , e = c }) })) . e)
(fix (iszero (a [ A ])))
(succ ({ a = ({ * (All C . String) , (true 0) } as (All B . B)) , d = (unit . e) }))
((((pred a) [ ({ d : ({ Some B , Nat }) , d : ({ d : Nat , b : Bool }) }) ]) as (All D . ({ a : Nat , d : Unit }))) [ ({ Some E , ({ a : (B -> A) , e : A }) }) ])
({ e = (let { E , a } = (0 as Float) in (iszero "apple")) , c = (if (\ b : (All B . (Unit -> C)) . (let { E , e } = (let c = "apple" in 2) in false)) then (if ({ * B , unit } as A) then true else 2) else (pred a)) })
({ c = (let { A , d } = ({ * ({ b : ({ Some A , Unit }) , b : ({ d : Float , c : Nat }) }) , (iszero true) } as ({ c : (Nat -> Unit) , d : Unit })) in ((c . e) as (All C . ({ e : Nat , a : A })))) , e = (let a = (a b) in (\ B . "boy")) })
(fix ((fix (pred (pred "boy"))) as ({ Some D , ({ b : Bool , a : Bool }) })))
(((if (c [ B ]) then 2 else ({ c = true , b = b })) [ ({ e : String , a : C }) ]) [ ({ a : ({ d : Float , d : String }) , e : ({ a : Unit , b : A }) }) ])
(iszero (let b = (let e = b in (succ 0)) in ({ * Nat , (succ a) } as C)))
(\ D . (fix ({ c = (\ a : Nat . a) , e = (false . a) })))
(let c = ((iszero c) as ({ Some D , String })) in ({ d = (let { D , b } = 2 in ({ e = unit , e = true })) , e = (iszero 2) }))
(if ({ d = (fix unit) , e = ({ * (All D . String) , (\ D . "boy") } as ({ Some A , Unit })) }) then (iszero (pred b)) else (let { D , c } = (pred (2 as Bool)) in (if (let { C , b } = (a [ B ]) in ("apple" as B)) then (fix (let b = true in "apple")) else (succ false))))
((pred (\ b : (All D . B) . (let { B , c } = "apple" in "apple"))) . c)
(iszero ({ d = (true . e) , d = (2 b) }))
(((let { A , e } = false in "boy") [ (All A . A) ]) [ (All D . ({ Some D , ({ b : Unit , c : C }) })) ])
((let { A , c } = ((if (fix unit) then (if c then b else "boy") else (\ C . b)) as (B -> A)) in (\ A . ({ a = 2 , b = b }))) [ ((All A . ({ Some B , Bool })) -> ((All D . C) -> ({ c : String , e : C }))) ])
(let b = (succ (iszero ("boy" b))) in (iszero ({ e = (succ b) , c = ({ d = 0 , a = "apple" }) })))
(let e = ((\ B . "boy") . a) in (\ a : ({ Some B , (String -> Bool) }) . (unit unit)))
(\ b : ((All C . ({ Some C , Float })) -> (All E . A)) . (pred (let { C , a } = 0 in (pred "apple"))))
(let { C , b } = (succ ({ * ({ Some A , C }) , (iszero "apple") } as (All E . Nat))) in (({ e = (fix true) , b = 0 }) [ ({ a : ({ Some E , C }) , d : ({ e : Nat , a : Unit }) }) ]))
(({ a = (("boy" 2) as (Nat -> Unit)) , d = ({ * C , "apple" } as String) }) (let e = (succ 1) in (iszero a)))
(({ b = (succ 2) , a = (iszero b) }) [ (All A . (All C . (Float -> (All A . Float)))) ])
(fix (let { C , d } = (({ * Float , unit } as Float) a) in (iszero (let { B , d } = 2 in b))))
(if (iszero (\ A . (let b = a in 1))) then ({ a = (true [ String ]) , d = ("boy" . c) }) else ((\ E . (2 c)) [ ({ Some D , (Nat -> C) }) ]))
(pred ((\ b : (All E . Bool) . 0) (\ e : ({ c : Bool , b : Float }) . (iszero c))))
(\ A . (succ (fix ({ a = unit , c = c }))))
(\ a : ({ Some C , (All B . (All D . Nat)) }) . (pred (let { D , c } = "apple" in b)))
(succ (pred (({ * (All E . C) , false } as (All B . B)) [ ({ e : B , b : ({ Some C , Float }) }) ])))
({ * (All D . (Bool -> B)) , ({ d = (succ "boy") , e = ((\ d : ({ c : C , c : Unit }) . (let a = "apple" in "boy")) [ ({ d : B , b : String }) ]) }) } as (({ Some D , Float }) -> (Unit -> String)))
(((if (if unit then "boy" else "boy") then (\ c : C . b) else true) as (Nat -> A)) . d)
(\ C . (succ (iszero unit)))
((let b = (if (fix b) then true else (0 . e)) in (let { D , d } = 0 in (succ false))) . b)
(let c = ({ * ({ Some B , Float }) , (let { A , c } = ({ * Float , a } as Nat) in (fix false)) } as ({ a : Bool , a : C })) in (if (if ({ * Unit , 0 } as A) then (if 0 then true else 2) else (pred b)) then (if (\ A . a) then (\ e : Float . c) else (pred (\ a : Unit . 2))) else (\ E . c)))
({ * (All D . (All A . ({ e : Float , c : C }))) , ((iszero ("apple" . d)) . a) } as ((Unit -> ({ a : C , e : Bool })) -> ({ Some D , (All D . Unit) })))
(if (iszero ((b as ({ b : B , d : B })) ((b "apple") 1))) then ((\ a : String . unit) . d) else (({ c = (let c = (iszero 1) in false) , a = (succ (let { E , d } = a in unit)) }) as (All B . ({ Some B , String }))))
(let { E , d } = (if (let d = 1 in "boy") then (({ * Unit , true } as B) . b) else (false . d)) in ({ * (Nat -> String) , (let e = false in a) } as (({ Some C , Bool }) -> ({ d : B , e : Nat }))))
(pred ((\ a : ((All A . Nat) -> Unit) . (b "apple")) as (All B . (A -> Nat))))
(pred (\ C . (pred (let { A , c } = (false as C) in c))))
(\ d : (({ d : A , b : Unit }) -> (String -> C)) . (pred ((iszero "apple") b)))
(let d = (fix ({ * Bool , (\ C . a) } as String)) in (succ ((1 as String) (iszero 2))))
(if (\ a : (All A . Float) . ((if b then a else "apple") as Nat)) then (iszero (if true then 1 else (2 "boy"))) else (pred (fix (pred "apple"))))
(let { A , c } = ((fix (iszero "apple")) . e) in ((pred ({ * B , c } as Float)) . e))
(\ b : ((All C . (All A . ({ Some B , C }))) -> ({ c : ({ e : C , c : B }) , e : (All D . String) })) . (succ (\ e : ({ Some B , B }) . ((let { C , d } = "apple" in b) . a))))
(((0 as Nat) (\ d : (All B . B) . (let { E , b } = b in a))) . d)
(succ ({ a = (unit [ Bool ]) , b = (a . e) }))
((fix ({ * String , b } as Float)) [ (((Bool -> Float) -> Unit) -> ({ c : Float , e : A })) ])
(pred ((false b) . e))
((succ (iszero true)) (fix (\ e : (All C . Unit) . a)))
(let { A , c } = (\ A . (fix (succ 2))) in (\ D . (if 1 then a else a)))
({ a = (iszero (if c then b else 1)) , a = (let e = (b [ Nat ]) in (fix a)) })
((fix ((succ c) 1)) as (({ Some D , (All D . (Nat -> C)) }) -> (String -> A)))
(pred (iszero (\ E . (let { E , a } = 2 in 1))))
(let d = ((iszero false) (succ false)) in (\ a : ({ Some C , (String -> Bool) }) . (fix 2)))
((fix (let c = (\ d : A . b) in b)) (let d = ("boy" [ B ]) in (fix a)))
(let { A , a } = (iszero (c . a)) in (pred ("boy" [ Unit ])))
(\ e : (({ c : Bool , d : (Float -> Float) }) -> (All C . C)) . (succ (pred c)))
(\ B . (if ((succ "boy") [ (All E . String) ]) then (fix (let a = true in a)) else (let e = "apple" in (let b = c in 2))))
(if (iszero ((false [ Unit ]) [ (C -> Float) ])) then (pred (\ a : B . (unit as C))) else (let { D , d } = (succ c) in (unit [ String ])))
(succ (let d = (let b = "boy" in ("apple" . c)) in ({ * (Unit -> C) , (succ b) } as ({ d : (Float -> B) , e : ({ Some B , Nat }) }))))
(fix (\ a : (All A . Bool) . (let d = b in true)))
({ d = ((true . b) as ({ Some A , (All E . Nat) })) , c = (succ (unit 2)) })
(fix (({ c = (fix (let d = 0 in false)) , c = (fix (0 [ A ])) }) [ (All E . ({ Some D , ({ d : Float , d : A }) })) ]))
(fix ({ c = (fix a) , b = (succ (\ e : (All E . Bool) . (let { C , e } = 2 in b))) }))
((if (\ B . true) then (succ 1) else ({ b = (\ E . "boy") , e = (b [ Nat ]) })) [ ({ b : ({ b : Unit , d : Bool }) , b : (All D . (Unit -> Unit)) }) ])
(\ D . ({ d = (\ e : ({ Some C , Float }) . (0 [ Unit ])) , e = (\ A . (\ C . c)) }))
(((fix false) (let { B , a } = (succ a) in (if 0 then b else "boy"))) as (({ Some E , C }) -> ({ b : ({ Some C , C }) , d : B })))
({ * ((All E . Nat) -> ({ c : A , b : B })) , ({ * (All B . A) , (succ 2) } as (All E . (Float -> A))) } as ((C -> B) -> ({ b : C , e : String })))
(succ (succ ((pred 0) (c as Bool))))
(({ a = ({ * ({ c : C , c : C }) , (fix 2) } as (All B . A)) , d = (\ d : A . 0) }) ({ d = (fix unit) , c = (iszero (if ({ * String , a } as C) then (false . d) else (iszero b))) }))
((let b = (2 . b) in (iszero true)) as (All A . ({ e : (All C . C) , e : (A -> Unit) })))
(pred (\ a : (All E . B) . (succ b)))
({ * ({ Some C , (All D . ({ c : C , b : A })) }) , (if (\ A . true) then (if unit then unit else a) else (\ d : A . "boy")) } as ({ Some B , (All E . (All D . B)) }))
((\ E . ({ c = (fix false) , e = ({ * B , true } as Float) })) [ (All C . ({ c : Nat , d : C })) ])
((let d = (\ A . (succ 1)) in (\ C . c)) ((a (succ b)) as (Nat -> Nat)))
((succ (({ d = unit , b = (if a then a else c) }) [ (All D . Bool) ])) (succ (true unit)))
(pred (\ E . (iszero ({ * A , b } as C))))
(succ (pred (iszero ({ * B , c } as Unit))))
(let b = (\ E . (succ ({ c = true , c = "apple" }))) in (succ (2 [ C ])))
(\ b : ((All D . Bool) -> (Bool -> Nat)) . ((\ c : String . 2) (let a = "apple" in false)))
({ * ({ e : ((All D . String) -> ({ c : Nat , b : Float })) , d : (All B . Bool) }) , (let c = (let c = ("apple" a) in (1 [ String ])) in (let a = ({ * Float , 2 } as String) in ({ * Bool , "boy" } as A))) } as ({ b : (All A . (All C . ({ Some B , A }))) , e : ({ b : Float , e : C }) }))
(if (pred (2 true)) then (iszero ({ * A , 1 } as Unit)) else ((pred (true unit)) as (All D . ({ e : B , a : (All E . C) }))))
({ e = (succ (if b then (0 as C) else (b c))) , b = ((if 1 then 2 else 0) . a) })
(let { C , c } = (\ e : ({ b : Nat , c : Nat }) . (succ true)) in (fix (unit . c)))
(pred (if ({ e = true , b = false }) then (\ B . "boy") else (fix a)))
({ * ({ Some E , ({ d : (Bool -> Float) , d : (All A . A) }) }) , (pred ((true . c) [ ({ Some E , String }) ])) } as ({ Some D , ({ a : ({ Some C , C }) , d : ({ c : String , e : C }) }) }))
(pred ((iszero c) (\ B . true)))
({ * ({ e : ({ Some A , (All D . A) }) , b : (All C . A) }) , (let d = (2 as Bool) in (true false)) } as (All E . ({ Some E , Nat })))
((({ * (Nat -> Unit) , (\ D . "boy") } as (Nat -> A)) . a) [ ({ Some B , ((All E . (All E . Nat)) -> ({ d : A , d : (C -> A) })) }) ])
(fix (({ * ({ Some D , Bool }) , (iszero "apple") } as B) (pred true)))
(((fix true) as ({ Some A , Nat })) [ ({ Some E , (Float -> Float) }) ])
({ a = (succ (pred "boy")) , e = (let b = (let { C , d } = (fix ({ a = "apple" , d = 1 })) in (pred (iszero true))) in (let d = (b . d) in (\ a : B . (iszero false)))) })
((let e = (let { E , e } = c in (if b then 2 else false)) in (((succ true) [ A ]) as (All D . C))) [ (({ Some A , B }) -> ({ c : Float , c : A })) ])
(let { E , c } = (({ * Float , 1 } as Bool) [ (All D . (All B . A)) ]) in ({ e = (\ d : Float . b) , b = (succ (let a = 0 in unit)) }))
(((fix 0) . d) (iszero (1 [ Bool ])))
((pred ({ * ({ Some B , Bool }) , 0 } as (All C . Float))) as ((B -> Float) -> (All E . (All C . Float))))
(if (iszero (\ d : ({ e : B , e : B }) . 0)) then (fix ({ b = "apple" , b = c })) else ({ c = (fix 2) , c = (({ * (All C . Unit) , ({ a = 2 , e = false }) } as ({ Some B , A })) . a) }))
((({ * String , c } as A) [ (C -> (B -> Unit)) ]) as (All A . ({ Some B , (Bool -> C) })))
((let e = (pred 2) in (iszero (0 1))) [ ({ Some C , (All C . Unit) }) ])
((if (succ b) then (iszero (iszero c)) else (let c = (iszero 1) in true)) . c)
(\ A . (((\ C . (iszero 0)) as (All E . Unit)) . e))
({ c = ((unit b) . c) , d = (pred (c as Float)) })
(if (\ D . (\ e : Unit . ({ b = true , b = "boy" }))) then (fix (\ E . "apple")) else ({ a = (iszero (let c = unit in "apple")) , c = (let { D , d } = (if (pred unit) then (fix 2) else 2) in (if "boy" then unit else 0)) }))
(\ b : ({ Some E , (All E . Bool) }) . (fix (fix (\ C . a))))
(\ C . (("apple" [ Nat ]) (pred false)))
(let { B , b } = (\ e : (All E . Unit) . ({ * (C -> A) , ({ c = unit , d = "boy" }) } as ({ a : Unit , b : (All A . B) }))) in (let { C , a } = (pred b) in (\ a : ({ Some C , Unit }) . true)))
({ * (All E . ({ Some A , A })) , ({ c = ({ * B , a } as B) , e = (\ c : C . 0) }) } as (All D . (({ Some A , Nat }) -> (Float -> B))))
(iszero ((let { E , d } = (2 unit) in (if c then b else false)) as ({ e : (All B . String) , c : String })))
((pred ((if 1 then a else 1) [ C ])) as ({ Some B , ({ a : Unit , d : String }) }))
(\ d : ({ a : ({ Some E , A }) , e : ({ b : Bool , d : B }) }) . (({ * Unit , 1 } as B) (iszero (\ B . b))))
(iszero ((0 "apple") (a . c)))
(pred ({ d = (pred (\ A . ({ e = c , c = 0 }))) , c = (2 as ({ d : C , d : A })) }))
(({ e = (\ B . ({ d = 1 , d = c })) , e = ((a "boy") [ (({ Some E , A }) -> String) ]) }) [ (All E . ({ Some D , ({ e : (All E . Unit) , a : String }) })) ])
(succ ({ d = (succ ({ a = 2 , c = b })) , a = (\ B . (if 0 then "boy" else b)) }))
(succ (((succ a) as (Unit -> Float)) (a . a)))
(succ ((\ e : String . a) as (All C . ({ Some D , A }))))
(pred (((true . c) . c) . b))
({ * ({ d : (All D . ({ c : A , a : (Bool -> String) })) , e : ({ e : B , e : ({ Some E , Nat }) }) }) , ((\ E . a) [ ({ b : C , d : ({ e : C , e : String }) }) ]) } as (All B . ({ Some B , Float })))
(let { A , c } = (let { E , d } = (let a = ("apple" 1) in (if 2 then 1 else "boy")) in (if (iszero (\ c : C . false)) then (iszero (succ unit)) else ((true [ Nat ]) . a))) in (let { B , c } = (let { C , c } = "apple" in c) in (let c = b in c)))
(iszero (fix (fix b)))
(\ c : (All B . (All D . Nat)) . ({ * ({ Some B , C }) , (1 as String) } as (All C . Nat)))
((if (pred (let { C , c } = "boy" in a)) then (\ b : Float . a) else (c as A)) ({ c = (fix (pred unit)) , c = (\ a : (A -> C) . (iszero c)) }))
(fix (let { C , b } = (let { B , d } = (let b = "apple" in 0) in a) in ((fix "apple") [ ({ Some B , C }) ])))
(let { D , b } = ({ * (All E . Nat) , (iszero 2) } as ({ Some C , Nat })) in (let e = (\ c : ({ Some E , Float }) . (if 0 then "apple" else b)) in (iszero false)))
(fix (fix (\ D . "apple")))
(let { E , c } = (((a as Bool) as C) . d) in ((if ({ c = b , a = unit }) then "apple" else 2) . c))
(\ E . ((succ (fix c)) as (Unit -> C)))
(\ A . ({ d = (pred (2 . c)) , c = (if "boy" then b else (let { B , c } = a in 0)) }))
((\ D . (a as (All C . Nat))) as (({ b : C , c : Unit }) -> ({ e : (All A . Nat) , b : C })))
({ e = (iszero ((\ d : String . 2) [ ({ Some E , Float }) ])) , a = ({ * ({ e : ({ e : C , d : (A -> Unit) }) , a : (Bool -> Float) }) , ((true . c) unit) } as (All A . (Float -> Float))) })
(if (let { E , e } = (iszero ("apple" as ({ c : C , b : Nat }))) in (let { E , a } = "boy" in a)) then (iszero (\ a : ({ Some B , B }) . (succ "boy"))) else (iszero ({ e = (1 a) , e = ("boy" as Nat) })))
(((true . c) . e) (pred (iszero unit)))
(pred ((let { C , e } = ({ a = unit , b = unit }) in (b [ Float ])) . e))
((fix ("boy" . d)) [ ({ d : ({ b : (All D . String) , d : (All C . B) }) , a : (Float -> A) }) ])
((let { B , e } = (a b) in ({ b = 0 , d = true })) . e)
((pred (let { B , b } = a in 2)) (iszero (\ D . false)))
({ a = ({ c = (pred (pred b)) , d = (\ D . a) }) , d = ((pred "boy") . e) })
(fix (let { D , b } = ((let { E , a } = 0 in (0 . c)) (iszero 2)) in (iszero (if 1 then 2 else false))))
({ b = ({ * (All D . ({ d : C , b : String })) , (a . c) } as ((All B . Bool) -> (All B . Bool))) , d = (\ D . ({ a = c , d = unit })) })
((iszero ("boy" . b)) ((succ false) [ (All B . ({ Some E , B })) ]))
(\ d : ({ e : (All E . B) , e : ({ a : ({ d : C , c : A }) , c : (Bool -> C) }) }) . ((let { E , a } = (fix false) in b) (succ (pred b))))
(let e = (if (2 as Bool) then ("boy" [ Nat ]) else (pred (succ 1))) in (let d = (\ B . (pred false)) in (let c = "boy" in (succ 2))))
(\ B . (let e = ({ * (All A . Bool) , (iszero "apple") } as ({ e : A , a : Bool })) in (\ a : ({ a : B , a : String }) . (iszero b))))
({ c = ({ a = (let d = b in ({ b = "apple" , e = unit })) , e = ({ * ({ Some E , C }) , (iszero 0) } as (C -> A)) }) , c = (pred ((fix 0) . b)) })
(fix (let e = (let { D , b } = ({ c = unit , e = 1 }) in (let b = 1 in a)) in (let { B , c } = 0 in (\ E . b))))
(({ e = ({ a = 1 , e = "boy" }) , d = ((let a = c in 2) . e) }) (if (0 [ A ]) then (let e = b in 2) else (let d = a in 2)))
((succ ((pred 2) as ({ Some C , Float }))) [ ({ d : (All D . Bool) , c : ({ a : C , a : Unit }) }) ])
(((a [ Bool ]) as ({ Some C , Bool })) as ((All C . ({ e : String , a : Unit })) -> ({ Some C , ({ a : (All A . A) , b : String }) })))
(({ * (All E . (All A . ({ Some D , B }))) , (succ ({ b = c , e = c })) } as (All C . ({ d : (Float -> B) , c : Unit }))) as (All C . ({ Some E , ({ Some E , String }) })))
((if (succ (iszero 1)) then (false as B) else (succ unit)) [ ({ e : (Nat -> Float) , b : ({ Some D , Nat }) }) ])
(let e = ({ * ({ a : (All D . A) , e : ({ Some A , B }) }) , (1 as ({ d : Bool , b : Float })) } as ({ Some E , Float })) in (fix (pred a)))
(iszero (\ A . (fix (pred b))))
({ e = (let { C , c } = (\ d : (All B . Bool) . ("apple" [ String ])) in (let { C , b } = a in true)) , d = (iszero (({ d = false , c = 2 }) . a)) })
((if ({ * ({ b : A , e : String }) , (false [ String ]) } as ({ a : Float , d : C })) then (pred (0 [ Float ])) else (let { D , b } = (let c = (\ b : B . "apple") in (false as A)) in (false as C))) as (All D . (A -> A)))
(pred (\ C . ((let a = 0 in b) . a)))
(succ ((iszero "boy") [ (({ d : Unit , b : C }) -> ({ Some A , Nat })) ]))
({ c = (("boy" [ B ]) [ (All C . ({ Some D , C })) ]) , d = ((0 as C) as (C -> Bool)) })
(let e = (succ (true true)) in (succ ((fix c) as (All B . Nat))))
(\ b : ({ a : ({ Some E , Unit }) , d : (({ Some E , B }) -> Nat) }) . ((let d = true in true) as ({ Some A , Unit })))
(let c = ({ c = (\ B . 0) , d = (iszero (\ E . false)) }) in (let { B , e } = (let e = b in 2) in ((iszero 1) . b)))
(\ D . (\ a : ({ c : ({ b : Nat , a : String }) , e : (All A . A) }) . (\ E . (false . c))))
({ c = (let { B , a } = (let { E , b } = (let d = "boy" in a) in 1) in (\ c : A . true)) , c = ((let { C , d } = ({ b = unit , c = (let d = unit in a) }) in ({ * String , (b . a) } as (Nat -> Bool))) [ (All E . ({ Some C , C })) ]) })
(fix (let a = (let c = ({ c = c , d = 2 }) in "apple") in (let { E , a } = unit in false)))
(({ a = (\ e : Bool . (1 as String)) , c = (c . b) }) . b)
(if (("apple" [ (All B . Nat) ]) . a) then ({ a = (iszero ({ * B , 1 } as Bool)) , e = ({ b = (let d = b in false) , c = (iszero 0) }) }) else ({ e = ((pred unit) . b) , b = (let c = 2 in unit) }))
(let d = ((if 1 then "apple" else 2) as ({ Some D , (Unit -> Float) })) in (\ d : (All A . ({ c : Nat , e : A })) . ({ * Bool , (\ e : Unit . b) } as C)))
(fix (fix ({ d = (iszero c) , e = (let { B , b } = false in ({ * Float , 2 } as Nat)) })))
(let { C , a } = ({ a = (succ (true 0)) , a = (fix (b . e)) }) in (\ e : (B -> String) . (\ a : ({ Some D , ({ c : Float , b : Float }) }) . (a . b))))
(\ d : ({ Some A , ({ c : Float , c : Float }) }) . (\ c : ({ d : A , d : A }) . ((\ e : String . unit) . c)))
(if (({ * (Float -> Nat) , b } as Unit) . e) then (succ (false . e)) else ((false [ Unit ]) (\ e : B . true)))
(iszero ({ * ({ a : A , e : A }) , ({ e = unit , e = "apple" }) } as (({ Some E , Float }) -> (All E . A))))
((succ (fix ({ * Unit , "boy" } as Nat))) [ ((Bool -> ({ Some B , String })) -> ({ Some E , (All D . Float) })) ])
(succ (fix (2 as ({ e : String , e : Unit }))))
(let { D , a } = (\ C . (let c = (fix a) in (pred b))) in (if (\ D . c) then ((let c = (unit as String) in "apple") . e) else ((if "apple" then unit else "boy") [ (Bool -> Bool) ])))
((succ (fix a)) [ (({ b : Nat , b : String }) -> (All B . ({ Some B , String }))) ])
((("boy" [ Bool ]) . d) (iszero (if (fix c) then ({ b = 0 , a = "apple" }) else (if false then a else true))))
({ * ((All A . ({ b : Nat , e : C })) -> (All E . Float)) , ({ * (B -> String) , (pred true) } as ({ c : Float , c : ({ Some A , Nat }) })) } as ({ d : ({ c : A , e : Nat }) , d : ({ d : Bool , b : Bool }) }))
(if (let { B , d } = (succ b) in ({ * (C -> String) , 1 } as Float)) then ((let c = 1 in 1) as (All C . (All B . Bool))) else (iszero (let { E , d } = (\ d : ({ Some E , String }) . (let e = b in b)) in (succ 2))))
(\ B . (((pred (iszero 0)) (if a then (let c = 1 in "apple") else unit)) [ ((Unit -> Float) -> ({ a : B , b : String })) ]))
(pred ((iszero c) . c))
((((2 as Bool) . e) as ({ Some D , ({ b : (All E . String) , c : B }) })) . e)
(succ ((\ B . 2) as (All D . (Float -> C))))
((pred (let { E , a } = (if b then "apple" else 2) in (1 . d))) as ({ Some C , ({ Some C , Nat }) }))
(if ({ c = (pred (a . b)) , d = ({ c = ("boy" b) , b = (\ B . b) }) }) then (succ (if (fix "apple") then a else (fix false))) else (({ d = ((\ B . 1) "apple") , b = (true as String) }) (iszero (pred 0))))
({ * (({ Some C , (All C . A) }) -> (All C . ({ Some B , ({ Some B , String }) }))) , (\ a : (All D . (A -> Bool)) . (iszero (iszero 1))) } as (All A . (({ Some C , Bool }) -> Nat)))
(((pred (2 [ Nat ])) . e) (\ e : ((Nat -> Nat) -> (Nat -> C)) . (\ c : ({ Some D , Unit }) . (\ d : String . c))))
(pred (iszero (pred (pred unit))))
((fix (if 2 then 2 else unit)) as ({ Some E , ({ Some E , ({ Some D , ({ e : String , a : Float }) }) }) }))
(let d = ({ * (All E . Unit) , (if (\ d : C . 1) then (fix "boy") else ((\ B . 0) as C)) } as (Bool -> ({ e : B , c : Nat }))) in (let { B , d } = (\ E . ({ * Nat , unit } as C)) in (if 2 then a else a)))
(let { D , a } = (fix (a . a)) in (iszero ({ * A , unit } as (All A . A))))
(pred (if ({ b = ({ a = a , e = unit }) , a = (\ c : A . "apple") }) then (if (fix c) then 0 else c) else (pred (pred unit))))
((pred (0 1)) as ({ Some E , ({ a : (B -> Bool) , d : String }) }))
(pred (\ c : (All E . String) . (if "boy" then 2 else (c "apple"))))
(iszero (({ e = 1 , c = b }) (\ E . (pred unit))))
(\ C . (\ A . (iszero true)))
({ * ((Float -> Nat) -> ({ d : ({ Some E , String }) , d : ({ e : A , b : Nat }) })) , ((iszero false) ("boy" as Float)) } as (All A . ({ Some B , Unit })))
((let e = ({ * C , "apple" } as ({ Some A , Float })) in ((1 as C) as C)) (\ a : (All B . String) . ((a [ C ]) [ Float ])))
({ * ({ e : ({ b : (All A . Nat) , c : ({ a : (All A . Bool) , e : (All E . Nat) }) }) , d : (All C . (B -> Nat)) }) , ((\ E . (if 0 then "boy" else false)) as (All A . (All D . B))) } as ({ Some A , ({ b : ({ Some E , Bool }) , d : ((All C . Nat) -> ({ e : Float , a : A })) }) }))
(\ C . ((if 0 then a else c) [ (All E . C) ]))
(if (succ (false as ({ e : C , c : A }))) then (succ (if (\ c : String . a) then (if false then a else "apple") else "boy")) else (let { A , c } = (pred (\ D . c)) in (let d = unit in a)))
(if (fix (succ b)) then (pred (fix (0 [ B ]))) else (fix (let c = (a unit) in 1)))
