(case (< a = (succ ({ d = (if false then "apple" else b) , e = (2 a) })) > as ({ a : Unit , a : C })) of < b = e > => ({ a = (iszero (case 0 of < d = e > => b | < b = c > => true)) , e = (b as Nat) }) | < b = d > => ((iszero true) as (Rec D . ({ c : String , e : Nat }))))
((case (if unit then "boy" else unit) of < a = b > => (let e = a in true) | < d = e > => (succ true)) . c)
(iszero (succ (pred unit)))
((fix (iszero ({ e = true , b = (if "apple" then "boy" else 0) }))) . b)
(fix ((pred (succ b)) (succ a)))
(fix ((case "boy" of < b = b > => true | < d = b > => (< d = 2 > as Unit)) as (Rec D . Unit)))
(< e = ({ d = ((succ unit) . b) , b = (case (if unit then "apple" else b) of < b = b > => (fix true) | < b = b > => (succ (iszero 1))) }) > as ({ b : ({ b : Bool , a : Float }) , c : (< c : A , b : C >) }))
(\ d : ({ c : (({ c : B , e : Unit }) -> String) , e : (< e : (Nat -> Nat) , e : Unit >) }) . (let e = (fix unit) in (({ b = (\ b : Bool . c) , d = true }) as (< a : Unit , b : Float >))))
(iszero (((b . d) (let e = false in unit)) (if (succ (fix 1)) then ((b . c) . a) else (unit . e))))
((if ((iszero c) . a) then (0 "apple") else (case 1 of < d = b > => (if "boy" then 2 else "apple") | < c = a > => (unit . b))) . e)
(iszero (\ b : ({ b : (< c : C , e : String >) , c : Float }) . (iszero (0 as A))))
(case (< a = ("boy" c) > as ({ a : Nat , a : Nat })) of < e = d > => (\ d : ((Float -> C) -> (Rec D . Bool)) . (iszero false)) | < e = d > => (< d = (c as C) > as ((Unit -> Unit) -> Float)))
(pred (((pred 1) (< a = ({ d = "apple" , a = false }) > as Unit)) (\ d : Float . (\ b : Nat . 2))))
(fix (fix (if "boy" then unit else 2)))
((if ({ e = (succ false) , d = ({ e = 0 , d = b }) }) then ((succ c) as Float) else ({ a = true , e = false })) (succ (pred "apple")))
(let b = ((1 . e) . d) in (iszero ((a as Unit) (if "apple" then 0 else b))))
((if (let d = c in false) then ({ c = 1 , a = 0 }) else (case (iszero c) of < a = e > => (true as B) | < a = b > => (let c = 0 in true))) as ((Rec B . Bool) -> (Float -> ({ c : String , a : Float }))))
(< c = (fix ((iszero a) . d)) > as (Rec E . ({ d : (Rec B . C) , d : (Rec B . String) })))
((iszero (pred 1)) . b)
(({ a = (false . d) , e = (fix (case a of < d = a > => true | < b = d > => "boy")) }) . c)
(fix (let b = (succ (({ a = "apple" , d = 1 }) . e)) in (let c = (\ d : C . 1) in (< d = 2 > as Bool))))
(fix (case (let d = (if (< d = c > as Float) then 1 else unit) in (b as B)) of < d = a > => (let e = 0 in (unit as B)) | < c = b > => (\ c : (< c : Float , e : Bool >) . (let e = "boy" in 0))))
((< e = (if (if true then unit else b) then ((iszero 2) . c) else ({ e = "apple" , a = (< b = "boy" > as Float) })) > as ({ c : ({ a : Float , d : A }) , a : A })) ((iszero ({ c = (if 0 then false else 2) , d = ({ b = 0 , a = unit }) })) ({ b = (iszero 2) , a = ({ b = b , e = c }) })))
(iszero (iszero (case a of < a = d > => 0 | < b = d > => true)))
(case (iszero ((< b = unit > as B) . d)) of < b = c > => (pred (iszero true)) | < b = e > => (succ ({ a = (2 . d) , a = (fix unit) })))
((case (succ 1) of < a = b > => (iszero true) | < b = d > => (pred 2)) . e)
(iszero (case ({ b = "boy" , a = (case 0 of < e = b > => true | < a = e > => true) }) of < e = c > => ((< e = (true c) > as (Nat -> A)) as (({ a : A , c : Float }) -> A)) | < b = e > => (let c = (0 as (Rec E . C)) in (\ c : Nat . "boy"))))
(pred (< b = (< d = ({ e = unit , d = a }) > as ({ a : Nat , d : Unit })) > as (< b : (({ b : B , b : A }) -> (< b : Bool , a : A >)) , a : (< c : Bool , b : (< e : String , a : Bool >) >) >)))
(\ c : ((< a : ({ b : (String -> C) , d : Unit }) , a : (Nat -> String) >) -> (A -> (< a : String , e : Float >))) . (case (iszero (let b = 1 in false)) of < b = e > => (if (fix false) then (iszero true) else ("boy" b)) | < e = d > => (succ c)))
((if (succ (iszero 0)) then ({ b = a , d = 0 }) else (fix 2)) as (({ d : B , c : Unit }) -> (< a : A , e : B >)))
((let c = (fix true) in (false as Float)) (case (< c = 0 > as C) of < b = d > => (case (succ true) of < d = e > => ({ d = 2 , e = (\ d : Unit . unit) }) | < a = e > => (succ unit)) | < d = c > => (fix (succ b))))
((< b = (fix a) > as ({ a : ({ d : (Rec B . Bool) , b : Unit }) , d : (< d : Float , c : Float >) })) ((pred (< e = "apple" > as Nat)) (\ a : (< e : A , b : B >) . ({ a = false , e = a }))))
(((case 1 of < b = d > => "apple" | < c = e > => 1) ({ b = unit , b = (iszero false) })) ((succ a) . b))
(let a = (\ c : ((< a : B , d : Unit >) -> C) . (succ 0)) in (fix (iszero (fix 1))))
(fix (case ((if (succ a) then a else c) . e) of < a = b > => ((case true of < a = a > => (b false) | < c = a > => (< b = 1 > as Float)) as (Rec D . String)) | < c = c > => (if (fix "apple") then (\ b : (String -> Unit) . unit) else (case ({ b = a , c = a }) of < e = e > => (\ b : B . 0) | < e = c > => c))))
(pred (iszero ("apple" as C)))
(let d = (< b = ((iszero unit) . b) > as (Rec C . String)) in (< e = (succ unit) > as (Rec B . (< d : Float , b : Unit >))))
(\ d : (Rec B . (Rec C . Unit)) . (\ a : (Rec D . (Rec A . Nat)) . (succ (succ false))))
(case (let e = (pred ({ d = (fix b) , d = "apple" })) in (pred "boy")) of < a = a > => (if ((iszero "boy") . b) then (1 b) else (\ e : (< d : Bool , d : Bool >) . (b unit))) | < e = b > => ((\ b : C . "apple") as (({ a : A , d : B }) -> (Bool -> Bool))))
((\ a : (< d : Nat , a : Float >) . (case (\ b : Bool . c) of < c = e > => (\ c : B . "apple") | < e = c > => "apple")) (iszero (fix ({ b = (succ c) , e = ({ b = b , b = a }) }))))
(if ({ c = (case 1 of < d = c > => (false . a) | < c = e > => false) , e = (iszero (iszero 1)) }) then ((succ ({ c = (\ d : Bool . 0) , d = c })) (iszero (fix a))) else (pred (\ c : String . true)))
((fix (let e = (if c then 2 else 2) in c)) ((\ b : (< b : A , d : A >) . (fix false)) . b))
((< a = (false as Nat) > as (B -> C)) . c)
(pred (case (b false) of < d = c > => ((\ a : Nat . "apple") unit) | < a = d > => (succ 1)))
(case (iszero (iszero c)) of < a = b > => ((case 2 of < d = b > => (let d = 0 in "boy") | < c = d > => (let b = b in 2)) as ({ c : (< a : (Nat -> Unit) , e : C >) , c : (< c : ({ d : C , c : B }) , b : Bool >) })) | < b = a > => (if ((iszero b) as Bool) then (pred a) else (pred (succ 1))))
(< d = (< a = (pred true) > as (< e : String , c : Unit >)) > as (Rec A . (Rec B . String)))
(< a = ((a . c) . b) > as (< e : (Unit -> String) , c : (< d : ({ d : Bool , a : B }) , b : A >) >))
(((\ b : String . "apple") . e) as (Rec C . (< a : Nat , c : ({ e : B , e : Unit }) >)))
(pred ((pred a) as (Rec E . C)))
(({ b = (\ c : C . 1) , c = (\ c : B . "apple") }) as (Rec C . ((< a : (Nat -> Bool) , b : Bool >) -> (Rec E . (Nat -> String)))))
(pred (let b = (\ e : ({ b : A , c : B }) . (iszero "boy")) in ((if (c . c) then a else 0) as (Unit -> B))))
((((b as B) (let a = 0 in c)) ((if 0 then 1 else 2) . d)) as ({ a : (A -> (Rec A . String)) , d : (Rec C . (C -> A)) }))
(succ (pred (succ ({ a = "apple" , c = 0 }))))
((succ (\ b : A . "boy")) . a)
({ e = ((2 as A) (c . e)) , c = (if (case c of < e = c > => (\ e : C . "boy") | < d = c > => (let c = false in "boy")) then (if (iszero "boy") then (fix a) else (succ unit)) else (let a = (1 . c) in true)) })
(case ((succ (\ a : String . false)) (succ ("boy" false))) of < b = e > => (\ e : (< b : (A -> Bool) , a : Bool >) . (iszero c)) | < b = c > => (fix ({ a = (let a = 1 in true) , e = b })))
(let d = (\ a : (< c : Bool , e : Float >) . (if (\ d : Unit . a) then (if false then 1 else c) else (iszero b))) in (fix (pred unit)))
(\ d : (< a : (Rec B . Unit) , c : (String -> Float) >) . (fix (iszero (iszero a))))
(\ a : (Rec B . (Nat -> B)) . (if ((let b = b in b) unit) then (succ (pred 2)) else (iszero (pred 1))))
(\ e : (< c : (Rec E . A) , e : (Rec E . (Unit -> A)) >) . (((\ c : Unit . (let c = true in 2)) ({ d = 2 , e = 0 })) as ({ b : ((< c : Float , b : Unit >) -> ({ e : Nat , d : Unit })) , e : ({ a : C , a : B }) })))
(if (((fix "apple") as (Rec D . C)) . a) then (\ b : (Rec B . (B -> A)) . (< a = (case unit of < a = e > => 0 | < a = a > => 2) > as (A -> ({ d : Float , e : Nat })))) else (pred (iszero (let c = false in "boy"))))
((let c = ((if 1 then true else "boy") . d) in (iszero ((a . e) as C))) (succ (iszero (b . c))))
(fix (succ ((pred 1) (succ a))))
({ a = (({ d = (if c then true else b) , a = (let c = a in c) }) as ({ c : ({ c : Float , d : Bool }) , d : (C -> Float) })) , e = (({ d = "boy" , a = ({ a = true , d = true }) }) . e) })
(< d = (((if 0 then unit else c) . a) as (A -> ({ e : Float , b : Unit }))) > as (Rec D . (Unit -> Nat)))
(if (case ((< b = 0 > as Unit) as B) of < d = b > => (if c then true else "apple") | < a = c > => (< e = (fix unit) > as ({ a : Bool , b : C }))) then ({ a = (iszero (if c then a else 2)) , c = (if unit then (let d = a in true) else 0) }) else (< b = (pred 1) > as (B -> String)))
((succ (\ a : B . 0)) as (((C -> Unit) -> ({ b : ({ e : Bool , c : String }) , e : Float })) -> (< c : (({ a : Nat , d : Float }) -> (Rec D . A)) , a : (< a : Float , c : B >) >)))
(succ (if (succ (\ d : Bool . "boy")) then (\ e : (Rec E . ({ a : C , d : C })) . (\ d : (Rec A . String) . a)) else (case (succ ("boy" . a)) of < c = d > => ((if 0 then false else 1) as Nat) | < a = e > => (fix "boy"))))
(pred (pred (if (pred b) then (iszero 2) else (if "boy" then b else "boy"))))
(case (case ({ b = (pred (succ true)) , a = (iszero (b as A)) }) of < b = e > => (< b = false > as (Rec B . B)) | < a = c > => (let b = "boy" in (pred b))) of < e = b > => ((\ e : (< b : Float , b : Bool >) . a) . d) | < a = e > => (fix (iszero ("boy" . c))))
(let d = (fix (case false of < a = d > => (\ e : C . "boy") | < a = d > => (iszero 0))) in (\ e : (< e : ({ b : B , b : Bool }) , d : (B -> Bool) >) . (succ ((< d = "boy" > as String) as String))))
((let c = (pred a) in ("apple" as B)) as (< e : ({ d : String , b : String }) , b : ({ c : B , c : Unit }) >))
(case ((let a = ({ d = "apple" , b = ({ e = true , a = 1 }) }) in (\ a : A . true)) . d) of < b = e > => ((succ "boy") . e) | < c = a > => ((({ a = false , b = "boy" }) (pred 0)) (< e = "apple" > as (< e : Float , a : String >))))
((succ (< d = unit > as A)) as ((< c : Unit , e : String >) -> (Nat -> Float)))
({ c = (iszero (iszero (\ a : C . "apple"))) , e = (let e = (\ a : Unit . false) in (iszero a)) })
(let c = (iszero (succ ({ b = 1 , d = true }))) in (let a = (let a = (< a = false > as Float) in (({ a = "boy" , d = "boy" }) as ({ b : A , d : Nat }))) in (\ e : (Rec A . ({ a : Bool , b : C })) . (case unit of < b = b > => true | < c = e > => "apple"))))
(\ c : (< c : ((< e : Unit , d : C >) -> (Rec C . A)) , e : ((A -> C) -> C) >) . ((iszero unit) ({ d = 0 , d = unit })))
(< d = (case (< a = (true a) > as Bool) of < a = d > => (2 . e) | < e = d > => (iszero 1)) > as (Rec C . ({ b : A , c : Float })))
({ c = (let b = (iszero b) in (< b = (c as A) > as ({ c : C , d : String }))) , d = (\ e : (Rec C . String) . ({ a = "apple" , c = true })) })
((if ({ c = ({ c = b , c = "apple" }) , b = b }) then (case "apple" of < a = b > => "boy" | < d = a > => 2) else (< d = (fix "boy") > as Bool)) (let b = ("apple" as Unit) in (iszero 1)))
(succ ({ b = (c as Bool) , c = (if (2 as String) then c else c) }))
(let a = ({ a = (case c of < a = c > => "boy" | < c = a > => ({ b = c , e = false })) , b = ("apple" as A) }) in (iszero ("apple" as Float)))
(((\ d : String . unit) as (Rec C . Bool)) . a)
((({ c = (< e = true > as String) , c = 2 }) . a) (\ b : (< b : (Rec D . C) , b : ((< a : B , c : Float >) -> Nat) >) . (let b = (fix unit) in (c as Float))))
(\ c : (Rec A . (< a : Unit , d : (< a : B , b : String >) >)) . (case (true as (< a : Float , d : Nat >)) of < d = e > => ({ a = (fix "apple") , c = false }) | < d = e > => (case 2 of < a = a > => b | < a = b > => b)))
(\ e : ({ a : (< b : Unit , a : B >) , b : (< b : ({ d : B , c : Unit }) , e : (Rec A . A) >) }) . ((if false then a else unit) as ({ d : (< b : Unit , c : A >) , d : String })))
(let c = (succ ({ e = "boy" , e = unit })) in ((if false then b else "boy") (iszero 0)))
(\ c : ({ d : (Rec A . Nat) , d : ({ b : A , e : (< c : C , c : Nat >) }) }) . (case (if true then (let c = true in "boy") else (iszero false)) of < e = d > => (iszero (pred 1)) | < e = a > => (let d = 2 in false)))
(({ d = (({ a = true , b = b }) . d) , e = (fix (let a = unit in "apple")) }) ((pred false) as (String -> String)))
(fix (((1 true) . b) . d))
(let e = ((fix (pred unit)) . a) in (\ c : (Rec B . (< a : String , d : A >)) . (case b of < e = a > => false | < b = b > => b)))
((case ({ b = ("boy" as A) , d = ({ c = 0 , c = 1 }) }) of < d = a > => (fix (if c then (< c = 1 > as Nat) else (succ 1))) | < b = b > => ((pred (case 2 of < e = e > => "boy" | < e = e > => "apple")) as (< a : ({ e : Float , a : C }) , e : (Rec C . B) >))) ((if (2 . a) then (if (\ a : Nat . "apple") then a else "boy") else (fix "boy")) as (String -> Float)))
(((iszero 0) . d) ((if ((case "boy" of < e = b > => 0 | < a = d > => b) as String) then (1 . c) else (if (< c = 1 > as Float) then b else b)) as (< e : ({ d : (< d : B , e : Unit >) , a : (Rec B . C) }) , a : ({ e : String , c : (Rec E . String) }) >)))
((let e = ((case (let c = 0 in false) of < d = c > => ({ b = a , c = "boy" }) | < b = e > => (\ d : A . "boy")) . c) in (case ({ d = (unit a) , d = false }) of < a = a > => (pred (fix "boy")) | < b = d > => (\ d : Float . 1))) . a)
((case (pred (iszero unit)) of < b = e > => (false as (Rec C . Float)) | < e = a > => (< a = false > as (Unit -> C))) . a)
(iszero (\ c : (< a : (Float -> A) , c : (Rec B . C) >) . (fix (case c of < d = d > => c | < e = a > => b))))
(succ ((fix (false as (< c : Float , d : C >))) . d))
((fix (iszero false)) . c)
((iszero ((< a = "apple" > as Unit) . c)) . b)
(let b = ({ b = (case false of < c = c > => false | < b = e > => (a b)) , d = ((pred "boy") (false as Float)) }) in ((true as Float) . d))
(fix (pred (iszero true)))
((fix (case c of < b = c > => (unit . b) | < b = a > => unit)) . b)
((fix ((succ (iszero false)) (< d = 1 > as Unit))) (case (< b = b > as String) of < e = a > => (case 0 of < c = a > => unit | < d = c > => ("boy" as Bool)) | < b = b > => ((succ unit) . e)))
(pred (< b = (pred ({ a = true , d = "boy" })) > as ({ c : ({ a : String , c : B }) , c : (< a : (Float -> C) , d : A >) })))
(let a = ((({ b = false , e = unit }) as (< e : Bool , a : B >)) ((1 . a) ((succ "boy") . d))) in (let c = (if (< c = false > as ({ a : Float , d : Nat })) then (case c of < d = b > => "boy" | < a = a > => true) else (fix false)) in (if (let d = (\ e : Unit . b) in "apple") then (fix c) else (pred a))))
(fix (fix (\ c : (Nat -> A) . (fix 2))))
({ d = (\ a : (Bool -> (Rec D . Bool)) . (pred (c . d))) , c = ((iszero (c as String)) (let d = (succ b) in c)) })
(pred (case (b . a) of < a = c > => (if 0 then b else 2) | < d = a > => (if (fix 1) then 0 else (case true of < c = a > => c | < a = d > => 2))))
({ a = (succ (iszero 2)) , c = (pred (case "apple" of < b = c > => "apple" | < d = c > => false)) })
(< e = (\ a : (< b : (< e : A , d : String >) , a : (Bool -> Bool) >) . (case (let a = 1 in b) of < b = b > => (fix 1) | < c = b > => b)) > as (< e : (< b : Bool , c : String >) , e : (< b : B , a : (Nat -> C) >) >))
(case ((pred true) ((fix "apple") . e)) of < b = b > => (pred ("apple" as B)) | < a = c > => (iszero ((0 as B) . b)))
(fix ((fix "boy") as (Rec D . ({ b : Float , a : C }))))
(iszero (< d = (< c = c > as Float) > as ({ d : (< a : A , e : String >) , d : (Bool -> Unit) })))
((pred (iszero b)) as ((A -> (Bool -> Nat)) -> (< b : String , a : ({ c : String , d : Unit }) >)))
(let d = (if (case (\ d : Nat . 1) of < c = e > => b | < e = e > => 1) then ({ e = (2 a) , d = (fix "boy") }) else (let e = ({ c = c , e = 2 }) in (\ b : String . b))) in ((pred (succ (if false then c else a))) as (< c : ((B -> C) -> (Rec D . Float)) , d : (Rec D . (Rec A . B)) >)))
(if (let d = (succ ("boy" . a)) in (case (\ b : (Rec D . Unit) . (< a = 2 > as Float)) of < c = b > => ("boy" . a) | < d = c > => ((case false of < e = e > => 1 | < e = e > => false) . b))) then (fix ((let c = c in unit) . e)) else ({ c = (fix (\ b : Nat . b)) , c = (< d = (0 (pred 2)) > as (< b : Nat , a : (Rec B . C) >)) }))
(((iszero (< e = a > as ({ e : B , a : A }))) as (Rec C . ({ d : A , e : C }))) as ((Float -> A) -> (< c : Unit , a : Bool >)))
(succ ({ d = (true as Nat) , b = (unit . d) }))
(pred ((1 (iszero b)) as ((B -> Float) -> (Rec E . String))))
((pred ((let b = 0 in "apple") as (< c : C , b : Nat >))) . b)
(succ (\ a : (Rec E . (Rec D . String)) . (succ true)))
(succ ((case (0 "boy") of < d = a > => (let b = 2 in 1) | < e = b > => (if true then 2 else false)) (let b = ({ d = (fix "boy") , e = false }) in (c . a))))
(< c = ((iszero (succ 2)) as ({ a : (< d : (< b : B , a : Nat >) , b : String >) , e : (< b : (Rec A . C) , d : (String -> B) >) })) > as ({ e : ({ d : (< a : C , c : Float >) , a : B }) , a : (A -> (< b : String , b : Float >)) }))
(succ (iszero ((a . c) (1 false))))
(succ ((< b = (let d = false in "apple") > as ({ d : (< a : String , d : A >) , d : (< d : Unit , e : C >) })) (succ 2)))
(fix ((iszero 2) . e))
((fix (iszero "apple")) as ((< e : (< a : Bool , a : C >) , b : ({ d : A , a : Bool }) >) -> (Rec E . (< e : Bool , d : Unit >))))
(\ a : (Rec D . (Rec E . B)) . (let e = (fix (2 c)) in (pred "apple")))
(pred (fix (< e = "boy" > as ({ d : C , a : Bool }))))
(case (succ ("apple" . a)) of < d = d > => (case (succ (pred true)) of < b = e > => (0 as Nat) | < a = c > => ("boy" . b)) | < a = c > => (< d = (\ d : A . a) > as (C -> String)))
(case (pred (fix 1)) of < b = c > => (\ e : (< e : Nat , b : (< b : Float , c : Bool >) >) . (a . e)) | < c = d > => (\ c : (Rec C . ({ d : (< a : Bool , d : Unit >) , e : Unit })) . (iszero (let a = (let b = c in c) in true))))
(< c = (succ (if (succ 2) then (c (true b)) else (case unit of < d = c > => (0 as A) | < c = b > => a))) > as ((< c : (B -> Unit) , a : (Float -> Bool) >) -> ({ e : (< c : B , b : C >) , d : ({ d : String , e : String }) })))
((if (succ unit) then (\ b : Nat . (if "apple" then unit else 2)) else ({ c = false , e = true })) (case (< d = (true as Float) > as B) of < a = a > => (if (iszero c) then unit else (if unit then unit else "apple")) | < d = e > => (iszero a)))
((case ((< d = b > as C) as (({ b : Bool , a : Unit }) -> ({ e : B , d : A }))) of < d = a > => (pred 1) | < c = b > => (case ((1 . a) (pred "apple")) of < b = a > => (case (pred unit) of < d = b > => true | < b = a > => "boy") | < a = d > => (< c = b > as Unit))) as ({ d : ({ d : ({ c : C , d : Float }) , d : (Rec D . A) }) , d : (Rec D . ({ e : (Bool -> Float) , b : String })) }))
(iszero (succ (if (succ true) then ({ b = false , e = unit }) else (fix 0))))
({ e = (if (succ (1 as Unit)) then (succ (\ b : Unit . unit)) else (fix a)) , d = (case (iszero (pred true)) of < c = c > => (succ "apple") | < b = c > => (iszero (\ c : B . (iszero unit)))) })
((if (1 as A) then (succ (fix 0)) else (case "boy" of < d = c > => false | < e = a > => a)) ((< b = 1 > as B) as (< c : B , a : A >)))
(case (pred (case "apple" of < c = a > => (succ 1) | < a = c > => (true as C))) of < e = b > => (fix (succ ({ e = 1 , b = c }))) | < b = d > => (fix (let b = c in "boy")))
(\ b : (({ b : (Rec C . C) , b : (Rec A . B) }) -> ({ d : (< a : Unit , c : Bool >) , e : ({ e : Unit , e : Bool }) })) . (let d = (2 2) in (\ d : Bool . 0)))
(if (pred (fix "apple")) then (if (succ (fix (fix "boy"))) then ({ b = (iszero false) , e = (if 1 then "apple" else (false as Bool)) }) else (c b)) else (\ e : (Rec A . (Unit -> C)) . (let d = (iszero false) in (true as String))))
({ b = (iszero (\ a : Float . (true as B))) , d = (("apple" as (< d : Nat , d : A >)) . a) })
(case (fix (succ (a c))) of < e = a > => (iszero (let c = 1 in 0)) | < e = b > => (succ ({ e = 0 , a = b })))
(case ((fix 1) as (Rec A . String)) of < c = d > => ({ c = (false . c) , e = (false . b) }) | < e = b > => (case (let d = "apple" in c) of < e = d > => ((succ 1) (\ b : Unit . 2)) | < e = e > => (\ e : (< a : Unit , a : A >) . (iszero 0))))
(case ((let a = 0 in 0) . c) of < a = d > => (if (succ b) then (fix (succ a)) else (case false of < b = c > => false | < b = c > => 0)) | < c = c > => (iszero (if "boy" then false else unit)))
({ b = (< d = (c false) > as ({ c : Bool , d : Unit })) , a = (let b = (let b = (iszero "apple") in (1 2)) in (let b = 0 in 1)) })
({ d = ((case (2 1) of < d = d > => (if b then unit else c) | < c = e > => (succ 1)) . e) , e = (let e = ((\ a : Float . "apple") . b) in (pred 1)) })
((\ d : (< a : (Rec A . B) , a : ({ e : B , b : (Rec D . Float) }) >) . (< c = (if 2 then ("boy" true) else (pred 2)) > as (Rec C . (C -> A)))) (fix (case (succ "apple") of < c = e > => (true 2) | < b = b > => (if 2 then a else c))))
(fix ({ c = (iszero "boy") , a = (fix unit) }))
((iszero (pred (succ 1))) ({ d = ({ c = "boy" , b = (succ 1) }) , a = (let a = 0 in a) }))
(fix ((succ b) . a))
((\ c : (C -> Bool) . (if ("apple" as (C -> Nat)) then (let c = 2 in ({ c = "apple" , d = false })) else (fix (< d = b > as B)))) (succ (iszero (\ c : String . false))))
(\ e : ((< c : String , a : (< a : Float , e : Unit >) >) -> (Rec B . (B -> Float))) . ((case (2 unit) of < c = e > => 1 | < c = c > => b) . e))
(succ (succ (({ e = 2 , a = 0 }) (iszero a))))
(((succ (fix 2)) (\ d : (Rec B . Nat) . "boy")) (let b = (< d = (< a = 2 > as Nat) > as String) in (({ b = unit , e = "boy" }) . d)))
(({ e = (< c = c > as Float) , c = ({ b = 2 , b = "apple" }) }) (succ (a as ({ c : String , e : Unit }))))
(fix (({ b = b , a = c }) as (< d : (Rec B . ({ c : B , e : Float })) , a : (B -> Unit) >)))
(\ e : (Rec A . (< d : (Nat -> C) , c : Unit >)) . ({ b = (false c) , a = (\ c : String . (pred b)) }))
(succ ((iszero 2) . c))
(succ (succ (if (case true of < b = a > => unit | < b = d > => a) then (1 . b) else (fix c))))
(\ c : (({ b : (C -> Float) , d : ({ e : C , b : A }) }) -> (< e : Float , d : String >)) . (< d = (fix (if "boy" then b else (if "apple" then "apple" else b))) > as ({ a : (< b : Bool , e : A >) , a : ({ a : A , b : Float }) })))
(((pred (\ d : B . 0)) . c) as ({ b : (String -> C) , a : ({ d : C , a : Float }) }))
(case (fix (let c = (let a = b in "apple") in (< b = unit > as B))) of < a = b > => (iszero (\ c : (< c : (Rec B . Bool) , c : Nat >) . (succ (iszero "apple")))) | < e = b > => (iszero (pred (pred false))))
(succ (case (if (fix 1) then false else (fix false)) of < d = c > => (true . d) | < e = a > => (let a = (if true then 0 else 1) in (< d = false > as String))))
(let a = ({ b = ((let c = b in "apple") as B) , e = (2 as String) }) in (((succ (fix "boy")) as (< c : Unit , e : Unit >)) as ({ a : (< a : Unit , b : C >) , a : B })))
((fix (case (false . b) of < e = d > => (fix b) | < e = e > => (< e = c > as ({ d : String , d : B })))) (fix (if (< a = (< e = "apple" > as C) > as (Nat -> String)) then (2 as Bool) else (let a = false in unit))))
(\ d : ((< b : A , e : Nat >) -> (< b : Bool , c : B >)) . (({ b = (0 . c) , b = (0 as C) }) as (< e : Nat , e : Float >)))
(< d = (\ a : (({ a : C , e : B }) -> (< e : Float , b : B >)) . (\ d : (Rec A . (< c : C , e : Bool >)) . (let b = false in a))) > as (Rec E . (< a : Nat , d : Float >)))
(((< d = c > as A) . e) as (< d : (({ c : B , e : C }) -> (Rec E . String)) , a : ({ e : (Rec D . C) , a : (< c : Bool , c : (C -> C) >) }) >))
(pred (fix ({ d = (succ 1) , c = (c b) })))
(if (let a = (unit as String) in (< a = (pred (case false of < a = b > => 0 | < e = b > => c)) > as (< b : Nat , e : A >))) then (< b = ((if (0 as String) then (case c of < d = a > => a | < a = b > => b) else 2) ({ c = false , e = true })) > as (Unit -> Nat)) else (let e = (case (let b = "apple" in a) of < c = c > => (case 1 of < e = d > => a | < c = c > => unit) | < c = c > => (pred c)) in ((true false) . d)))
(let d = (case (pred ((succ unit) (let b = 2 in true))) of < d = e > => (succ "boy") | < a = a > => (\ d : ({ d : Float , b : ({ a : String , c : C }) }) . ("boy" "boy"))) in (succ (iszero (fix 1))))
(let a = (succ (case false of < b = e > => (succ "apple") | < b = b > => ({ c = "boy" , b = false }))) in (iszero (case ({ e = 1 , d = 1 }) of < d = b > => ((case b of < c = d > => unit | < d = d > => true) 1) | < e = b > => ({ b = false , b = true }))))
(if (< e = (pred 0) > as (Unit -> A)) then (pred (c as (A -> Float))) else (< c = (fix (< d = 1 > as C)) > as (Rec D . Bool)))
(if (if (false as (< c : Nat , c : C >)) then ("boy" . a) else (false . b)) then (let c = ((false as Nat) . b) in (\ a : Nat . a)) else ((< a = "apple" > as Nat) as (B -> String)))
((iszero (\ b : A . (fix a))) (succ ((if a then b else false) (iszero unit))))
(case (iszero (succ (if (fix true) then (\ a : Float . c) else ({ c = 2 , c = c })))) of < d = e > => (if (iszero "boy") then ("apple" as Nat) else ((\ e : A . a) (iszero c))) | < e = a > => ({ e = (1 2) , d = (iszero b) }))
({ d = (((if "apple" then 0 else c) (\ c : ({ b : Unit , e : B }) . b)) . e) , d = ({ d = (fix (if 1 then false else 2)) , b = (< b = (pred "boy") > as (Nat -> Nat)) }) })
((< e = (if a then false else 0) > as (< c : B , e : (< d : Bool , d : Float >) >)) (case (\ c : (< d : Nat , b : Nat >) . unit) of < e = b > => (fix 2) | < b = b > => (\ c : ({ c : Bool , d : C }) . (succ 2))))
(((iszero (fix b)) as (< b : (< d : Nat , e : Nat >) , b : ({ e : A , b : Bool }) >)) (fix (< d = 1 > as ({ a : Nat , e : String }))))
(if ((if b then (succ 1) else (if 1 then 2 else 1)) . b) then (succ (succ "apple")) else (pred (\ d : C . (< d = true > as Nat))))
(pred ({ d = (iszero ({ e = c , b = 0 })) , a = (case "boy" of < e = c > => b | < c = a > => c) }))
(let e = (< d = ((case true of < a = e > => unit | < a = d > => a) as (< b : Bool , a : (Rec E . Nat) >)) > as (Rec D . ({ c : (< d : A , b : C >) , d : (< e : Unit , d : String >) }))) in (iszero (pred 1)))
({ d = (((succ unit) (true as Unit)) . e) , b = (iszero (\ a : ({ c : A , e : Unit }) . (fix "boy"))) })
(pred (let d = (b . e) in (2 . a)))
(case (if (< c = false > as (Nat -> Bool)) then (({ a = c , c = c }) . b) else (let b = true in b)) of < e = b > => (iszero ({ e = (iszero 1) , c = (< c = a > as (< a : Nat , a : B >)) })) | < c = b > => (iszero (< b = (fix 0) > as (Rec E . B))))
((succ (case 0 of < a = a > => 1 | < d = c > => unit)) . c)
((succ (< e = false > as Bool)) as (< a : (B -> Bool) , e : (Rec D . ({ b : (< e : Nat , e : C >) , e : Float })) >))
(case (fix (false a)) of < a = b > => (< b = (pred ({ b = 1 , a = false })) > as (C -> Unit)) | < d = d > => (succ (case false of < b = c > => a | < c = c > => 0)))
(pred ((\ c : ({ d : (Rec C . Float) , d : Float }) . (\ a : B . (< e = false > as Bool))) as (Rec D . (Float -> C))))
(succ ((fix (succ 2)) (pred 2)))
(pred ((1 as C) (if (< e = 1 > as A) then (fix "apple") else "boy")))
(if (< a = (b (\ b : Bool . 2)) > as (< a : Unit , b : Unit >)) then ((({ a = 0 , b = true }) as ({ e : Nat , a : C })) ({ d = (iszero (c . c)) , d = (a . a) })) else (\ a : (< d : (C -> Nat) , e : B >) . (let b = (let d = (\ d : Bool . "apple") in 1) in (if "apple" then (2 "apple") else (a 0)))))
((\ a : (< c : B , e : (Rec C . Unit) >) . (iszero "apple")) . e)
(succ (pred (pred (let c = 1 in a))))
({ a = (((iszero unit) . a) (\ c : ((Rec D . Nat) -> (Rec E . A)) . ({ b = (case true of < b = b > => b | < a = a > => 1) , b = (pred 1) }))) , b = (succ ((\ a : (Rec C . Unit) . ("boy" as Float)) (fix (true . d)))) })
(iszero ((iszero "apple") . b))
(case ({ c = ((if "boy" then false else false) . a) , e = ((< c = 1 > as Float) as A) }) of < d = d > => (< d = (case (succ b) of < b = c > => true | < a = a > => false) > as (Rec A . (Unit -> C))) | < c = e > => ((iszero "boy") (unit as Bool)))
(pred (if ((if a then c else "apple") ("apple" false)) then (fix (pred ({ e = 0 , a = c }))) else (if "boy" then 1 else 0)))
({ d = (pred ((let c = 1 in 0) . a)) , c = (< a = (succ a) > as (< a : String , e : B >)) })
(fix (\ b : ({ a : (Rec A . Float) , a : (Rec D . Nat) }) . (let e = unit in unit)))
((< a = ((0 as C) as (Rec E . A)) > as (< d : (Rec A . (B -> Bool)) , b : (< a : Nat , e : Bool >) >)) as (< c : (Float -> Unit) , e : (Rec C . C) >))
(succ ((let d = (if (iszero 1) then (let d = 1 in b) else (case false of < d = b > => "boy" | < a = b > => "boy")) in (false 2)) as ({ a : ({ e : A , d : Unit }) , e : (Bool -> Float) })))
(< c = (({ a = (iszero (if b then "apple" else true)) , a = (pred (b . a)) }) ("apple" false)) > as (Rec D . ({ a : (Unit -> String) , e : ({ a : Bool , c : A }) })))
(if (fix (fix (case unit of < a = c > => "apple" | < d = d > => 1))) then ({ d = ({ c = c , a = unit }) , b = ({ d = (unit as (Unit -> B)) , b = (case b of < a = a > => 0 | < c = e > => 2) }) }) else ((\ c : ({ e : Float , c : A }) . ((\ b : B . 2) . d)) . d))
(fix ({ d = ({ a = (succ true) , b = (if true then unit else "apple") }) , c = (fix (({ c = 0 , a = "apple" }) . c)) }))
(< c = (\ a : (< b : Nat , b : Nat >) . (let e = true in (if "boy" then "apple" else 1))) > as (({ d : String , b : ({ e : Bool , e : B }) }) -> (Rec B . (Rec B . B))))
(pred ({ a = (case false of < d = a > => (b . c) | < b = c > => (0 . a)) , a = (succ (succ a)) }))
(\ a : ({ c : (< c : (< b : C , c : Bool >) , c : C >) , c : ({ c : (A -> A) , b : ({ e : (Rec D . Nat) , a : (Unit -> String) }) }) }) . ((let b = "apple" in a) . a))
(iszero ({ e = (\ a : C . false) , a = (\ c : Float . (iszero 2)) }))
((iszero ((\ d : B . (succ false)) . a)) . d)
(if (succ (c "boy")) then (\ c : ((< e : A , c : String >) -> Unit) . (< d = unit > as Bool)) else (((if a then c else false) (pred unit)) as ((C -> Nat) -> (C -> ({ b : A , c : C })))))
({ e = (pred (if "boy" then b else "boy")) , c = (pred (unit b)) })
(if (< d = (\ e : ({ d : B , a : B }) . unit) > as (Rec A . (A -> Nat))) then ({ e = (\ e : Unit . 2) , c = (0 as C) }) else (succ ((pred c) "boy")))
(\ d : ({ a : ({ c : String , a : Float }) , a : (< b : Nat , e : Float >) }) . (pred (if "boy" then true else (pred b))))
({ b = (("apple" . b) as (< b : ({ b : A , e : Float }) , a : ({ c : Float , b : Unit }) >)) , c = (case ((case "boy" of < b = a > => unit | < b = e > => a) . d) of < e = a > => (\ d : ({ d : A , a : C }) . (succ 1)) | < a = b > => (if ({ b = a , e = true }) then true else 2)) })
(succ ((let b = "apple" in a) (fix (let c = unit in true))))
(if (fix (if (let b = 2 in "boy") then (let e = (pred 0) in ({ d = c , b = "apple" })) else (fix "apple"))) then (iszero (succ b)) else (let d = (true 0) in (iszero 1)))
(\ c : (Rec A . (Rec B . (B -> Unit))) . (iszero (< e = (succ a) > as ({ c : (A -> Nat) , d : ({ a : Nat , c : Bool }) }))))
(< d = (pred (succ 1)) > as ((String -> Float) -> ({ c : (< c : Float , b : String >) , b : C })))
({ d = (\ d : ({ e : (Rec C . Unit) , d : ({ a : C , c : A }) }) . ((pred ("boy" true)) . d)) , d = (fix (2 . e)) })
(case (succ ({ e = (let b = (< b = 2 > as A) in (if false then 0 else 0)) , b = ((pred true) true) })) of < a = c > => (fix (succ unit)) | < c = e > => (< d = (({ a = unit , d = "boy" }) . a) > as (Rec D . Bool)))
(< d = (succ (fix a)) > as (Rec C . (< d : (Nat -> A) , d : (Unit -> A) >)))
(< b = (let b = (let d = "apple" in false) in (pred (1 as Float))) > as ((< e : Nat , b : Unit >) -> (Nat -> (A -> Float))))
(\ e : (< a : (Nat -> A) , b : ({ c : (Bool -> C) , b : Unit }) >) . (iszero (pred (case false of < d = c > => a | < d = b > => unit))))
((({ e = (fix "boy") , b = (let a = false in (\ e : C . b)) }) (pred "boy")) as (< e : ({ c : C , d : Nat }) , a : (String -> Float) >))
(let b = (if (2 "boy") then ((false . a) (c as C)) else (\ d : (Rec B . ({ a : B , a : String })) . (succ true))) in ({ e = ((b as Unit) as Float) , a = (if c then 0 else (case b of < b = d > => c | < a = c > => b)) }))
(let c = (pred ((case b of < d = e > => c | < c = e > => 1) . a)) in (\ e : ((< b : Bool , a : C >) -> Float) . (succ (\ c : B . false))))
(pred (succ (< b = (if unit then "apple" else a) > as C)))
((let e = (let a = (0 . b) in ({ d = 1 , e = c })) in ({ a = (unit . e) , c = (< b = (iszero c) > as B) })) . a)
(case ((fix (iszero unit)) . a) of < c = b > => (let c = (1 "boy") in (pred "boy")) | < e = c > => (case (succ (\ e : A . true)) of < d = c > => (< b = 0 > as Float) | < e = a > => (pred b)))
((pred (\ d : Unit . 0)) as ({ d : (Unit -> (Rec A . A)) , d : (< e : Nat , b : String >) }))
(< d = (((pred a) as (Rec A . (Rec B . C))) . a) > as (Rec B . (< e : Bool , d : (< a : Unit , c : Nat >) >)))
(iszero (\ a : ((B -> B) -> (Nat -> Unit)) . (fix (case true of < d = a > => a | < e = a > => 1))))
(succ (succ (let a = c in a)))
(succ ((\ c : (< b : B , c : C >) . (\ c : Unit . "apple")) as (Rec D . B)))
(((2 . e) . d) as (({ c : Unit , b : String }) -> (< d : Float , c : A >)))
(fix (((iszero false) . c) (succ (if true then b else 0))))
(if (case (("boy" as Float) (iszero 0)) of < b = b > => (if "apple" then 1 else "boy") | < e = c > => (1 as (< b : B , c : B >))) then (let b = (if 0 then "boy" else (iszero "boy")) in (succ 1)) else (< a = (< e = 2 > as Nat) > as ({ e : Unit , a : Nat })))
(({ a = (if ({ a = (2 as B) , a = (< a = c > as String) }) then (iszero a) else (iszero unit)) , e = (fix (unit (1 as Bool))) }) as (Rec E . (Rec B . Nat)))
(if ({ d = ({ c = (c "boy") , a = (iszero "boy") }) , b = (if false then "apple" else c) }) then (\ e : ({ a : Bool , e : (Rec A . Nat) }) . (succ false)) else (((fix "apple") as ((< c : Nat , a : Float >) -> B)) (case (case unit of < c = e > => (if 0 then c else b) | < d = a > => (a true)) of < d = b > => (if "apple" then ({ e = b , d = b }) else ({ b = c , c = "boy" })) | < b = a > => (2 . d))))
({ a = (pred (case 2 of < c = b > => true | < c = b > => (fix b))) , b = (({ c = (case c of < d = e > => a | < e = b > => a) , c = unit }) as (Rec E . (Rec C . B))) })
(({ e = (fix (if c then unit else unit)) , d = ({ a = (\ e : Bool . false) , e = (2 as Float) }) }) . e)
({ a = (\ a : (Rec D . B) . (if (fix true) then ({ d = 1 , e = c }) else 1)) , a = (pred ((let d = b in c) . d)) })
(iszero (\ c : (< b : (Nat -> Nat) , e : (Rec C . Float) >) . (< c = (if false then "boy" else false) > as (Rec D . A))))
((if ((case (< d = b > as Unit) of < a = c > => a | < d = c > => (if 2 then unit else true)) . a) then (({ a = (fix 0) , a = c }) (iszero false)) else (pred ({ b = 2 , a = unit }))) (pred (if (fix 2) then (c as Unit) else (pred "boy"))))
(case (let b = (< e = ({ a = "boy" , a = 2 }) > as (C -> Float)) in (case 1 of < c = a > => a | < d = d > => "apple")) of < d = b > => (\ b : ({ a : Nat , b : ({ a : C , d : Nat }) }) . (c b)) | < d = c > => ((2 c) as ({ d : Unit , d : A })))
(fix (iszero (c . c)))
((({ a = (\ d : A . 0) , a = (pred 1) }) . a) (succ ({ e = true , a = false })))
(< a = ((iszero ((a . a) true)) . d) > as (({ d : Nat , c : ({ a : A , c : Float }) }) -> (Rec A . String)))
((\ c : (< d : Unit , d : B >) . (((fix 2) (succ c)) . e)) as (({ c : Unit , e : String }) -> (Rec D . Unit)))
(fix (fix ({ b = (pred b) , c = true })))
(< a = (succ (c "apple")) > as ((Rec B . (Rec C . (< d : Float , c : Bool >))) -> ((< a : B , c : Unit >) -> (Nat -> C))))
((((< d = "apple" > as A) as (< e : Bool , d : B >)) (succ 2)) as (< e : (Rec C . Float) , b : (< e : A , d : Unit >) >))
(iszero ((< e = (iszero true) > as (< d : String , a : Nat >)) as (Rec A . Nat)))
(if (iszero (let a = "boy" in "apple")) then (< b = (let c = (fix unit) in (if true then (pred 1) else "boy")) > as (< a : B , e : ({ b : Unit , e : String }) >)) else (fix (\ d : B . 0)))
(case (let b = ((< a = c > as B) (case a of < e = e > => b | < a = b > => b)) in (iszero (1 true))) of < c = b > => (case (iszero 0) of < d = d > => ((2 . b) ("boy" as Nat)) | < d = d > => (succ (fix "apple"))) | < a = e > => (pred (\ d : Bool . a)))
(fix ({ a = (if true then b else 2) , c = (succ b) }))
(iszero ({ e = (pred ({ e = "apple" , d = unit })) , d = (fix unit) }))
(iszero (if (case (case "boy" of < b = a > => true | < d = e > => 2) of < e = b > => (iszero "apple") | < a = b > => (pred 0)) then (iszero 1) else (b . c)))
(((succ c) (\ e : B . true)) as ({ d : (< b : (Rec B . Float) , b : B >) , c : (Rec D . Float) }))
(fix (< c = (pred (fix "apple")) > as (< c : String , a : ({ e : A , d : Nat }) >)))
(let e = (iszero (iszero (pred b))) in (fix (< c = (0 "boy") > as C)))
(fix (fix (let c = (if 2 then (if c then a else c) else 0) in (iszero 2))))
({ d = (({ e = unit , b = unit }) . a) , e = (pred (case (iszero 1) of < d = b > => (< c = true > as A) | < c = c > => ((c . a) . c))) })
({ e = (succ (if (succ (fix unit)) then (if (let e = "apple" in 2) then (b as Bool) else false) else (case 1 of < e = c > => true | < d = b > => a))) , d = (fix (if true then "boy" else (a b))) })
(((iszero ({ d = true , a = ({ e = c , b = 0 }) })) . d) (< c = (\ c : (< e : B , b : Unit >) . (succ (iszero "boy"))) > as (Rec A . String)))
({ a = ({ a = (if (fix "apple") then (case 2 of < d = b > => "boy" | < b = d > => false) else unit) , b = ({ c = unit , a = "apple" }) }) , e = (let c = (true . c) in ({ d = true , a = true })) })
(((case (0 c) of < b = d > => "boy" | < a = c > => "boy") (if (iszero c) then (if true then "boy" else "boy") else "apple")) ((succ (if 2 then "apple" else 2)) (fix (\ e : (Bool -> C) . (fix false)))))
(iszero (iszero (pred (fix false))))
(\ e : (Rec B . ((Rec C . Float) -> ({ c : A , a : Nat }))) . (pred (a . d)))
(case ({ b = (case false of < c = b > => 1 | < a = c > => "boy") , c = ({ d = unit , c = b }) }) of < c = e > => (pred (fix 1)) | < d = e > => ((succ (case c of < b = d > => 2 | < e = d > => 2)) . d))
(case (fix (< c = b > as Bool)) of < b = c > => (case (< e = 0 > as C) of < d = d > => (\ d : (Bool -> B) . "boy") | < c = c > => (let c = unit in "apple")) | < d = b > => (pred (((\ b : Unit . a) . d) (c as Nat))))
(< a = (((case a of < c = d > => c | < a = a > => 0) . a) . a) > as (< c : ({ a : (< a : String , a : Float >) , a : (C -> Bool) }) , c : (< b : Bool , c : Float >) >))
(case (< e = (\ e : Unit . b) > as ({ c : Bool , e : Bool })) of < c = a > => (if (let e = unit in "boy") then ({ c = 1 , b = false }) else (case ("apple" . d) of < b = b > => (c . d) | < a = a > => (a . a))) | < b = d > => (iszero (false as Unit)))
((fix ((pred a) as (A -> String))) as (< d : ({ c : ({ d : Unit , e : A }) , b : (String -> C) }) , b : ({ c : ({ a : Nat , e : C }) , c : String }) >))
(fix (let d = (iszero c) in (case "apple" of < b = a > => 0 | < e = c > => (\ d : Unit . b))))
(pred (\ c : ({ e : C , d : Unit }) . (unit . b)))
(((< d = c > as Bool) as (< c : C , c : (Rec A . Nat) >)) . b)
(\ a : ({ c : (< c : (Rec C . Unit) , b : (B -> A) >) , b : (< c : (Unit -> Nat) , d : ({ d : B , c : Float }) >) }) . (succ (if ((succ a) . c) then ({ a = "boy" , d = false }) else (succ "boy"))))
((succ (if false then true else 0)) ((succ false) . e))
(if (succ (succ (pred c))) then (({ d = unit , c = a }) ({ c = (if b then true else "apple") , b = (false unit) })) else ((case 0 of < b = a > => "apple" | < c = e > => 1) (true as Nat)))
(let d = (iszero (if (fix 1) then 0 else 0)) in (let b = (pred 2) in (fix false)))
((pred (a . c)) as ((({ e : Nat , e : B }) -> (Nat -> Bool)) -> (Rec A . (Rec E . Unit))))
(let b = ((let d = false in unit) . b) in (fix ({ d = unit , b = 0 })))
(fix (\ e : (< b : Nat , a : A >) . ((if "apple" then 2 else 2) . e)))
({ e = ({ c = (< e = (let b = 0 in true) > as ({ e : (C -> Float) , b : C })) , d = ((iszero "apple") as ({ d : A , d : C })) }) , c = (succ (case a of < d = e > => unit | < a = a > => "boy")) })
({ d = (\ e : (Rec D . ({ b : Bool , e : C })) . (< e = c > as (String -> A))) , e = (((case a of < d = c > => (c . e) | < e = b > => 2) (< d = false > as (Rec B . B))) as (Rec C . ({ c : (< e : Nat , b : A >) , b : Unit }))) })
(\ e : (< b : (B -> Float) , e : ((Float -> Float) -> (Float -> String)) >) . (let e = (\ c : Float . (if "boy" then "boy" else false)) in (if true then ({ d = 2 , b = "apple" }) else (pred 2))))
(({ d = (fix (fix c)) , b = (fix a) }) as (Rec B . (String -> C)))
(\ a : ({ e : (Rec A . A) , a : (Rec C . ({ e : Float , e : B })) }) . (if (\ c : Float . b) then ((if "apple" then false else 1) as (Nat -> String)) else (case "boy" of < b = a > => "boy" | < a = c > => b)))
(succ (if (if (let e = "apple" in c) then (pred c) else ("apple" as B)) then ({ a = ("boy" . d) , b = b }) else (pred ({ a = true , a = c }))))
(let b = ({ b = (succ (< c = "boy" > as String)) , b = (< c = (\ d : Float . "apple") > as (Rec D . B)) }) in ((unit . d) (false as B)))
(< b = (((pred "apple") (< d = unit > as Bool)) . a) > as (Rec C . ({ e : Nat , e : B })))
(\ d : ({ c : (Rec A . (Rec B . Unit)) , b : (Float -> Bool) }) . (pred (< a = (succ 1) > as ({ b : Nat , e : Nat }))))
((({ c = (succ b) , a = 1 }) ({ b = "boy" , e = 1 })) . d)
((\ a : (< b : Bool , d : (Bool -> Float) >) . (\ c : Float . "apple")) as (Rec E . ({ b : Nat , c : Float })))
(pred (\ d : (< a : (Rec E . Unit) , d : (A -> String) >) . (case (\ c : C . "apple") of < e = b > => (pred (a . a)) | < b = a > => (fix (< d = 1 > as Float)))))
((\ a : ({ e : Unit , b : String }) . (succ (fix "boy"))) ((\ c : Nat . c) . a))
(\ e : (Rec E . ({ c : C , c : Float })) . (fix (fix (true as Bool))))
(succ (pred ((if (< b = unit > as Bool) then (\ c : Nat . "boy") else "apple") as (< e : Bool , d : Float >))))
((if (fix (iszero c)) then (iszero true) else ({ c = (pred false) , b = (case a of < a = c > => 1 | < a = d > => true) })) (fix (fix (\ a : C . "boy"))))
(iszero (case (succ a) of < c = e > => (c "boy") | < e = a > => (case 2 of < a = d > => (< b = unit > as String) | < e = d > => (fix true))))
(case (iszero (let e = true in unit)) of < b = a > => (case (b as C) of < b = a > => (\ d : Nat . 2) | < e = e > => (2 as A)) | < b = d > => (if (b as Nat) then (pred a) else (\ d : Bool . "apple")))
(succ ({ d = (case "boy" of < b = a > => 2 | < b = b > => b) , b = (case (fix 0) of < d = c > => (case a of < c = e > => false | < b = e > => 1) | < d = a > => (succ 2)) }))
((fix ({ e = unit , a = 2 })) as ((< d : Unit , c : (< c : Float , a : Float >) >) -> (Rec E . Float)))
((let e = (let a = (< e = ({ c = unit , e = c }) > as C) in (pred false)) in (succ ("apple" as B))) as ((< e : Float , b : A >) -> ({ d : String , a : B })))
((< e = (case a of < b = c > => (succ unit) | < c = e > => c) > as (Rec B . ((< c : Float , d : B >) -> (Rec D . Nat)))) as (Rec D . ((< c : Unit , d : C >) -> (Rec B . Unit))))
(< d = (< b = (let c = a in true) > as ((Rec C . (Rec C . Bool)) -> (Rec A . ({ e : C , a : Unit })))) > as ((< b : Bool , a : A >) -> (< e : A , d : Nat >)))
(let d = (pred (unit as Bool)) in ((succ (if "apple" then c else 1)) . b))
({ b = (case (if false then "apple" else (b true)) of < b = a > => (pred 0) | < c = a > => (case (fix ({ b = unit , d = 2 })) of < d = d > => (pred 1) | < b = b > => (a as String))) , d = ({ e = (case ((< e = a > as Bool) . e) of < c = c > => (a b) | < a = b > => (iszero b)) , b = (fix (unit as Bool)) }) })
(((succ true) as (< e : Bool , a : Float >)) as (< a : (Rec E . String) , d : (Rec C . ({ c : Bool , d : String })) >))
(\ c : (Rec E . ({ b : B , e : String })) . (\ e : (A -> Float) . (false . b)))
(let d = (< d = (fix 2) > as ({ b : Nat , c : Nat })) in (< e = (case (< c = false > as B) of < c = c > => (if a then a else a) | < a = b > => ("apple" as (Nat -> String))) > as ((Rec E . Nat) -> (< c : Unit , c : Unit >))))
(succ (< b = ((if unit then "boy" else true) . d) > as (< e : (Rec E . C) , e : (< b : String , d : ({ a : Unit , c : Unit }) >) >)))
(case (< b = ((case false of < e = a > => 2 | < c = d > => true) as ({ d : Bool , a : A })) > as ({ b : ({ b : C , d : A }) , c : (Rec C . (C -> Float)) })) of < c = e > => ((if (2 false) then (if unit then (case 2 of < a = c > => c | < b = b > => false) else true) else (let a = (1 a) in "apple")) . d) | < e = b > => (((b 0) as (Float -> String)) ((if a then a else b) (< d = 2 > as String))))
(({ e = (pred 0) , a = (b . d) }) (fix (case ((if c then 0 else 0) . a) of < d = a > => (unit c) | < a = d > => (pred 0))))
(case (if (a . c) then ({ c = (< c = 0 > as Bool) , c = (false . b) }) else (iszero ({ a = 2 , c = b }))) of < b = a > => (pred ({ e = ({ e = unit , d = "apple" }) , c = (false as (C -> Unit)) })) | < c = d > => (succ (false a)))
({ c = (pred (< d = (if b then false else a) > as Unit)) , d = (\ a : ({ e : Float , c : Bool }) . (b false)) })
(< c = ({ e = (pred unit) , e = (iszero false) }) > as ({ e : (< b : (< b : Bool , c : C >) , e : Bool >) , d : (Rec E . (< d : B , a : Unit >)) }))
(let c = ((succ (if 1 then c else a)) . e) in (iszero (({ a = false , c = true }) . c)))
(let d = (succ (pred (false . c))) in (({ d = b , c = 0 }) ({ e = 0 , d = b })))
((fix ((succ "boy") as (Rec D . Unit))) (< c = (unit "boy") > as ({ d : (< a : B , b : Bool >) , b : (Nat -> C) })))
(\ b : (< c : (Rec C . A) , e : (< b : (Rec D . ({ c : B , d : B })) , d : ({ e : B , c : (Rec A . Nat) }) >) >) . (< e = (case (iszero unit) of < b = b > => (< d = a > as C) | < a = a > => (case "apple" of < d = c > => "apple" | < a = e > => a)) > as ({ c : (C -> String) , b : (< c : Bool , b : Nat >) })))
(case (({ e = 1 , d = false }) . b) of < d = a > => ((iszero (fix (iszero unit))) as ({ b : (Float -> (Rec C . C)) , a : (< d : Bool , c : Unit >) })) | < d = b > => ((fix 2) (\ e : (< c : A , b : String >) . (fix c))))
(case ({ b = (pred 2) , d = (\ d : Unit . c) }) of < b = e > => ((let e = false in false) as ({ c : Float , d : String })) | < b = b > => (case (c as A) of < d = b > => (case 0 of < a = b > => false | < c = c > => (< c = "apple" > as Nat)) | < d = d > => (1 as String)))
(\ b : ({ b : ({ c : Float , d : Unit }) , e : ({ a : (< a : Nat , c : Float >) , e : (B -> String) }) }) . ((case ("apple" 2) of < b = d > => (\ a : Float . "apple") | < c = c > => "apple") . d))
(\ d : ({ a : (Rec B . ({ c : Nat , a : Bool })) , a : (Rec E . (< d : C , d : B >)) }) . (\ d : ({ c : String , c : Float }) . ({ b = b , d = (iszero 1) })))
(pred ({ a = (iszero unit) , c = (if 1 then (b c) else (\ c : String . 1)) }))
(< c = ((let e = (iszero a) in (if 2 then true else 1)) as (< b : A , e : B >)) > as ({ e : (Float -> ({ e : Float , d : Unit })) , e : (Float -> (Float -> Nat)) }))
(if (iszero (< c = false > as Nat)) then ((pred (case ("apple" as Nat) of < e = d > => "apple" | < e = a > => "boy")) as (< a : String , b : (Rec D . Unit) >)) else ((let e = (succ "apple") in ({ a = c , a = 0 })) as (< b : (< c : B , c : Bool >) , a : (B -> Nat) >)))
((let a = (if (b false) then (succ 2) else unit) in (if (case a of < b = d > => true | < b = e > => c) then (if "apple" then "boy" else unit) else (2 as B))) . d)
((succ ({ b = (\ a : C . b) , e = ("apple" as C) })) . e)
(fix ((pred 1) (case unit of < b = d > => b | < e = d > => (pred c))))
(< b = (fix (case (b 0) of < b = a > => ((iszero "boy") . a) | < d = e > => (pred 0))) > as ({ a : ({ b : (String -> Float) , b : A }) , c : ({ e : Float , b : C }) }))
(\ a : ((A -> A) -> ({ c : (Float -> C) , d : B })) . (case (let e = unit in 0) of < d = b > => (succ "boy") | < a = c > => (\ d : ({ b : Nat , e : B }) . (\ c : Float . true))))
(\ d : ((< c : (Unit -> String) , a : (Rec D . Nat) >) -> (< b : (Rec C . Nat) , a : Float >)) . (\ a : ({ d : C , a : (String -> C) }) . (case false of < e = b > => unit | < d = b > => c)))
(let a = ((\ a : (< c : String , a : (Rec E . Nat) >) . (if "apple" then c else unit)) (pred (1 . e))) in (let c = (\ a : (Rec D . A) . (< b = (< a = 0 > as Bool) > as (< d : C , b : C >))) in ((case b of < d = c > => 0 | < e = c > => c) . a)))
(fix (((iszero true) . b) . e))
({ a = ((iszero b) (pred (iszero "boy"))) , a = ((pred true) (\ d : ({ a : Float , c : String }) . ({ d = 1 , a = true }))) })
(iszero (fix (fix c)))
(\ c : ((({ a : B , a : A }) -> (Float -> Float)) -> (< d : (String -> C) , d : ({ b : A , e : String }) >)) . (succ (case a of < c = b > => 1 | < e = b > => "boy")))
(\ e : ((Rec C . ({ c : Unit , b : (B -> Bool) })) -> (< d : (Rec B . B) , d : Nat >)) . ((case true of < e = e > => ({ b = c , b = b }) | < d = e > => false) (let b = 2 in a)))
(iszero (succ ("apple" . b)))
(((< c = 1 > as C) as (Rec E . (Nat -> B))) as (< b : (Nat -> (< c : C , a : B >)) , d : (String -> (< d : Unit , e : B >)) >))
((fix (< a = unit > as Unit)) (\ a : (< c : String , d : Unit >) . (case 2 of < e = a > => "boy" | < d = c > => unit)))
(iszero (case ((case 0 of < a = a > => a | < a = e > => unit) as Unit) of < e = b > => (succ false) | < b = c > => (< c = "boy" > as (Nat -> B))))
(\ b : ((< c : A , b : Bool >) -> (< a : (< b : Float , b : Bool >) , a : A >)) . (pred (\ d : A . false)))
((case (< b = (0 . e) > as Float) of < a = e > => ("boy" as A) | < d = b > => ({ c = unit , b = "apple" })) ((\ c : Bool . (if 1 then 1 else 2)) (a false)))
(fix (< c = (if (let d = b in 2) then (if (if b then 2 else 1) then (pred true) else unit) else (c as Bool)) > as ((< b : (B -> C) , e : (Bool -> B) >) -> ((Rec B . Nat) -> Bool))))
((case (2 as String) of < e = d > => (succ b) | < e = c > => (fix (b . e))) ((case a of < b = b > => b | < a = e > => ({ a = unit , a = "apple" })) . b))
({ a = (fix (\ a : ({ b : A , b : C }) . "apple")) , b = (succ (if "boy" then 0 else 2)) })
({ d = (let e = (true 0) in ((0 "boy") (fix b))) , d = (if (case (< e = 0 > as (< c : Nat , e : String >)) of < c = a > => (b as Unit) | < c = e > => (0 "boy")) then (if ((c "apple") a) then (case a of < d = e > => 2 | < b = b > => unit) else (case 1 of < e = a > => (case "boy" of < e = a > => true | < e = c > => b) | < a = c > => (< c = true > as Float))) else ((true 2) . d)) })
((pred (< e = ("apple" . b) > as (Float -> A))) . d)
(case (fix (let b = unit in unit)) of < a = c > => (case (fix ((0 . a) (c . b))) of < b = e > => ((iszero 1) (case a of < a = d > => c | < c = b > => unit)) | < c = c > => (< b = (fix a) > as Unit)) | < c = d > => ((({ d = unit , e = (pred "apple") }) . c) . c))
((if (succ b) then (fix (a false)) else ({ b = true , e = unit })) (< d = (succ 2) > as ({ e : (Unit -> A) , d : Float })))
({ d = (fix (pred b)) , d = (\ a : ({ e : (Nat -> Unit) , a : Unit }) . (succ (true . e))) })
(< e = (succ (iszero (let c = "apple" in a))) > as ({ d : (< b : Float , a : Bool >) , b : (Nat -> B) }))
(succ (({ a = true , b = b }) (let e = (false as Unit) in (succ (c as String)))))
(((let d = b in 0) as (< b : ({ a : Unit , a : Unit }) , e : B >)) . d)
((let e = (pred 0) in (< e = c > as Float)) (pred (pred false)))
(iszero (case (pred b) of < e = c > => ("boy" . c) | < a = b > => (pred (succ false))))
((iszero (((pred 1) . a) . b)) (if (if (1 b) then (succ 2) else ({ e = (if 0 then c else c) , c = (if b then true else 1) })) then (< c = (pred "apple") > as Float) else (let a = (unit unit) in 1)))
(succ (if (iszero (case 1 of < a = e > => 1 | < c = b > => true)) then (case (\ d : Float . 1) of < c = b > => (\ b : A . c) | < d = d > => (fix ({ c = unit , b = a }))) else ({ e = (b false) , c = (c (fix b)) })))
({ d = (if (fix (if 2 then 0 else a)) then (< c = (0 . b) > as (A -> String)) else (case (iszero 0) of < c = d > => ((succ b) ({ e = unit , b = 2 })) | < c = b > => (\ c : Unit . a))) , c = (< d = (< b = a > as Bool) > as (Rec E . (Rec A . Unit))) })
((\ a : (B -> A) . (if 2 then false else b)) as (Rec D . (Rec B . (Rec D . B))))
(< a = (succ ((c as Unit) (unit as B))) > as ({ b : (Rec E . (Bool -> Unit)) , a : (Rec B . Nat) }))
(pred (iszero (a . e)))
(if (let d = (if (case "apple" of < b = e > => 2 | < a = c > => true) then ("apple" true) else (< b = unit > as (< e : Bool , e : Bool >))) in (if (< b = 2 > as C) then (if a then a else 2) else (< c = false > as Bool))) then ((unit . e) as (Rec C . (Rec C . Bool))) else (\ c : (Rec A . C) . (true . b)))
(fix (\ a : (< d : (Rec B . A) , b : (< c : B , b : Unit >) >) . (pred 0)))
(\ e : (< a : ((Rec D . Nat) -> A) , d : (({ b : Unit , c : A }) -> ({ d : (< d : Unit , a : C >) , d : C })) >) . (({ a = (succ b) , b = (case true of < e = d > => (let c = false in unit) | < e = d > => (2 . c)) }) . d))
(iszero (fix (succ "apple")))
(iszero ((succ (succ true)) (iszero a)))
(({ c = (b "apple") , e = ({ d = (succ true) , b = (\ a : (Rec D . Float) . b) }) }) as (< b : ((Rec D . Float) -> String) , e : (C -> C) >))
(if ((\ a : Float . unit) . a) then ((succ ((case true of < b = a > => "apple" | < b = d > => true) as A)) . e) else (iszero (< e = (< e = unit > as C) > as (Rec A . Nat))))
(((pred 0) . a) . d)
({ b = ({ e = (< b = unit > as C) , a = (succ a) }) , b = (\ c : (< d : A , c : B >) . (unit (iszero "apple"))) })
(let d = (case (succ ("apple" . e)) of < c = a > => ("boy" . e) | < d = b > => (false . e)) in ({ c = (case c of < d = b > => 2 | < a = b > => true) , e = (case "boy" of < d = d > => b | < a = b > => "boy") }))
(\ a : (Rec D . (< d : Float , a : B >)) . (< e = (case ({ b = "boy" , d = 1 }) of < e = b > => (let e = b in "apple") | < c = a > => a) > as (C -> C)))
(\ d : (< c : (< e : (Rec B . C) , b : (Rec D . A) >) , c : ({ c : Float , d : Nat }) >) . (pred (\ a : (Float -> Float) . ({ b = (iszero b) , e = c }))))
(pred (iszero (fix 1)))
(fix (\ a : (Rec D . A) . (pred 1)))
((succ (iszero (case (< b = 0 > as C) of < a = e > => a | < d = d > => c))) as (Rec A . (Rec B . ({ c : Unit , e : B }))))
(succ (((iszero "boy") . a) . d))
(pred (({ c = c , a = c }) (case c of < b = c > => false | < a = c > => "boy")))
(pred ((\ a : Nat . 0) ({ c = 2 , d = b })))
(< b = ({ e = ((pred "boy") . b) , c = (pred (\ c : C . b)) }) > as ((< e : Bool , e : B >) -> (< e : Bool , b : ({ b : C , a : C }) >)))
(< c = (< b = (pred 0) > as ((Rec E . A) -> ({ b : Bool , a : Bool }))) > as (< b : (< a : (< e : Unit , c : A >) , e : (Unit -> Unit) >) , e : ({ d : (A -> Float) , c : ({ e : C , a : A }) }) >))
(\ b : ({ e : ({ c : (Rec A . B) , b : ({ b : String , b : C }) }) , d : (Rec E . C) }) . (case (iszero 0) of < c = b > => (pred c) | < e = b > => ({ b = true , a = 2 })))
(case (case (succ (pred 1)) of < e = d > => ({ d = c , b = 1 }) | < e = d > => ("apple" 0)) of < a = c > => (case (pred c) of < e = e > => (let a = (succ 2) in (0 as Bool)) | < b = d > => (< d = (false false) > as ({ d : (< a : B , e : String >) , e : Float }))) | < d = d > => ((let e = (c a) in 1) . d))
(\ e : ((Rec B . Nat) -> ({ c : Unit , e : Unit })) . (fix (case "apple" of < c = c > => 0 | < d = d > => (iszero "boy"))))
(case (pred (< c = (false as Bool) > as ({ c : (Rec E . A) , c : ({ a : String , b : B }) }))) of < a = a > => (if (succ (iszero c)) then (pred true) else (fix (if unit then b else "apple"))) | < c = d > => ((case (< a = 1 > as Float) of < a = a > => "boy" | < d = b > => (succ 2)) . e))
(iszero (succ ((iszero 2) as B)))
(pred ({ b = (\ a : (Nat -> Float) . ({ b = c , c = c })) , e = (0 b) }))
(< c = (fix (succ 2)) > as (Rec B . (< d : (< b : ({ d : Nat , a : C }) , a : (Rec E . A) >) , a : (Rec C . Float) >)))
(if (case ((fix false) (\ e : Float . "boy")) of < e = a > => (succ "boy") | < e = b > => (succ unit)) then (let e = (let a = 1 in (pred 1)) in (fix a)) else (case (iszero (1 . c)) of < e = d > => ((pred true) as (Rec A . String)) | < d = a > => (if ("apple" c) then (case false of < b = c > => a | < e = c > => true) else 0)))
(pred (case (succ ("apple" . c)) of < c = d > => (pred (iszero a)) | < d = a > => (let e = ({ a = "boy" , b = a }) in a)))
(fix (({ c = (< c = true > as Unit) , a = (case (if 1 then b else b) of < c = a > => ({ a = false , b = c }) | < c = d > => (true . b)) }) as ({ b : ({ d : String , a : C }) , d : ({ b : Float , c : Nat }) })))
(((pred true) . b) . d)
(pred (succ (succ a)))
(case (({ e = (if unit then c else (iszero 1)) , a = (pred 0) }) (pred ("boy" . c))) of < b = c > => (fix (let c = (iszero unit) in b)) | < e = b > => (\ b : (Rec A . C) . (pred 2)))
(let a = (pred (c . e)) in (let e = (({ b = a , e = (< b = b > as B) }) (let c = 1 in "apple")) in (pred ("boy" . e))))
((succ (2 . d)) ((case 2 of < c = d > => c | < b = c > => unit) (iszero (succ 2))))
((case (fix (< c = c > as Nat)) of < b = c > => (succ ({ d = (fix "boy") , c = (fix unit) })) | < d = d > => (pred true)) as (< c : (< d : (A -> String) , a : (A -> Float) >) , b : (< b : Nat , a : Nat >) >))
(if ((iszero (\ a : Float . ("boy" as String))) as (< d : Nat , b : ({ e : Unit , e : Bool }) >)) then (case (iszero unit) of < d = c > => ({ b = a , c = true }) | < d = d > => (let d = (succ b) in (succ false))) else ((let e = (let b = ("apple" as String) in "apple") in (case "apple" of < d = e > => false | < e = e > => 0)) as (Rec D . (Rec D . Unit))))
(< d = ((\ d : (< b : B , c : B >) . true) as (< c : Nat , a : A >)) > as (< c : (Rec A . (Rec B . A)) , c : ({ b : ({ c : Float , a : B }) , d : ({ e : (< a : String , e : Bool >) , c : (< a : Nat , b : String >) }) }) >))
(fix (iszero (1 as A)))
(pred (< c = (let a = (0 as Float) in b) > as (< e : (Bool -> Nat) , d : (< c : ({ e : A , a : String }) , c : Nat >) >)))
((\ a : ((A -> Unit) -> (< d : B , c : C >)) . (true as Unit)) as (Rec A . ({ a : (Rec B . Nat) , b : (< b : Float , b : Nat >) })))
(< d = (case (succ c) of < a = c > => (\ b : (Rec A . A) . (b as B)) | < a = a > => ((succ c) . e)) > as (< c : (< c : B , b : A >) , e : (Nat -> Nat) >))
(let d = (case (({ a = 0 , b = false }) . c) of < e = b > => (0 as A) | < e = a > => (iszero false)) in (((iszero true) as (< d : Float , b : Unit >)) (pred a)))
(fix (< d = (\ c : (Rec A . C) . (true as A)) > as (Rec E . Float)))
(\ c : (< c : ({ b : (A -> C) , d : (Rec C . Float) }) , d : ((< b : A , d : B >) -> ({ a : Unit , a : Float })) >) . (("apple" true) . a))
(< a = ((< d = a > as (Rec E . Nat)) . c) > as ({ e : ((Rec D . String) -> Unit) , c : (Rec D . ({ c : Unit , d : Unit })) }))
(< a = (fix (pred false)) > as (< b : (Rec B . A) , a : ({ a : Bool , d : ({ e : Unit , b : Unit }) }) >))
(case (< a = (< b = (pred true) > as Float) > as ((Rec B . Unit) -> (< d : (< c : C , b : A >) , e : (Rec D . Unit) >))) of < e = c > => (pred (< d = ({ e = 0 , a = unit }) > as (String -> ({ d : Unit , a : Float })))) | < e = a > => (("apple" . c) (pred "apple")))
(< a = (< e = (< a = b > as Bool) > as (Rec C . ({ d : Float , e : String }))) > as ((< e : C , a : String >) -> (< e : (Rec D . B) , a : (Rec A . B) >)))
((case (\ e : String . (c 0)) of < c = a > => ({ d = true , a = (case "apple" of < a = a > => unit | < e = c > => 2) }) | < d = a > => (0 "apple")) as (< c : (Rec C . ((Nat -> Bool) -> A)) , c : (Rec A . ({ b : Unit , c : Float })) >))
(iszero ({ b = (if (\ e : String . (let e = "boy" in a)) then (false . b) else (\ b : (< b : Unit , a : String >) . (fix c))) , b = (pred (iszero b)) }))
((succ (fix (\ d : Float . b))) as (({ d : (Rec E . C) , a : Nat }) -> (Nat -> (< d : B , c : Float >))))
(pred ((case a of < d = b > => a | < c = c > => (if 1 then c else a)) . c))
({ d = (((\ c : B . false) (succ false)) . a) , b = (fix (< a = 1 > as ({ e : String , b : Bool }))) })
(case ((let d = "apple" in (iszero 0)) (fix (if ({ c = unit , e = a }) then (unit as Nat) else 0))) of < a = c > => (< a = (case (pred 1) of < c = d > => (succ false) | < e = e > => 1) > as ({ a : (< c : A , b : Nat >) , a : (< e : (Rec E . C) , e : (< c : C , d : A >) >) })) | < c = a > => ((case (iszero true) of < c = e > => (case true of < a = a > => false | < a = b > => 1) | < a = c > => (if "boy" then b else 1)) (iszero (succ "apple"))))
((case (\ e : B . "apple") of < e = d > => (pred 2) | < e = b > => (if b then 0 else "apple")) . e)
(case (< b = ({ d = (case c of < b = d > => (pred "boy") | < c = c > => true) , d = (pred (if 2 then b else 2)) }) > as (< a : (< a : (Rec E . Float) , c : Float >) , a : (Rec E . C) >)) of < e = c > => (\ e : ({ c : A , b : String }) . ((succ "apple") as ({ b : Float , c : C }))) | < b = a > => ((let a = true in ({ d = "boy" , c = b })) . d))
({ a = (iszero (pred unit)) , e = (fix (((b as Float) . b) ({ c = "boy" , a = "apple" }))) })
((if (0 as C) then ({ d = ({ c = "boy" , e = unit }) , b = (case c of < a = c > => 2 | < e = e > => "boy") }) else ((if b then "apple" else 2) . d)) . b)
((pred (succ ({ c = (iszero false) , e = "apple" }))) (succ ({ e = (< b = 1 > as Bool) , d = (false as Bool) })))
((((pred 2) as ({ b : Nat , a : Nat })) as (Rec E . Bool)) (< e = (if "boy" then (\ d : A . true) else unit) > as (Rec E . Bool)))
(let c = (\ a : ({ a : (({ c : String , a : Unit }) -> A) , d : (< e : (String -> A) , b : (< d : Nat , d : Nat >) >) }) . ((let c = (case false of < e = e > => "boy" | < b = c > => 1) in (true as Float)) . d)) in (pred (iszero (< b = "boy" > as String))))
(\ d : (< d : ((< c : String , d : A >) -> ({ d : Bool , d : Bool })) , e : (< a : ({ a : (Rec A . Float) , d : (A -> B) }) , e : (< e : Float , b : B >) >) >) . (\ d : (Rec E . Float) . (iszero b)))
(< d = ((case ({ a = unit , e = 0 }) of < a = e > => "boy" | < d = e > => 0) . e) > as (Rec C . ({ b : (Nat -> Nat) , b : (Rec A . Float) })))
(pred ((("boy" . d) . c) . d))
((((fix 0) as (Rec D . Nat)) (unit 2)) . b)
((fix ((iszero a) (if "boy" then unit else "apple"))) (let a = (iszero (< a = "boy" > as A)) in ({ d = ({ c = c , e = 1 }) , a = (fix b) })))
(({ c = (if true then 2 else 1) , c = ((iszero unit) . e) }) (let b = (unit (a as Float)) in (< e = (fix true) > as Unit)))
(iszero ((case (false as String) of < a = c > => (succ 2) | < e = b > => ({ a = a , c = true })) . c))
(pred (case ({ d = (iszero 2) , e = (< a = (0 0) > as (C -> String)) }) of < c = a > => ((fix true) (if true then 2 else c)) | < d = d > => (< a = (fix "apple") > as ({ c : C , e : (Nat -> A) }))))
(case ((pred unit) . a) of < e = c > => (if ((\ e : String . c) as ({ c : Unit , c : Unit })) then ({ b = (pred "apple") , a = b }) else (if (fix true) then (if true then 1 else unit) else (unit a))) | < c = d > => (let b = (pred (< a = a > as Unit)) in (\ c : B . "boy")))
(pred (succ (\ a : (Float -> C) . (succ (succ "apple")))))
((case (("apple" as B) as (< b : String , a : B >)) of < b = d > => (iszero (< a = true > as C)) | < c = a > => (pred (let a = true in 1))) . e)
(\ a : ((< a : Unit , c : C >) -> ({ c : ({ c : Nat , e : String }) , d : Unit })) . (\ d : (< e : (< a : (Rec D . Unit) , d : (< e : B , e : Float >) >) , e : ({ e : Bool , a : Bool }) >) . (iszero ("boy" . a))))
(iszero (fix (let b = (let c = "apple" in "apple") in 2)))
(case (((< c = 1 > as A) as (Rec E . ({ a : Nat , b : Float }))) as (< e : C , a : Unit >)) of < d = e > => (\ e : ({ d : ((A -> Unit) -> (< e : String , c : Bool >)) , b : (< d : Bool , e : Unit >) }) . (true (< b = 0 > as A))) | < b = d > => (\ a : (< b : Bool , e : (Rec D . Unit) >) . (if (let d = 0 in "apple") then (case a of < e = a > => 1 | < c = e > => "boy") else (fix 2))))
(\ c : ({ e : (Rec C . ({ a : C , a : A })) , d : ({ b : (Rec E . A) , d : (< a : Float , b : String >) }) }) . (succ (< a = (fix "boy") > as (< c : String , a : Bool >))))
(((let c = "apple" in "apple") . b) as (< d : (< b : Float , d : Float >) , d : (A -> (< d : Float , b : Float >)) >))
((\ d : ({ d : Bool , e : Nat }) . ({ e = 0 , c = "apple" })) (fix ((< c = 1 > as Unit) as (Bool -> B))))
((if (case true of < b = d > => a | < e = b > => false) then (pred (2 as C)) else (case (a . c) of < d = a > => 2 | < d = a > => c)) . b)
(fix (< c = ((pred unit) . c) > as (Rec D . (Rec E . Nat))))
((iszero (succ (\ d : C . a))) . e)
(succ (if (< e = a > as Bool) then (case true of < b = e > => true | < a = c > => false) else (fix "apple")))
(iszero (< e = (pred 0) > as ((< c : Bool , a : String >) -> Bool)))
(succ (\ e : (Rec D . String) . (\ a : ({ c : Unit , d : String }) . (a false))))
((iszero ({ a = 0 , b = c })) . b)
(pred ((case c of < d = c > => a | < c = e > => b) as (Rec C . Float)))
(pred (fix (succ ((succ 0) as ({ c : C , c : A })))))
((if (case (let c = false in 1) of < a = c > => (\ e : Bool . true) | < d = b > => c) then (fix ("boy" 1)) else (pred (1 as Unit))) as (Rec E . (Rec C . Bool)))
(let c = (iszero (if (c "apple") then (succ 0) else (iszero b))) in (case (succ (2 . c)) of < e = d > => ({ b = (let e = a in a) , c = (let b = "apple" in "boy") }) | < b = b > => (iszero 1)))
(succ (\ c : (< c : B , b : Nat >) . ({ b = (iszero (iszero true)) , b = ("apple" b) })))
(succ ({ b = ((fix (let a = "boy" in 1)) (succ c)) , d = (let e = (0 as String) in (case c of < d = d > => a | < d = b > => b)) }))
((if (if (iszero a) then (case (1 unit) of < a = c > => 0 | < a = b > => (if false then true else 2)) else (c . a)) then ((succ true) as Nat) else (let b = (pred 1) in (let e = "apple" in unit))) (pred (case (if 0 then b else "apple") of < e = e > => true | < a = e > => (case 0 of < c = e > => "boy" | < c = b > => unit))))
((\ e : (Rec E . (< d : Unit , e : A >)) . (pred ({ b = c , c = c }))) . e)
(((succ c) as (({ e : (Rec D . C) , c : ({ e : String , b : String }) }) -> (Rec D . Float))) (\ b : ({ d : (< b : A , c : Unit >) , e : Unit }) . (1 as C)))
(case (\ c : ({ e : (< b : Unit , c : A >) , a : (Rec A . Unit) }) . (c (pred 1))) of < b = d > => (({ d = (fix false) , e = (a as C) }) as ({ e : Nat , e : C })) | < e = e > => ((succ true) as (< b : (< a : Nat , e : String >) , a : Unit >)))
(< d = ({ b = (iszero ({ d = 2 , c = a })) , e = (\ e : A . true) }) > as (({ b : (Nat -> Float) , a : A }) -> (Rec B . (Rec B . Unit))))
(case (< c = ((succ c) . b) > as ({ e : (Rec A . Nat) , d : (Unit -> A) })) of < d = a > => ({ e = (< d = false > as Nat) , e = ((succ 1) . e) }) | < c = d > => (\ d : (String -> ({ b : B , a : C })) . (if (if false then unit else 0) then (2 ({ c = true , c = c })) else (< c = (0 true) > as (Bool -> A)))))
(let e = ((\ c : (< a : (Bool -> Unit) , a : (< c : Nat , d : String >) >) . ("apple" as Nat)) ((2 1) (pred c))) in ((case "boy" of < b = e > => 0 | < c = d > => b) . b))
({ d = ((\ e : ({ a : C , e : B }) . (< e = "boy" > as C)) (case false of < c = e > => "boy" | < c = a > => true)) , b = (if (case 2 of < e = a > => c | < b = e > => unit) then (if c then ({ b = "boy" , e = a }) else "apple") else (succ "boy")) })
(pred ((< e = b > as (Rec B . Unit)) ({ a = true , d = (if "boy" then false else "apple") })))
(< b = (((\ b : Bool . false) as C) as (< d : ({ c : B , d : B }) , c : (< b : (Bool -> A) , a : (Rec D . Nat) >) >)) > as ({ a : ({ b : Nat , a : Bool }) , e : (< d : Unit , c : (< b : A , c : B >) >) }))
(((< a = (pred false) > as (Rec A . ({ d : Unit , c : C }))) (fix (< b = true > as String))) as (< d : (Rec D . (< c : Float , e : Nat >)) , b : (Rec C . B) >))
(iszero ((b . a) ({ a = 2 , d = false })))
(succ (succ (fix (\ c : (< b : C , d : A >) . (fix "boy")))))
(if (fix ((\ e : (Unit -> B) . (succ true)) (2 as Float))) then (case ((pred false) . c) of < c = c > => (< e = "boy" > as (Rec D . Unit)) | < c = a > => (iszero ({ d = (pred unit) , e = unit }))) else ((let b = (succ "boy") in (< b = 2 > as A)) ("boy" . e)))
(if (fix (fix 1)) then (let d = (if (case unit of < c = a > => "boy" | < b = a > => unit) then (iszero 1) else ({ c = 1 , b = unit })) in ((\ e : A . 1) . b)) else (((iszero a) as (< a : String , c : C >)) . c))
(case ((\ b : Unit . (case "boy" of < b = b > => false | < e = d > => a)) (a . d)) of < a = e > => (let b = (if "apple" then "apple" else 1) in (succ true)) | < e = b > => ((succ (if 0 then "boy" else false)) as (Bool -> B)))
(iszero (if (a as Nat) then (b (fix unit)) else (if 0 then (\ e : String . "apple") else ("apple" 0))))
((if (< d = (\ c : A . "boy") > as Bool) then (if (pred "apple") then a else "apple") else (< c = (c . d) > as (< d : C , c : A >))) (if (("boy" . e) (2 a)) then ({ b = (c as String) , b = (if (2 as Float) then ({ c = "boy" , a = c }) else false) }) else (true ({ c = 1 , a = "apple" }))))
((iszero (fix unit)) (fix (pred c)))
(((succ (fix 1)) (let b = (succ "boy") in (c false))) . c)
(succ ((if "apple" then 2 else "boy") as (< e : C , a : Float >)))
(succ ((let a = "boy" in "apple") as (< e : B , a : Float >)))
({ a = (((case 2 of < d = d > => false | < d = b > => a) as C) . d) , e = (< c = (iszero (pred "apple")) > as (Rec A . B)) })
(iszero (< b = (a . a) > as (C -> Nat)))
((succ (\ c : String . false)) (fix (case 0 of < d = e > => (\ e : Nat . 1) | < a = c > => "boy")))
(if (if (pred (< d = a > as B)) then (< c = (fix true) > as ({ a : (< e : C , d : Unit >) , c : ({ b : Nat , d : Bool }) })) else (pred (1 . c))) then ({ b = (case unit of < d = b > => (if 2 then "boy" else a) | < d = b > => b) , a = (((true . b) (let c = unit in b)) as (< d : C , c : C >)) }) else (("apple" . b) as ({ a : String , b : ({ d : B , c : C }) })))
(\ d : ({ e : (Rec C . ({ c : Unit , a : A })) , c : (Unit -> String) }) . (\ c : ({ e : (Unit -> (< e : A , c : Bool >)) , b : (Rec E . (< b : Nat , e : Unit >)) }) . (iszero (\ c : C . (succ 1)))))
(((let c = (< b = false > as A) in (iszero 0)) as (< a : (Rec D . Float) , d : (Rec D . (< b : B , a : Nat >)) >)) (fix ("boy" . b)))
(fix (let a = ((pred false) (succ 0)) in (let d = (\ b : (Float -> String) . true) in (succ "boy"))))
((({ c = (\ d : (Bool -> Nat) . (\ d : Nat . true)) , a = (fix false) }) (case (let b = c in true) of < c = c > => ({ a = "boy" , c = 1 }) | < c = a > => true)) . c)
(succ (("boy" as Float) (\ d : A . 1)))
({ e = (< d = (iszero (let b = 0 in 2)) > as ({ b : Nat , a : C })) , c = (case (if (< e = 2 > as B) then c else (succ 2)) of < b = e > => (pred unit) | < c = b > => (succ (succ ({ c = true , c = c })))) })
(case (iszero (< a = c > as String)) of < e = d > => (iszero (if 2 then 2 else "apple")) | < c = a > => (if (succ (c as B)) then (\ d : Bool . "boy") else (\ b : (Rec D . Unit) . (fix (true . c)))))
(pred (iszero (case unit of < a = d > => a | < c = e > => c)))
(succ ((let c = true in "boy") as ({ d : (< b : Float , b : Unit >) , d : (String -> C) })))
(pred (succ (0 as Bool)))
(if (if ((if 2 then true else true) as (< d : Unit , d : Float >)) then (iszero (iszero 1)) else (< c = (iszero true) > as (< b : Nat , a : Bool >))) then (iszero (< d = c > as Unit)) else ((c b) as ((Unit -> Bool) -> (< e : Nat , a : B >))))
(let c = (pred (fix (c as Bool))) in ((pred b) . e))
(let d = (if (let d = (pred a) in (let d = c in 0)) then (< c = a > as A) else (succ true)) in ((fix "apple") (let c = c in (pred a))))
((if (< c = a > as ({ e : Bool , a : Unit })) then (let b = (succ c) in false) else (let d = true in b)) as (< b : (Rec B . B) , b : (Nat -> A) >))
((< c = (case 1 of < c = c > => c | < a = b > => unit) > as ({ a : C , d : (String -> String) })) as (Rec E . ((Rec E . Nat) -> Unit)))
(\ d : (({ a : String , c : (Rec C . String) }) -> (A -> String)) . (fix (({ b = true , d = "boy" }) as (B -> B))))
(\ b : (< c : (Nat -> (String -> Nat)) , b : ({ b : ({ e : A , e : String }) , a : (< b : B , c : A >) }) >) . (pred (succ a)))
(case (fix ({ b = (succ 0) , a = (c as Float) })) of < a = d > => (fix (let e = (succ (c as Float)) in (iszero ({ e = b , b = a })))) | < a = c > => (iszero (\ e : Float . "boy")))
(\ a : (< e : (Rec C . ((< a : Bool , e : Float >) -> ({ e : String , c : A }))) , c : ((Rec E . A) -> ({ b : String , a : Nat })) >) . (case ((< a = a > as A) as ({ d : C , d : B })) of < b = e > => (iszero ("apple" as (Rec D . String))) | < c = e > => (c as Nat)))
((if (fix (< d = false > as Unit)) then (\ a : A . "boy") else ({ c = (1 . a) , d = (case a of < a = b > => 2 | < c = c > => a) })) (let e = ((fix b) . e) in ((2 as Float) (succ "boy"))))
(case ((fix b) . d) of < c = c > => ((case (< a = 0 > as Nat) of < e = e > => (< c = "boy" > as B) | < b = a > => (let e = (< b = c > as C) in (\ a : Unit . 2))) (iszero (iszero (c . d)))) | < b = d > => (if ((false (case b of < e = d > => 2 | < e = b > => 0)) . e) then (\ a : ({ e : ({ d : Bool , e : C }) , a : A }) . ({ a = (a 1) , c = 0 })) else (\ e : ({ a : C , b : A }) . 1)))
(({ a = (succ 0) , d = ((a . e) (let e = b in "boy")) }) (pred (fix "apple")))
((iszero (succ 2)) . c)
(((a (unit "boy")) . a) as ({ b : (Rec B . C) , c : (Nat -> ({ b : Nat , d : C })) }))
(< b = (let e = (let c = (< a = 2 > as A) in 2) in (succ true)) > as (< c : (String -> String) , a : (< d : Float , b : (Bool -> Unit) >) >))
(case (\ c : ({ d : (Nat -> Unit) , a : ({ d : Nat , d : Bool }) }) . (pred a)) of < c = d > => ((\ c : (< a : (< b : Nat , e : Bool >) , b : (Rec C . Unit) >) . (pred (if "boy" then 0 else "apple"))) . a) | < a = b > => (< a = (let b = unit in (iszero c)) > as (< c : String , d : (Rec E . String) >)))
(let b = (let c = (case 1 of < e = a > => 1 | < c = b > => 1) in (let c = a in a)) in ({ e = (if (< e = b > as Nat) then (fix a) else (if 0 then 0 else 0)) , e = (pred (\ c : A . a)) }))
(pred (pred (< a = (case ({ e = true , d = 2 }) of < d = d > => (\ a : String . true) | < c = b > => (\ e : B . 2)) > as ({ e : Bool , e : ({ e : A , b : String }) }))))
(case (((true false) . d) as (< e : A , a : Bool >)) of < a = c > => (fix (unit as C)) | < b = c > => (\ b : ({ e : Nat , c : B }) . (\ b : Float . "apple")))
(< b = (fix (({ c = 0 , d = a }) as String)) > as (< b : ((< e : B , b : C >) -> (C -> Nat)) , a : ((Rec A . Nat) -> ((Nat -> Unit) -> ({ d : Nat , e : Float }))) >))
(< d = (if (let a = true in (case "apple" of < e = b > => "apple" | < a = d > => 2)) then (\ e : C . (pred b)) else (let b = 0 in unit)) > as (({ c : (< c : Bool , a : Bool >) , e : B }) -> (C -> Unit)))
(\ e : (Rec B . ({ c : (< b : A , e : C >) , e : Nat })) . (pred (pred (a . e))))
((if (if false then "apple" else b) then (let e = (\ d : C . 1) in (succ c)) else (succ c)) . c)
(fix (if (if 1 then false else (iszero c)) then (succ (pred b)) else (let b = (\ b : String . false) in (let a = unit in false))))
({ b = ((case (\ e : B . "boy") of < e = c > => (false as String) | < a = e > => ((let d = true in b) as Nat)) as ({ c : (< d : Float , d : (C -> Bool) >) , e : (< d : Bool , c : C >) })) , b = (\ c : ({ c : Unit , b : (< b : Nat , c : Unit >) }) . ((iszero (c . e)) (\ c : C . true))) })
(\ d : (< e : (< e : ({ d : Bool , d : Nat }) , a : Bool >) , e : (< e : String , c : C >) >) . (if (unit . a) then (case a of < b = d > => 0 | < a = c > => ("apple" as A)) else (iszero 1)))
(\ a : ({ d : (Rec C . C) , c : ({ d : ((C -> Unit) -> String) , d : (< d : Float , d : String >) }) }) . (let e = ((0 b) unit) in ((fix a) . d)))
((iszero (< d = 1 > as A)) (iszero (c b)))
(iszero (let a = ((false as Nat) (if ({ a = "apple" , d = "boy" }) then a else "boy")) in (true as (< b : A , e : Unit >))))
((if (a unit) then (unit . d) else (fix "apple")) (iszero (succ (pred false))))
(succ (iszero (let b = c in true)))
(pred (succ (let e = unit in false)))
(succ (\ c : ({ e : (A -> A) , e : ({ c : B , b : C }) }) . ((iszero c) . e)))
(\ b : (< a : (Rec A . Unit) , d : ((Rec B . Float) -> Nat) >) . (< b = ((\ d : Float . 1) . c) > as (< b : String , d : String >)))
((pred (\ c : Bool . b)) (case ({ b = (< c = false > as A) , d = ({ a = 1 , a = a }) }) of < a = a > => (if "apple" then false else (succ a)) | < d = c > => (pred unit)))
({ c = ((\ d : String . "apple") . b) , c = (((case 2 of < e = b > => "apple" | < b = a > => true) true) . c) })
(succ (if (case 0 of < b = e > => 2 | < c = e > => "apple") then (1 as A) else (< e = (1 as C) > as ({ a : Nat , d : String }))))
(fix (fix (< a = 0 > as (Unit -> C))))
(< b = ((unit as String) . b) > as ((< e : (Rec B . (< d : Bool , b : Nat >)) , b : (Rec C . ({ e : Nat , b : A })) >) -> (< a : ({ c : Unit , c : A }) , b : (A -> ({ b : Unit , e : B })) >)))
(if (\ e : (< d : (Rec C . (< a : String , d : Unit >)) , a : (Rec D . Bool) >) . (fix (< a = true > as C))) then (succ (pred (if a then a else true))) else (< a = ({ d = 1 , a = (iszero 2) }) > as (Rec D . (Rec D . A))))
(let b = (< b = (c b) > as (Rec B . Unit)) in (case (c . d) of < b = e > => (if c then true else "apple") | < c = b > => (pred "apple")))
(iszero (fix (({ c = "apple" , c = true }) as (< c : (< a : C , e : Unit >) , a : (< d : Bool , e : Bool >) >))))
(case (let e = ({ c = 1 , d = c }) in (if false then a else 1)) of < d = e > => ((\ a : (Rec E . (< e : Unit , b : A >)) . (if true then 1 else unit)) as (Rec C . (Rec A . Float))) | < b = d > => ((fix (\ e : Nat . 0)) (case (case unit of < e = b > => b | < a = b > => unit) of < d = d > => 2 | < a = e > => a)))
(\ c : (Rec A . ({ e : Bool , d : String })) . (fix (if 1 then c else "apple")))
(if ((case 1 of < e = a > => (if "boy" then 1 else false) | < d = b > => 2) (b as A)) then (case (if (case "apple" of < d = e > => unit | < d = b > => 1) then (case 2 of < d = c > => 2 | < b = e > => "apple") else (if 0 then unit else a)) of < a = a > => (if (let e = 0 in true) then (unit unit) else 2) | < c = e > => (< d = c > as (Rec C . Nat))) else ((if 0 then a else 2) . a))
(let b = (fix (iszero (let d = (1 as Unit) in (unit b)))) in (if (b as String) then ("apple" . a) else ((case a of < e = c > => c | < a = c > => 2) as A)))
(succ (if (iszero false) then (if "boy" then b else 0) else (fix (< e = "boy" > as Float))))
(if ((succ "boy") . e) then (pred (< b = (a false) > as ({ a : Unit , c : B }))) else (case (\ b : (Bool -> String) . (fix "apple")) of < c = d > => ({ b = (if "apple" then false else "boy") , c = (< d = b > as Nat) }) | < a = e > => ((< a = 2 > as A) . c)))
(< e = (< e = (a . e) > as (Rec B . Nat)) > as ((Bool -> (Unit -> Bool)) -> ({ b : String , e : Unit })))
({ a = (let c = ((pred 1) as B) in (\ b : C . 2)) , c = (case (let d = unit in (if c then 1 else unit)) of < c = d > => ((< c = true > as B) . a) | < e = a > => (case (case a of < e = e > => a | < b = e > => "apple") of < b = b > => (\ d : B . a) | < d = d > => ({ a = "boy" , c = false }))) })
(if (fix (pred b)) then (iszero (((a "apple") "apple") . c)) else (< b = (iszero b) > as ({ c : Nat , d : (< e : String , a : Nat >) })))
({ a = (\ b : (B -> Unit) . (iszero 1)) , b = (if ((< a = b > as A) (\ d : Unit . true)) then (if ((false a) . a) then (succ b) else (let c = c in 0)) else ((iszero (let b = 2 in 2)) (succ 2))) })
(if (< d = (\ d : (B -> Bool) . (< b = b > as A)) > as ({ b : (< e : Float , a : Float >) , d : ({ a : Bool , a : A }) })) then ({ c = (if (iszero b) then (1 . d) else (pred 0)) , d = (succ (let d = "boy" in (fix 1))) }) else (< d = (let e = 0 in (a false)) > as ({ d : ({ d : Nat , e : String }) , e : (< b : A , a : C >) })))
(iszero (((\ e : Bool . 1) as Bool) (let c = (2 . b) in unit)))
(fix (let b = (case 1 of < e = e > => 0 | < a = c > => c) in (fix "apple")))
(\ b : ({ a : ({ e : String , d : Float }) , a : ({ d : ({ d : A , b : C }) , e : Bool }) }) . (case (fix true) of < d = b > => (if (false as C) then unit else 0) | < a = c > => ({ d = "apple" , e = 2 })))
(< e = (pred (case (case c of < b = c > => 0 | < c = e > => "boy") of < e = a > => ("apple" c) | < a = d > => ({ a = false , a = "boy" }))) > as ({ b : (< e : Nat , e : C >) , c : (String -> B) }))
({ b = (case ({ d = (false as C) , a = ((1 . c) (false . e)) }) of < e = c > => (case (pred (case false of < e = b > => 1 | < b = a > => 0)) of < b = b > => (succ false) | < c = c > => (\ c : (String -> A) . (fix true))) | < b = d > => (c . c)) , a = ((succ (false (let e = 0 in 2))) as ({ c : String , c : (< b : B , e : String >) })) })
(case (< d = ({ a = c , d = 2 }) > as (< a : Bool , a : Float >)) of < c = c > => (succ (< c = true > as Nat)) | < e = d > => ((iszero (c 2)) . b))
(pred (succ ((if c then b else "boy") . a)))
(pred (succ (let b = "boy" in (succ "boy"))))
(pred ((case "boy" of < e = e > => (fix c) | < b = a > => (< c = 0 > as Bool)) . c))
(((pred "boy") as ({ d : ({ b : (< a : Bool , d : B >) , c : Nat }) , d : ({ b : ({ b : Bool , a : C }) , b : Unit }) })) (succ (case (c a) of < b = e > => (< b = "boy" > as C) | < c = e > => (iszero ({ e = unit , c = a })))))
(let a = (< a = (let b = (let a = 1 in 0) in b) > as ({ e : Bool , d : A })) in (let e = (fix "apple") in (let a = 1 in b)))
(\ b : ((C -> Bool) -> (< d : B , b : Float >)) . ({ b = (case 2 of < d = a > => a | < a = e > => "boy") , d = (unit as A) }))
({ a = (\ b : ({ e : Float , b : Bool }) . (case 1 of < d = c > => "apple" | < b = d > => true)) , a = ((let e = 2 in 0) (if (iszero c) then "apple" else (case 2 of < d = c > => b | < a = c > => false))) })
(< d = ({ d = ("boy" (iszero "boy")) , b = (case (case "apple" of < e = c > => false | < c = b > => a) of < b = a > => 1 | < a = c > => 2) }) > as (Rec C . ({ c : (Rec B . (Rec A . Nat)) , e : (Float -> Float) })))
(\ a : ((< b : ({ a : A , b : Float }) , b : (< c : Float , d : A >) >) -> ({ d : Float , e : B })) . (if (if (0 "boy") then (false as C) else b) then (let c = 2 in 1) else (iszero 2)))
((case (< d = "apple" > as A) of < a = a > => (b b) | < a = b > => (unit b)) (({ a = "boy" , c = 0 }) . e))
((< b = (if (iszero "apple") then (c as B) else (true 0)) > as ((Rec B . Unit) -> (< a : Float , c : String >))) as (Rec B . (< c : (B -> C) , d : (B -> Nat) >)))
(fix ((< c = b > as Nat) . d))
(case (\ c : (A -> Float) . (succ false)) of < d = c > => (let a = (let e = c in (iszero b)) in (case "boy" of < d = d > => "boy" | < e = e > => b)) | < d = c > => (if ((c as (Bool -> B)) . d) then (case b of < c = b > => (pred true) | < c = b > => (if a then "apple" else "apple")) else (case (if true then "apple" else "boy") of < c = e > => c | < a = d > => (0 as A))))
(let d = (let c = (pred "apple") in (true as (< d : B , b : Unit >))) in (case (succ (succ a)) of < d = c > => (iszero (let a = ({ d = c , c = 0 }) in b)) | < d = c > => (({ d = 2 , c = b }) (a as A))))
(case (pred (iszero unit)) of < d = b > => ({ c = (if b then "apple" else (pred b)) , c = (case (\ c : A . a) of < c = b > => (pred unit) | < c = b > => (if 2 then 1 else true)) }) | < d = b > => (< c = (((true . a) . a) ({ e = false , b = "apple" })) > as (Rec E . (< a : A , b : B >))))
(let a = (fix ((case false of < c = b > => 0 | < e = a > => 2) . c)) in ((pred ((iszero "apple") as B)) (c . a)))
((succ (pred false)) . a)
(fix (({ d = b , e = (fix false) }) as ((C -> Bool) -> (B -> A))))
(case ((c ({ b = 0 , a = c })) as ({ b : ({ d : Unit , c : Bool }) , a : (< e : C , c : C >) })) of < b = a > => ((let d = true in (unit . d)) (succ c)) | < e = c > => ({ b = (iszero unit) , d = (succ (\ c : String . b)) }))
({ c = ({ c = (if (\ a : String . c) then (a . a) else c) , c = (if (succ "apple") then (fix true) else c) }) , b = ((let b = "apple" in a) (iszero a)) })
(succ (let e = (let c = true in a) in (\ c : C . 0)))
(fix (succ (case (if b then 0 else 0) of < a = e > => 2 | < d = d > => b)))
(fix (\ e : ({ a : Bool , c : C }) . ({ b = (({ c = c , c = unit }) . c) , b = (pred c) })))
((if (if (1 as B) then false else (succ a)) then (case false of < c = b > => true | < c = c > => true) else (fix (\ a : B . unit))) as (({ c : ({ b : B , c : C }) , e : String }) -> (Rec B . (Rec A . A))))
(< e = (pred (succ true)) > as ({ c : (Bool -> Bool) , d : (< a : B , e : Bool >) }))
(pred (if (case (true (case unit of < d = a > => 0 | < a = d > => b)) of < a = b > => (case 1 of < e = e > => 2 | < d = b > => c) | < a = b > => (pred "apple")) then (({ a = (if "boy" then "boy" else b) , a = (succ true) }) . b) else ({ b = (case 2 of < b = d > => (if 1 then true else 2) | < e = a > => a) , c = (\ a : String . true) })))
(fix (let a = (iszero "boy") in (succ 2)))
(succ (< c = ((fix 0) (if true then "apple" else true)) > as (< e : String , b : Unit >)))
({ b = (\ e : ({ e : String , b : A }) . (a true)) , e = (((0 as C) . d) as (Rec D . (Nat -> C))) })
({ e = (if (case c of < d = d > => (let a = false in b) | < e = a > => (iszero 0)) then (fix 0) else ((true as A) . e)) , d = (iszero (case ({ c = "apple" , b = true }) of < d = c > => (iszero 0) | < e = d > => b)) })
({ c = (< b = (succ 0) > as (< a : (Rec E . Bool) , b : ({ e : Unit , e : C }) >)) , e = (pred (let a = (fix false) in (< c = (let c = a in b) > as C))) })
((fix ((2 as Float) . c)) as (Rec C . (< c : Bool , b : Unit >)))
(({ d = (< a = "boy" > as (< e : B , a : Nat >)) , c = ({ c = (fix unit) , d = (fix "apple") }) }) as ({ a : (< c : (Rec B . A) , d : (Rec C . String) >) , c : (Rec E . (< a : Unit , b : C >)) }))
({ b = (let a = (pred "apple") in (fix true)) , a = ((0 as Nat) (c as (< b : Nat , d : String >))) })
(((let e = (< c = 0 > as Unit) in true) . e) . a)
((fix (case "apple" of < d = b > => 2 | < e = a > => "boy")) as (< e : ({ e : ({ a : Unit , c : Bool }) , b : ({ e : Bool , d : String }) }) , b : (A -> Unit) >))
((pred ({ a = (a 0) , e = ({ c = 0 , e = 2 }) })) as (Rec D . ({ a : (Rec B . Unit) , c : (C -> Float) })))
(let a = (fix (< d = "boy" > as String)) in (< b = (succ (iszero true)) > as (Unit -> String)))
(succ (let a = (iszero (pred "apple")) in (let d = (case c of < c = c > => c | < d = d > => 0) in a)))
(case ((iszero 1) (succ (< b = 2 > as C))) of < a = d > => (case (fix "apple") of < d = d > => ((1 . c) (\ b : Nat . b)) | < e = c > => (succ (true unit))) | < d = d > => (iszero (\ e : ({ a : Bool , d : C }) . true)))
(fix ((if (iszero c) then (pred false) else ({ c = true , a = "apple" })) . c))
(\ c : ({ d : ({ e : (C -> Unit) , e : (< c : String , e : Unit >) }) , a : ((Bool -> Unit) -> Float) }) . (< e = (case false of < c = a > => 1 | < b = d > => (succ "boy")) > as (B -> B)))
(< d = ({ a = (< d = (pred 2) > as (Rec C . Float)) , e = ((< b = 2 > as String) (\ e : Nat . b)) }) > as ({ a : (< c : Bool , a : Bool >) , b : ({ b : String , e : C }) }))
(\ b : ({ e : (Rec A . ({ d : ({ c : String , d : String }) , c : ({ e : Unit , d : C }) })) , a : ({ e : (Bool -> Unit) , e : (Rec E . String) }) }) . (({ e = (\ b : C . unit) , e = (case false of < d = b > => a | < a = c > => true) }) (pred unit)))
((\ b : (String -> Bool) . (fix 2)) . d)
(succ (if (fix (succ false)) then (pred ((b as A) ({ a = false , e = "boy" }))) else (fix (0 . d))))
(case (case (fix (succ 0)) of < e = d > => (succ a) | < d = b > => (\ a : (A -> C) . (iszero (let a = b in "boy")))) of < d = a > => (succ ({ b = c , a = (< e = a > as A) })) | < d = d > => (pred (succ (if 2 then b else false))))
(iszero (let d = (pred (b false)) in (if (fix unit) then (case 0 of < d = e > => unit | < e = a > => false) else (succ 0))))
(succ (< e = (iszero (unit . a)) > as (< d : (Rec A . A) , a : B >)))
(< c = (case (case (a . a) of < d = c > => (let b = 0 in false) | < a = e > => (pred false)) of < c = b > => (succ (succ (if "apple" then unit else b))) | < c = c > => ({ b = (< b = true > as A) , d = (iszero b) })) > as (({ a : String , a : String }) -> (Float -> C)))
(\ e : (< c : (< d : (Rec D . Unit) , d : String >) , e : (< c : Nat , b : (Unit -> C) >) >) . (if (\ c : (< e : Unit , b : A >) . 0) then (0 . c) else (< e = (fix (< d = c > as Nat)) > as ({ c : ({ b : A , b : String }) , e : (B -> Nat) }))))
(succ (if ({ d = "apple" , e = false }) then ((if "apple" then false else false) as (Rec C . Float)) else (pred (succ "boy"))))
(succ (case (if (succ a) then c else (b 0)) of < c = a > => ((pred "boy") . e) | < b = a > => (let d = ({ e = 1 , d = unit }) in (if c then 0 else c))))
((\ a : (({ a : Nat , b : Bool }) -> String) . (({ e = (b . e) , c = 0 }) . b)) . b)
(let a = (case (pred false) of < a = d > => (succ true) | < d = e > => (iszero (c as Bool))) in ((pred 1) . a))
(let c = (succ (case true of < b = c > => (pred true) | < d = d > => (fix 1))) in (case (fix c) of < d = a > => (fix 2) | < c = d > => (if b then a else a)))
(succ (< b = (case a of < a = c > => (\ d : A . 2) | < b = a > => (let a = 2 in 1)) > as ({ d : Nat , b : ({ b : String , e : Bool }) })))
((if (< d = "boy" > as ({ c : String , c : Unit })) then (< a = (iszero 1) > as Nat) else (case unit of < b = e > => false | < b = a > => (2 b))) ((iszero b) . e))
({ c = (pred (if (iszero c) then (iszero false) else (case (< e = 2 > as Unit) of < a = b > => (pred 1) | < a = d > => 0))) , a = (let d = (case (pred unit) of < c = c > => (case (pred "apple") of < e = b > => 2 | < c = a > => unit) | < b = c > => (fix 1)) in (if (false "boy") then true else (let b = unit in 0))) })
({ c = (pred (let d = c in 1)) , c = ((unit 0) . a) })
(pred (fix (let c = ({ e = b , e = 1 }) in ({ b = true , b = true }))))
((< d = (< c = (1 . a) > as B) > as ((Rec D . Float) -> (B -> C))) as (({ b : Float , a : B }) -> ({ b : Unit , b : A })))
(succ (iszero (iszero (< c = false > as B))))
(< c = (succ (pred a)) > as (Rec E . (Rec B . B)))
((fix (\ a : A . unit)) ((if 0 then unit else 1) . b))
(\ a : (Rec E . (< b : ({ c : B , a : Nat }) , c : ({ d : (Rec D . Float) , a : (A -> A) }) >)) . (< c = (({ c = (pred c) , b = unit }) as (C -> Unit)) > as (Rec C . (C -> Unit))))
(< a = ((if b then "apple" else (fix true)) as ((< e : A , c : Bool >) -> (Rec B . Unit))) > as ((Unit -> ({ e : Bool , d : Float })) -> (< e : ({ b : C , b : Nat }) , e : (< b : A , b : Unit >) >)))
({ c = (let b = (fix (case "apple" of < c = b > => c | < a = b > => "boy")) in (iszero a)) , c = ((pred (< a = "apple" > as Nat)) ((\ e : String . false) as (A -> Float))) })
((fix (succ (case b of < e = b > => a | < e = d > => "apple"))) (pred (fix unit)))
(let c = (iszero (let b = b in unit)) in (case (succ 2) of < b = e > => ({ b = 0 , b = "boy" }) | < c = a > => (if 2 then b else c)))
(< a = ((pred true) . b) > as ({ a : ((< d : Unit , a : C >) -> (Rec E . C)) , b : ({ b : ({ a : ({ d : Bool , d : B }) , c : Nat }) , a : (Nat -> B) }) }))
(fix (if (pred (let e = (succ true) in (< d = "boy" > as Unit))) then ((case unit of < a = b > => unit | < b = c > => c) as (< c : Nat , c : Float >)) else (let a = unit in "boy")))
(iszero (succ (succ 2)))
(case (fix (case "apple" of < b = a > => (\ e : Unit . false) | < d = a > => c)) of < b = d > => (iszero (case (case 0 of < b = c > => a | < d = e > => unit) of < d = d > => "boy" | < e = d > => (\ b : Unit . 0))) | < e = d > => ((if true then "boy" else (< a = unit > as C)) . d))
(< e = (pred (\ c : (< d : B , a : Float >) . (iszero (fix 1)))) > as ({ d : ({ b : (< b : B , b : Float >) , e : (< c : ({ a : Float , a : A }) , b : (C -> Nat) >) }) , e : (< a : Unit , a : (Rec B . C) >) }))
((fix ((c c) as C)) as (< a : (Rec A . Float) , e : ({ c : Unit , b : C }) >))
(iszero (fix (pred "boy")))
((((a as Unit) (succ 1)) as (({ a : C , c : String }) -> (< d : Nat , b : (< c : Bool , b : C >) >))) as (< e : ((< b : String , c : C >) -> (< a : A , b : A >)) , d : (< d : ({ c : (Rec D . C) , b : String }) , e : (Rec B . Nat) >) >))
(iszero (iszero (let a = (< b = unit > as Float) in (let d = c in false))))
(iszero ((let d = (false . c) in b) . d))
(fix (succ ({ c = 1 , e = 1 })))
(< c = (\ a : ((Nat -> Unit) -> ({ c : (Nat -> String) , c : C })) . (fix (fix unit))) > as ({ b : (Rec B . Nat) , c : (({ a : Bool , d : Nat }) -> ({ b : C , c : Nat })) }))
(((\ e : String . 1) (let d = unit in ("boy" c))) ((\ e : C . b) . d))
(fix (succ (fix (case c of < e = b > => 1 | < d = a > => unit))))
(case (iszero (1 . c)) of < b = b > => ((c as A) as (Rec B . C)) | < d = e > => (case ({ a = "boy" , e = 0 }) of < c = e > => (\ d : B . false) | < b = e > => (\ b : B . (succ c))))
((case (fix (0 0)) of < b = b > => (true as Float) | < e = e > => (succ (true . c))) (\ b : (< b : C , c : (C -> Float) >) . (if 1 then true else 1)))
({ a = (iszero ({ b = true , d = 1 })) , b = (case (case 1 of < c = c > => true | < e = e > => b) of < a = d > => (case unit of < c = b > => (c "boy") | < a = a > => (a a)) | < d = a > => (case "boy" of < e = a > => 1 | < c = b > => unit)) })
(iszero ((iszero "apple") . c))
(iszero (< a = (succ 2) > as ({ d : (Rec E . C) , a : (< d : Bool , c : Nat >) })))
(pred ({ a = (fix c) , a = (fix (let d = "apple" in true)) }))
((case (\ e : String . a) of < a = d > => (< c = unit > as C) | < a = e > => ({ a = "apple" , b = 0 })) (fix (false as Float)))
(case ((iszero (let c = b in unit)) as ({ b : (< a : A , c : Nat >) , b : Float })) of < d = e > => (({ e = true , e = (b . e) }) (pred 1)) | < e = d > => (((pred (if 0 then 1 else a)) . b) as (Nat -> C)))
(fix ({ b = (< b = unit > as A) , e = (case c of < c = e > => unit | < a = e > => unit) }))
(((< a = false > as (Rec A . C)) as ({ c : Unit , a : String })) (iszero (\ b : A . 2)))
(< d = (((b as Nat) as B) ((case "boy" of < c = a > => false | < d = e > => 2) . a)) > as (Rec B . (< a : B , d : C >)))
(< e = (let b = (c as C) in (let b = false in 0)) > as ((< d : B , e : Float >) -> (Rec B . Float)))
(let b = (case (iszero false) of < a = b > => (< c = true > as C) | < a = d > => (case (pred 0) of < b = e > => unit | < c = a > => false)) in (pred (if false then "boy" else "apple")))
(\ d : ({ b : (Rec E . (Float -> Nat)) , e : ((Rec A . B) -> (Bool -> B)) }) . ({ b = (succ (iszero b)) , b = (case (pred (case b of < e = b > => "apple" | < c = b > => false)) of < e = b > => (a as B) | < b = b > => (if false then (a "boy") else b)) }))
(fix ({ a = (case true of < a = e > => (pred 1) | < a = c > => "apple") , c = ({ c = c , b = (succ "apple") }) }))
((case (let c = (succ "apple") in false) of < a = d > => (succ "apple") | < a = e > => (0 as Unit)) . a)
(if (< b = (\ b : (Bool -> String) . (if unit then c else 1)) > as ((< b : Bool , a : Bool >) -> (Rec A . B))) then (if ((< d = "apple" > as Nat) as (< b : Unit , b : C >)) then (iszero true) else (let b = (fix (pred a)) in (pred "boy"))) else (iszero (\ e : (< d : Unit , a : Nat >) . (< a = unit > as Nat))))
(fix (pred (fix (succ "boy"))))
((case (succ (if (if 1 then b else false) then false else (let a = 0 in 1))) of < b = b > => ((succ true) as (Nat -> Float)) | < a = b > => (< a = (succ "boy") > as ((< e : C , b : Unit >) -> (Rec E . Unit)))) as ((Rec E . Float) -> (Rec A . Unit)))
(fix ({ a = (iszero (\ d : Nat . 2)) , a = (let e = ({ a = (case c of < b = e > => true | < a = c > => c) , c = a }) in (case unit of < d = b > => true | < d = a > => 0)) }))
(if (({ e = 1 , a = b }) (< b = "boy" > as Bool)) then ((fix (\ c : Float . "boy")) . e) else (iszero (1 . c)))
(((succ true) . d) as ((Bool -> C) -> ({ b : String , c : A })))
(< d = (if (\ b : A . (< d = false > as String)) then (if 0 then (let c = true in b) else "boy") else (succ false)) > as ({ b : ({ a : (< d : Bool , a : Unit >) , c : Unit }) , e : (Rec A . Float) }))
(\ b : ({ c : ({ c : C , b : Nat }) , c : (Rec C . String) }) . (\ b : (B -> (Nat -> Bool)) . (let d = ({ b = false , d = true }) in (< b = c > as Bool))))
(< d = ((fix true) as (Rec A . Nat)) > as (< d : ({ e : C , e : Bool }) , e : (Float -> String) >))
(fix ((fix (fix "apple")) (case a of < e = c > => true | < a = c > => b)))
(\ c : ({ c : (Rec D . Bool) , a : (Rec A . String) }) . (\ c : ({ a : (Float -> String) , a : (Rec E . String) }) . (case (iszero c) of < a = b > => ("apple" 0) | < c = e > => 0)))
(pred (iszero (let d = false in b)))
(pred (iszero (\ c : Bool . (b . a))))
((iszero (false a)) (let c = (if (let c = 0 in unit) then (succ 1) else (if a then 0 else "apple")) in (< c = (fix (c . c)) > as (< e : String , e : B >))))
({ c = ((fix c) (0 2)) , c = (fix (case c of < e = a > => 0 | < c = d > => "boy")) })
((iszero (iszero "apple")) as (< a : (< b : (< d : Nat , d : Unit >) , e : (Rec E . Float) >) , e : (Bool -> C) >))
(if (fix (fix 1)) then (let c = (< b = (unit false) > as (< d : (< b : Float , c : Unit >) , a : (< d : A , e : Nat >) >)) in (\ a : ({ c : (< b : String , c : A >) , a : ({ a : A , d : Unit }) }) . (if (let a = unit in "boy") then (< e = b > as Float) else unit))) else (let d = (case b of < a = d > => "boy" | < b = a > => unit) in (case unit of < b = c > => 1 | < b = a > => 2)))
(iszero (({ b = "apple" , d = "boy" }) . a))
(case (succ (\ c : C . 0)) of < b = c > => ((let c = ("apple" . c) in (if 1 then 2 else 2)) as ((Float -> String) -> (B -> (Rec D . String)))) | < c = e > => (pred ({ c = 2 , e = (if "apple" then 1 else true) })))
(case ((\ b : (Rec A . C) . (true unit)) . e) of < a = c > => ((iszero (fix a)) (fix a)) | < c = e > => (\ d : (< b : A , b : (Rec D . A) >) . (case ({ b = unit , a = false }) of < e = c > => (pred true) | < c = b > => (< e = unit > as Nat))))
((("apple" (iszero 1)) (let d = (\ a : Unit . 0) in (let e = unit in 0))) (succ (iszero a)))
({ b = (fix (case 0 of < c = c > => (false b) | < a = c > => false)) , b = (\ b : ((< c : Float , e : B >) -> (< b : Unit , d : Float >)) . ((fix a) . a)) })
(case (pred ((\ b : Unit . unit) 2)) of < b = b > => (pred (\ d : String . (pred 0))) | < c = e > => ((iszero "apple") ({ e = (\ e : Float . "apple") , b = (< e = a > as (< b : Nat , c : Unit >)) })))
(fix ({ c = (pred "boy") , a = (if (succ true) then (case c of < a = c > => "apple" | < c = c > => true) else (unit true)) }))
(case (pred (\ e : Float . (let a = b in "apple"))) of < e = e > => (succ (\ c : ({ d : String , e : Unit }) . (unit as A))) | < b = a > => (let b = (fix b) in (pred 0)))
(fix (if (fix (pred "boy")) then (pred (succ b)) else ((case 0 of < b = e > => true | < d = c > => 1) . b)))
((fix (iszero b)) (fix (let e = (2 as (String -> Nat)) in (\ a : Unit . "boy"))))
(if (iszero (fix (a as Nat))) then (\ a : (Rec E . Unit) . (succ 2)) else ((let b = (\ c : Unit . 0) in (fix (iszero c))) . d))
(fix ({ a = ({ a = (succ c) , a = (succ "boy") }) , e = ((if (case false of < b = b > => unit | < d = b > => 0) then (let d = c in c) else false) as (Rec D . A)) }))
({ a = (pred (< d = 2 > as (< b : Unit , b : String >))) , e = (pred (succ c)) })
(case ((pred (< d = 2 > as Nat)) (succ ((2 b) as Float))) of < d = b > => (< c = (pred "apple") > as (Rec E . A)) | < e = c > => (pred (< a = 1 > as C)))
(succ ({ c = (let d = (succ true) in ("apple" unit)) , b = (\ d : (Nat -> String) . 0) }))
(< a = (case (if ({ c = 1 , e = 0 }) then (< a = 1 > as A) else (succ unit)) of < b = a > => (< d = ({ c = unit , e = a }) > as (B -> (< b : Bool , c : String >))) | < d = b > => (< e = (let a = unit in a) > as ({ e : Nat , a : Float }))) > as ((< e : ({ d : C , e : Bool }) , c : Float >) -> (< d : ({ b : String , a : Bool }) , d : (Float -> String) >)))
(({ d = (if "apple" then true else b) , b = (b 2) }) . b)
(pred (fix (if b then 1 else 0)))
(pred ((\ a : String . (c false)) as ({ e : ({ d : A , c : Nat }) , e : Float })))
(< d = (if (let e = ({ d = 1 , c = false }) in (c as C)) then (if (\ e : B . true) then (0 0) else ({ e = a , d = false })) else (\ c : (Float -> (C -> C)) . (\ b : Float . (iszero c)))) > as (Rec D . ({ a : (< a : C , b : (< d : A , e : C >) >) , d : ({ d : B , c : Unit }) })))
((pred (let a = false in false)) as (< d : (Rec C . (Rec A . Nat)) , d : (Unit -> B) >))
(\ a : ((C -> (Rec A . Bool)) -> ({ a : ({ d : Bool , d : Nat }) , a : (Rec B . Bool) })) . ({ b = (fix (iszero (let b = 2 in 1))) , c = (pred (let b = (succ 0) in (case 1 of < d = d > => "apple" | < e = a > => unit))) }))
((pred (case (if (iszero 2) then b else (fix "boy")) of < d = d > => (({ c = "apple" , a = 0 }) as (< d : B , d : Float >)) | < c = b > => (let d = 0 in (succ "apple")))) (fix ((a (a c)) . b)))
(< b = ((let d = 1 in a) . c) > as (< e : (Rec B . Unit) , d : (B -> B) >))
((if (if (pred 0) then 2 else (iszero 2)) then (let a = c in "boy") else (fix "apple")) ({ c = (case false of < b = b > => (fix 0) | < a = c > => (fix "apple")) , d = (pred false) }))
((succ (let e = (iszero a) in ("apple" "boy"))) . a)
(succ (if (c . d) then (pred true) else (if b then (pred true) else (pred unit))))
((if (pred a) then ((< c = 2 > as String) as (Float -> B)) else (if (pred unit) then (let d = false in true) else (< b = (let c = false in "boy") > as ({ b : Bool , e : Bool })))) ((< a = ((iszero a) . b) > as ((Rec C . C) -> (< a : Nat , a : Float >))) . d))
(case ((case (let a = "apple" in a) of < e = c > => (true "boy") | < c = e > => (if 0 then a else "apple")) . a) of < b = d > => (if ("boy" as Unit) then (fix true) else (let a = 0 in "apple")) | < b = c > => ((< a = "apple" > as String) as ({ a : Float , a : C })))
((fix (< a = "apple" > as Float)) as ((< d : (Rec C . A) , c : (A -> String) >) -> (< d : (< e : Unit , e : String >) , b : (Rec A . String) >)))
((("boy" as (Rec B . Nat)) as ({ b : Bool , c : (Float -> Unit) })) as (Rec B . ((< b : C , c : C >) -> B)))
({ c = (let d = (\ c : ({ b : (C -> B) , a : Nat }) . ({ e = true , a = 0 })) in (b as A)) , c = (if ({ c = 2 , a = true }) then (succ "apple") else (iszero 1)) })
(\ c : (Rec E . (Rec D . String)) . (succ (let e = b in ("apple" false))))
((if (\ c : Nat . unit) then (iszero (case (false . c) of < b = a > => c | < c = d > => 0)) else (if (if (let a = true in 2) then ("boy" b) else a) then (iszero false) else (fix (iszero 2)))) . e)
(iszero (\ c : (Rec D . (Rec A . Nat)) . ((0 "apple") ({ d = a , b = "apple" }))))
(\ a : ({ c : ({ c : B , e : B }) , d : ({ a : ({ c : B , e : Nat }) , d : (Rec C . A) }) }) . (pred (let d = c in (\ c : Nat . 2))))
(let e = ((fix false) as (A -> A)) in (< c = (case (case (0 as B) of < c = d > => unit | < e = c > => "apple") of < a = e > => (< d = unit > as Float) | < e = d > => (2 as String)) > as (({ a : C , a : ({ a : String , b : Bool }) }) -> (Unit -> B))))
(fix (iszero (fix (case true of < d = c > => false | < a = d > => a))))
((< d = (false . d) > as ({ e : (Rec B . A) , d : String })) (case (\ a : (Rec E . String) . (pred unit)) of < d = b > => (if ("apple" as Float) then ("apple" . e) else (iszero a)) | < c = d > => (if (iszero b) then (case 2 of < b = b > => "apple" | < e = e > => 1) else false)))
(((\ c : Unit . (case false of < b = e > => false | < b = a > => 1)) . d) as ((Rec D . (Rec A . Float)) -> (< b : String , d : ({ e : B , c : C }) >)))
(fix (fix (succ "apple")))
({ a = (\ d : (< c : ({ b : Bool , a : Bool }) , d : ({ e : C , c : String }) >) . (case (succ a) of < d = c > => (unit "boy") | < a = d > => c)) , d = (succ ((let e = ({ b = unit , b = "boy" }) in (a as String)) . b)) })
(pred (fix (\ c : A . 0)))
(\ b : (< d : ({ e : Nat , c : (A -> Unit) }) , e : (Rec E . Float) >) . ({ e = ({ a = 1 , d = "boy" }) , c = (pred 2) }))
(pred (\ d : (Rec E . (B -> Float)) . (\ e : (A -> String) . 2)))
(((if ({ d = "apple" , e = 2 }) then (2 (case "apple" of < d = b > => false | < d = c > => false)) else (pred false)) (let d = ({ c = 0 , e = (2 as Nat) }) in (true unit))) ((pred (fix 1)) . d))
(case (case (fix (succ a)) of < c = b > => (let b = ({ e = unit , b = unit }) in (b "boy")) | < a = d > => ({ d = ((2 as Nat) as C) , b = (succ 1) })) of < d = b > => ((let c = (iszero 2) in (pred "boy")) . c) | < c = d > => (if (let d = a in (if unit then 1 else b)) then (< c = 1 > as C) else (< d = (fix c) > as C)))
(let c = (fix (pred (\ d : Nat . 1))) in ((case (case b of < b = a > => a | < c = a > => true) of < e = a > => (0 b) | < e = b > => (succ false)) as (< a : (Rec C . B) , b : Nat >)))
({ a = (< e = (let b = (unit b) in (\ c : Float . false)) > as (< a : (Rec B . B) , d : (< e : C , b : B >) >)) , d = (case (< a = (unit as (< d : String , e : Unit >)) > as (B -> A)) of < c = e > => (unit . b) | < b = c > => (1 (a as Nat))) })
(\ c : ({ a : ({ d : String , c : Float }) , d : (Rec C . Float) }) . (succ (iszero 2)))
(pred (succ (\ d : Nat . unit)))
(if (iszero (false . c)) then ((succ 1) . b) else (pred (case (< c = "boy" > as B) of < b = b > => (iszero 0) | < c = e > => (case 0 of < d = b > => c | < d = e > => "boy"))))
((iszero (succ (a as String))) (("boy" "boy") . e))
(case (fix ({ e = false , c = (pred 2) })) of < a = a > => (case (< e = b > as C) of < a = a > => (if a then (iszero 1) else (succ unit)) | < b = e > => (a "boy")) | < b = e > => (let b = (iszero "boy") in (fix (if false then true else 1))))
(fix ((succ (0 1)) (case (< d = (iszero b) > as (C -> B)) of < c = e > => (case "boy" of < d = e > => unit | < b = b > => a) | < d = b > => (if true then (iszero c) else c))))
(case (pred (let c = (\ e : Bool . false) in (fix (iszero b)))) of < d = c > => (if ({ c = "boy" , b = (0 2) }) then (if false then false else c) else (unit unit)) | < b = c > => ((if 2 then ("boy" . c) else false) as ({ e : String , e : Bool })))
(\ a : (< a : (< b : Unit , d : (< c : B , a : Nat >) >) , b : (Bool -> C) >) . (pred ((true 2) false)))
(succ (let d = (iszero b) in (succ b)))
((let a = (if (succ 2) then (let b = 2 in 1) else (if (a . a) then a else unit)) in (succ ({ a = unit , d = 2 }))) as (< b : ((Float -> Unit) -> ({ e : C , e : Float })) , c : (< b : String , a : (Float -> Unit) >) >))
(if (iszero (let d = true in (succ c))) then (fix (false as Unit)) else (pred (iszero (c . d))))
(\ c : (({ c : (String -> C) , c : (< d : A , c : String >) }) -> (Rec A . (C -> Float))) . (succ (let e = (fix "boy") in (c as B))))
(let b = (\ c : (< b : ((Rec C . A) -> (< e : A , e : Nat >)) , e : (< b : String , d : Unit >) >) . ((1 (iszero b)) as (C -> Float))) in (pred (case (pred a) of < a = d > => "apple" | < e = b > => false)))
(let b = (pred (let e = 2 in 1)) in (fix ({ a = false , c = c })))
(succ (\ b : (Rec A . Bool) . (a as Nat)))
(let a = (succ (if "boy" then (if 1 then 2 else c) else (iszero true))) in (pred (\ c : (< e : A , b : C >) . unit)))
(fix (if (let c = unit in 0) then (fix (succ 0)) else (\ d : (< a : C , b : C >) . "apple")))
(case (let c = (let b = (succ "boy") in ({ e = 0 , e = 2 })) in (< c = (pred (2 1)) > as (Rec C . C))) of < d = a > => ({ b = (pred (pred 1)) , b = (if (b 2) then (succ 2) else (0 . c)) }) | < a = d > => (if (if true then (\ b : C . "boy") else ({ d = c , b = false })) then ((< d = (succ 0) > as String) (succ true)) else (case (case a of < d = b > => 2 | < b = a > => "boy") of < e = a > => (pred (2 as Unit)) | < b = c > => (iszero 2))))
({ a = (let c = (< c = true > as A) in ({ b = b , e = unit })) , d = (succ ({ c = true , d = unit })) })
(fix (< a = (succ (iszero 1)) > as (< d : Nat , b : C >)))
(({ b = ("apple" . b) , e = (case c of < b = c > => (pred true) | < d = e > => "apple") }) . c)
(if (iszero (\ d : A . "apple")) then ((\ e : Nat . "boy") (unit . d)) else (iszero ({ a = ("boy" 0) , e = (unit as Unit) })))
(if (pred (\ d : Float . "boy")) then ({ e = (let b = c in b) , d = ((if "apple" then true else 1) as (< d : Bool , e : Bool >)) }) else ({ a = (case (\ a : Bool . true) of < b = a > => b | < d = b > => (iszero 1)) , a = (\ a : (< b : C , d : Nat >) . (< e = 0 > as A)) }))
(fix (succ (b c)))
((succ ("boy" . b)) . d)
(case (pred (fix (succ true))) of < c = a > => (succ (if false then c else 2)) | < d = a > => (case ((case unit of < b = c > => 2 | < a = b > => unit) as (Rec B . C)) of < e = b > => (false as Unit) | < e = d > => (pred (iszero a))))
(pred ((if (pred true) then (iszero b) else (let c = 2 in "apple")) as ({ e : (A -> String) , a : (< e : (B -> Unit) , e : (< a : A , b : Unit >) >) })))
(succ (if (iszero unit) then (fix ("boy" . d)) else (< b = 1 > as B)))
({ e = ((if a then "boy" else 1) . b) , d = (succ (\ c : (Nat -> C) . (succ c))) })
(\ d : (({ b : (< c : Nat , e : A >) , e : (< a : Nat , c : (Rec D . B) >) }) -> (< a : Nat , b : (A -> Unit) >)) . (iszero (pred (0 . e))))
(({ c = ({ a = (a as Bool) , d = (fix c) }) , e = (if (if unit then "apple" else b) then (false . e) else (succ 1)) }) ((pred ({ a = b , c = 0 })) . c))
(if (succ (if ((c as Nat) . d) then ((if unit then "apple" else "apple") 0) else ({ a = 1 , b = "boy" }))) then (if (iszero (< d = 2 > as A)) then (succ false) else (case (0 . b) of < e = d > => "boy" | < b = e > => false)) else (succ (\ d : (< e : B , d : A >) . (pred false))))
(succ (pred (case unit of < e = c > => c | < a = a > => true)))
(< e = (iszero (< a = (case b of < c = c > => 0 | < b = d > => false) > as ({ b : Bool , d : Bool }))) > as ((Rec A . (Rec D . A)) -> ((< d : Float , c : Unit >) -> (Rec C . Float))))
((case (unit . e) of < c = d > => (false 2) | < a = b > => (true . c)) ((case false of < d = c > => 0 | < e = b > => c) as ({ c : String , c : Unit })))
(((0 . b) . d) as (< b : (({ e : (Bool -> Nat) , e : C }) -> (Nat -> A)) , a : (< d : (Rec D . Float) , b : ({ b : B , c : Float }) >) >))
(fix ((if (false false) then "boy" else "boy") (0 a)))
(case ((b as String) . a) of < c = e > => (fix (succ true)) | < a = e > => (if (\ d : Float . 2) then (< a = "boy" > as B) else (if "apple" then (if false then "apple" else unit) else (succ false))))
(< e = (< a = (succ 0) > as ({ d : A , e : Unit })) > as ((< c : Nat , c : Bool >) -> (Rec A . (Rec E . Unit))))
(({ a = ({ e = 1 , c = a }) , b = (case true of < a = d > => "apple" | < e = d > => (c c)) }) . b)
(< b = (let d = (if (if (let b = 0 in "apple") then "boy" else (if b then "apple" else 1)) then ((pred true) (false . a)) else (iszero 0)) in (\ c : ({ c : A , d : Unit }) . (unit "boy"))) > as ((< d : A , e : Nat >) -> (< a : String , a : C >)))
(if (iszero (< e = ({ b = (let e = 1 in c) , d = true }) > as ((< a : Bool , d : Unit >) -> ({ a : Nat , a : Nat })))) then (succ (let e = "apple" in (\ b : Bool . 1))) else ((fix 2) (succ unit)))
((iszero (let d = (false "apple") in unit)) . e)
(case (\ b : (< b : Nat , d : Float >) . (succ (succ true))) of < d = e > => (case (case 2 of < b = b > => false | < b = a > => (let d = b in b)) of < e = d > => ({ d = (fix "boy") , e = (fix "apple") }) | < d = b > => (1 as Float)) | < e = a > => (iszero ({ c = (if "boy" then a else a) , a = unit })))
(let e = ((succ false) (\ e : Unit . (pred c))) in (fix ({ b = (\ d : (Rec E . Unit) . true) , e = ("boy" as ({ d : C , c : Unit })) })))
(pred (case (case unit of < c = a > => (iszero false) | < d = a > => unit) of < b = d > => (let a = 2 in false) | < d = b > => (pred ({ d = 2 , a = 0 }))))
(fix ((fix true) as (Rec B . Unit)))
(fix ({ e = (succ 0) , b = (let d = true in "boy") }))
(if (({ d = (succ "boy") , b = (case 2 of < d = c > => "apple" | < d = a > => 0) }) as ({ d : ({ e : Float , b : Unit }) , b : ({ a : C , a : Unit }) })) then (case (succ (\ b : Unit . 1)) of < a = a > => ({ a = "boy" , d = 2 }) | < e = a > => (({ e = b , c = unit }) (< d = c > as Bool))) else (iszero ({ e = "apple" , b = (\ e : A . unit) })))
(let b = (if ((iszero "apple") as Unit) then (succ b) else (true . b)) in (succ ((iszero 0) . d)))
(iszero ({ d = (true . e) , e = (\ c : Nat . false) }))
(({ b = (< d = ({ a = false , b = 2 }) > as (Rec D . Unit)) , b = (true . d) }) (< d = (succ false) > as (< e : Unit , e : B >)))
((pred (iszero "apple")) . b)
(pred (if (case (let c = c in b) of < b = a > => (false as String) | < c = d > => (fix "boy")) then (iszero (if (let b = 2 in 2) then (fix a) else b)) else (pred (pred 2))))
(if (fix (succ (let c = unit in unit))) then ((let c = b in unit) (if a then "boy" else c)) else ((< c = unit > as Nat) . b))
(pred ({ c = (< e = (< e = (pred "boy") > as A) > as (C -> C)) , b = (pred (a . d)) }))
(iszero (let b = (succ (2 false)) in ({ c = 1 , a = "boy" })))
(\ a : ({ c : (< a : (Rec E . B) , e : A >) , d : ({ e : (C -> Nat) , a : Float }) }) . (if (fix 2) then (a 0) else (if 1 then true else a)))
(if ((< c = (\ c : Unit . 2) > as (< e : Float , c : C >)) (pred (< b = false > as A))) then ({ a = (if (\ b : String . c) then 1 else false) , e = ((0 . d) as ({ a : A , b : Bool })) }) else (< d = (< a = "boy" > as Nat) > as ((A -> Unit) -> A)))
(succ (iszero (1 . a)))
(< a = (if (pred "apple") then (case 2 of < e = c > => ("boy" . c) | < e = e > => (let d = 0 in unit)) else (let c = 2 in unit)) > as (Rec A . ({ e : (B -> (Rec E . Nat)) , a : (< b : Float , d : C >) })))
(let b = (let a = (iszero c) in (succ 2)) in (if (succ (succ false)) then (fix true) else (< d = unit > as A)))
(< d = ((let e = "boy" in true) . e) > as (((C -> A) -> (Rec D . C)) -> (< d : (Rec D . B) , a : (Rec E . Float) >)))
((\ c : ({ b : (A -> Nat) , e : (Rec B . Unit) }) . (\ a : A . (succ c))) (fix (succ b)))
(< e = (\ b : (Rec B . (< d : Unit , b : (Rec C . Unit) >)) . ({ c = (if (succ a) then (if false then unit else 1) else (succ false)) , e = (if (\ e : Bool . c) then true else 0) })) > as (< b : (Unit -> Float) , a : ({ b : (< b : C , b : String >) , c : ({ b : String , e : Bool }) }) >))
(if (if (0 . a) then (if 1 then (< a = true > as B) else unit) else (iszero unit)) then (\ d : (Rec E . Unit) . (\ a : ({ a : C , d : (Rec B . Unit) }) . (\ d : A . unit))) else ((iszero (case 0 of < d = a > => "apple" | < d = a > => unit)) . a))
(\ b : ((< c : (String -> String) , d : (< a : ({ a : Float , e : A }) , a : (< b : Float , a : Bool >) >) >) -> (< b : (B -> String) , b : (< b : C , d : B >) >)) . (< e = ((< e = a > as Unit) unit) > as (Rec D . B)))
(\ c : (< b : (Rec C . Nat) , c : (A -> Bool) >) . (((pred "boy") (b . e)) as (< d : A , e : String >)))
(((case (\ b : Float . (pred a)) of < a = e > => (case "apple" of < e = b > => false | < c = c > => false) | < b = e > => (< c = c > as String)) (("apple" c) "apple")) . a)
(let e = ((case (unit "boy") of < a = a > => (pred (iszero false)) | < c = e > => (iszero true)) . d) in (((pred "apple") as ({ c : Unit , b : (C -> Float) })) as ({ d : ({ c : Bool , d : Unit }) , d : Bool })))
(< e = (\ a : (Rec B . C) . (case a of < c = e > => b | < e = c > => "apple")) > as (Rec B . (< e : Float , a : C >)))
(case (\ d : (Rec E . ({ a : Unit , a : String })) . (< d = ({ e = 1 , a = c }) > as (< a : A , b : B >))) of < c = d > => (iszero (if (succ false) then (0 . a) else (case a of < c = c > => true | < b = a > => unit))) | < a = c > => (pred (0 . e)))
(\ e : ((< d : Bool , b : (Rec E . Bool) >) -> (Rec E . String)) . ((succ (fix b)) . e))
({ b = ((case false of < c = a > => (\ e : Nat . true) | < d = b > => (false as Bool)) . b) , d = (succ ({ b = 0 , b = 2 })) })
(if (pred (0 as C)) then ({ b = (case c of < a = b > => b | < d = d > => (\ b : C . false)) , b = (case (if 1 then a else b) of < c = c > => (\ a : ({ b : Nat , a : String }) . (\ c : C . 0)) | < b = b > => (\ c : C . c)) }) else (pred ((< d = a > as Nat) as Nat)))
(pred (iszero (< e = (let e = a in 2) > as (Rec A . C))))
(iszero ((\ a : (< b : Nat , d : (< c : C , d : B >) >) . (1 (false false))) . c))
(< d = ((pred true) . d) > as (Rec E . ({ d : Float , e : Float })))
({ d = ({ e = ((pred b) . b) , b = (case (pred false) of < c = e > => false | < b = c > => 2) }) , a = ((case (pred "boy") of < e = c > => (fix b) | < b = b > => "apple") as ((< c : (Nat -> B) , e : (< d : Float , d : Nat >) >) -> (Nat -> Nat))) })
(\ d : (Rec C . (< c : (< b : C , b : String >) , e : (Float -> A) >)) . (case ({ b = 0 , d = "boy" }) of < a = b > => ((true . d) (succ "apple")) | < d = c > => (succ (\ c : Float . c))))
((< a = (pred "apple") > as (Rec E . C)) . c)
(\ b : ((< b : (A -> String) , c : (Rec C . (Rec C . Float)) >) -> (C -> (C -> C))) . ((\ a : (< a : Unit , c : (Rec A . Float) >) . (case a of < c = b > => c | < e = c > => "apple")) as ((Rec D . B) -> C)))
(< a = (pred (\ d : Bool . a)) > as (((Rec A . Bool) -> (B -> Bool)) -> (< b : (Rec D . String) , a : (< c : (Rec B . B) , d : (Rec A . Bool) >) >)))
(iszero (let a = (1 ({ c = c , c = unit })) in (iszero (true "apple"))))
(< c = ({ e = (fix a) , b = (succ (pred 2)) }) > as (Rec B . (Unit -> B)))
(iszero (\ b : ({ b : Float , e : String }) . (iszero false)))
((fix ({ e = (if 0 then unit else unit) , c = (succ a) })) as (Rec A . (< d : (Rec A . A) , a : (< a : String , b : Bool >) >)))
((let c = (\ d : Nat . ({ d = "boy" , c = 2 })) in (< b = a > as Nat)) (\ c : (< c : Float , d : B >) . (0 as ({ d : Nat , d : Float }))))
(case ({ e = (case (pred "apple") of < d = a > => ({ d = a , b = unit }) | < a = c > => (succ 0)) , b = (false as (Rec C . Unit)) }) of < b = c > => ({ a = (\ a : (< d : Float , a : Nat >) . 0) , a = (\ a : (Bool -> Float) . (0 as C)) }) | < b = d > => (let d = (succ unit) in (< c = (let e = 2 in 2) > as (< a : A , d : Nat >))))
(if (pred (succ (< e = c > as String))) then (pred (< c = (false as A) > as String)) else (pred ({ c = (unit . d) , b = (pred unit) })))
(fix ({ e = ({ e = false , c = "boy" }) , d = ((pred b) "boy") }))
(if (succ (if b then b else unit)) then (pred (1 0)) else ({ a = (< a = 1 > as Bool) , b = (iszero (iszero 1)) }))
(succ (fix (\ a : A . a)))
(pred (let e = ({ e = true , d = ({ e = c , c = c }) }) in (fix 0)))
(if (succ (let a = 1 in a)) then (succ (< d = (0 c) > as String)) else (if (false unit) then (< b = a > as (Rec E . A)) else (fix "boy")))
(< c = (\ c : (< e : Unit , b : (C -> C) >) . (\ b : C . "apple")) > as ((< a : Bool , d : String >) -> (< d : C , e : Float >)))
(let b = (succ (< b = b > as Float)) in ((if (if b then c else 0) then (0 1) else "apple") as (C -> (B -> A))))
({ e = (if (< d = (succ true) > as Unit) then (pred (1 2)) else (fix a)) , b = (succ (< b = c > as Bool)) })
(< b = (iszero (succ "boy")) > as ({ c : (Float -> A) , b : ({ d : Nat , a : String }) }))
((iszero (succ "apple")) (fix ((if (\ a : B . b) then (succ 2) else (if a then unit else 0)) as (Rec D . Nat))))
(\ c : (Rec D . ({ e : (Unit -> Float) , a : String })) . (pred (\ c : ({ a : A , c : B }) . ({ b = c , e = "apple" }))))
(let d = (succ (iszero (0 as String))) in ((true as ({ c : Bool , e : Float })) as (({ a : Nat , a : Float }) -> (B -> B))))
(fix (if (< d = 0 > as String) then (a 0) else (iszero false)))
((if (pred (fix 0)) then (if 0 then (\ b : Float . 2) else 0) else (let a = (if true then "apple" else true) in (\ c : String . unit))) . b)
((iszero (succ ({ e = false , a = b }))) . a)
(let e = ((succ (iszero a)) as ({ b : ({ d : A , a : (< c : String , d : Float >) }) , b : (Nat -> B) })) in (let e = (iszero "apple") in (case (let b = "apple" in true) of < b = c > => (< e = "apple" > as Bool) | < e = a > => b)))
(let d = (iszero (true "apple")) in (pred ({ a = (fix ({ d = 2 , b = 0 })) , d = (succ unit) })))
((fix (let d = (pred c) in (0 . c))) . e)
(iszero (({ e = (case "apple" of < e = e > => false | < d = b > => true) , c = 0 }) (pred (< a = a > as A))))
(if (succ (case (\ c : (Rec D . B) . 1) of < b = c > => (if 0 then 2 else false) | < d = e > => (pred (c "apple")))) then (pred (iszero b)) else (\ d : (Rec D . Unit) . ((succ false) as Unit)))
(let e = (if (pred (pred 1)) then (1 as String) else (iszero a)) in (case (succ (iszero a)) of < a = b > => ((if true then "boy" else c) (\ d : B . 1)) | < b = c > => (b 0)))
(if (< a = (< e = 0 > as C) > as (Rec B . String)) then (let e = (< b = (case false of < d = b > => "apple" | < b = d > => 2) > as (< c : Float , d : Bool >)) in (c (0 . e))) else (case (\ c : Unit . (< b = true > as A)) of < d = b > => (let d = "boy" in c) | < e = b > => (case 0 of < c = d > => (succ false) | < a = b > => (< d = a > as Unit))))
((if (pred "apple") then (case true of < a = a > => false | < e = e > => unit) else (false as Unit)) . a)
((fix ((iszero b) as Unit)) . a)
(if ((true (fix b)) . c) then (iszero (case "boy" of < a = a > => "boy" | < d = a > => unit)) else (< a = ({ b = a , e = b }) > as (String -> ({ a : Nat , e : Float }))))
(case (fix (fix (succ (if "apple" then "apple" else unit)))) of < c = a > => ({ b = (case "boy" of < c = d > => 2 | < c = b > => true) , c = (pred b) }) | < c = d > => ((\ a : ({ e : Unit , b : A }) . (if a then 0 else unit)) (case ((a . a) . b) of < d = c > => (1 0) | < e = b > => (case (2 . d) of < d = b > => "apple" | < e = b > => (case b of < a = e > => false | < d = d > => 0)))))
(let d = ((("apple" as String) . c) as (< c : ((Rec C . Unit) -> B) , e : (Rec A . (< d : Nat , a : Float >)) >)) in (case (if false then 0 else 2) of < d = d > => (\ a : Nat . c) | < b = e > => ("boy" . a)))
(if (case ({ d = unit , d = false }) of < b = d > => (pred "boy") | < a = c > => ("apple" . e)) then ((case ((pred "apple") ({ e = unit , c = 0 })) of < e = c > => (fix (pred "boy")) | < b = b > => (iszero a)) (let e = ("boy" "boy") in (succ (succ "apple")))) else ((({ d = 2 , e = 0 }) as (< e : Float , d : Unit >)) . b))
(iszero ({ e = (2 as C) , a = (case false of < d = d > => "boy" | < e = a > => "apple") }))
(fix (let e = (true . e) in (succ unit)))
(let e = (pred ((\ d : (A -> Bool) . 2) (succ "apple"))) in (succ ((unit . b) as (Rec B . Bool))))
(let a = (((case unit of < c = a > => "apple" | < a = b > => unit) c) . e) in (case (succ (b 1)) of < b = e > => (< e = 0 > as C) | < c = c > => (pred (\ e : Bool . 1))))
(< e = (if (succ unit) then (pred "boy") else (1 unit)) > as (< c : (({ b : Float , d : Bool }) -> ((A -> C) -> Float)) , b : ({ d : String , a : ({ d : Float , c : Float }) }) >))
(let e = (case (< c = (fix false) > as ((String -> Bool) -> Nat)) of < d = b > => (< e = c > as (Rec E . Float)) | < e = a > => (fix (iszero "boy"))) in (iszero (succ (succ a))))
((\ d : (< c : String , d : String >) . ((case "apple" of < b = d > => unit | < c = a > => unit) . b)) as (((Float -> C) -> (C -> Bool)) -> ((Bool -> C) -> (< a : ({ e : String , b : C }) , a : C >))))
(pred (if ((\ a : C . b) (succ c)) then (\ a : (< a : A , d : Nat >) . (2 2)) else (succ (< e = 1 > as A))))
(succ (iszero (succ (let e = b in false))))
(fix ({ b = (if 2 then 0 else (if "apple" then unit else b)) , b = (fix 1) }))
(iszero (case (pred 2) of < d = e > => (iszero 2) | < c = e > => (true . a)))
(pred (fix (< b = "boy" > as (< d : B , d : String >))))
(\ b : (< e : (Nat -> Unit) , e : ({ e : Bool , a : B }) >) . (< c = (\ a : Bool . 0) > as (A -> Nat)))
(if (< e = (unit as B) > as (< a : String , b : C >)) then (iszero ((succ unit) . c)) else (iszero (succ (iszero a))))
(if ((if (\ a : (C -> A) . ("boy" . c)) then (\ d : (String -> C) . c) else (if true then c else unit)) as (< a : (Rec C . String) , b : ({ c : String , c : A }) >)) then (fix (\ e : (< a : Nat , a : Bool >) . (case "apple" of < e = e > => "boy" | < a = d > => "boy"))) else (case (succ c) of < a = a > => (pred b) | < c = b > => ((succ true) as (< c : Unit , e : String >))))
(succ (if (\ a : Nat . 2) then (\ d : (String -> B) . a) else (case (succ true) of < e = d > => c | < a = a > => (case 0 of < b = a > => false | < a = b > => 2))))
(< c = (\ a : (Nat -> String) . (fix (0 as A))) > as (Rec D . (Rec C . (Bool -> Unit))))
(\ a : (< b : (Nat -> Nat) , d : (Rec D . (Rec A . A)) >) . ((if true then (let b = 2 in a) else 0) . b))
(if ((< e = (fix "boy") > as ({ b : Float , c : Nat })) as ({ a : (< b : (B -> C) , b : A >) , a : (< b : Unit , e : String >) })) then ((case "boy" of < c = e > => 2 | < c = e > => true) . b) else (pred (pred 2)))
(if ({ a = ((let b = a in c) . b) , a = (pred (iszero (case 2 of < b = e > => c | < e = b > => 1))) }) then (case ({ d = true , e = c }) of < c = c > => (case a of < d = d > => 0 | < d = b > => false) | < b = d > => (1 "apple")) else ((\ e : Unit . "apple") . c))
(((unit as Float) . a) as ((< d : (Float -> C) , e : Nat >) -> ({ a : Float , a : (String -> Float) })))
(case ((fix a) (succ b)) of < b = a > => (iszero (0 . e)) | < e = b > => (fix ({ d = (pred "boy") , e = ({ d = false , c = unit }) })))
(if (fix (succ c)) then (< a = (fix true) > as ((Unit -> Bool) -> (Unit -> Bool))) else (< b = (< d = (2 . c) > as Nat) > as ({ a : Bool , e : Unit })))
(pred (case (let a = (c as A) in (succ false)) of < e = c > => (iszero (pred 2)) | < b = d > => ((if true then false else "apple") . e)))
(fix (if (succ b) then (unit as Bool) else (pred (case b of < d = b > => b | < a = c > => c))))
((if (fix (fix b)) then ((case 2 of < b = c > => b | < d = a > => "apple") 1) else ("apple" . d)) as (< c : (({ b : Unit , c : Nat }) -> Nat) , d : (Unit -> Float) >))
((let b = (\ c : (C -> (< b : Unit , d : Bool >)) . ((< b = unit > as Bool) as (< b : Float , b : Bool >))) in ((succ (0 as Nat)) (succ false))) . e)
({ a = ((1 . b) as (< d : (Rec B . A) , e : (A -> Unit) >)) , d = (let c = ((pred "apple") . e) in ({ e = false , e = unit })) })
((succ ((pred true) . a)) as ((Rec A . String) -> ({ b : Float , e : ({ c : B , a : String }) })))
((let d = (if (1 . e) then "boy" else (1 as Unit)) in (\ e : (String -> Unit) . (iszero "boy"))) . c)
(< c = ({ c = (succ (unit . b)) , e = ({ e = true , e = 1 }) }) > as (Rec C . (Rec E . (Rec E . C))))
({ b = (fix (fix a)) , a = ((< e = (2 . b) > as Unit) as (Nat -> Nat)) })
({ e = (iszero (succ ({ b = "boy" , b = 1 }))) , c = ((fix ({ a = (pred "boy") , d = 2 })) as ((Rec B . Bool) -> A)) })
(case (iszero (\ c : Unit . true)) of < b = d > => (pred ((< a = a > as Bool) as (< a : C , b : (Rec D . C) >))) | < b = a > => (let d = (let c = true in a) in (pred (\ b : Float . unit))))
(((\ e : C . "apple") (let c = (c "apple") in true)) (fix (if (fix true) then 0 else false)))
(if (("apple" false) (case (iszero false) of < d = d > => (if a then true else unit) | < d = a > => (succ false))) then (iszero (succ (iszero false))) else (\ c : ((Bool -> Bool) -> ({ e : Nat , b : Float })) . (\ a : ({ e : Unit , a : C }) . (if a then (if c then true else a) else b))))
((succ (pred "boy")) . d)
({ b = (pred (if (succ true) then "apple" else a)) , c = (if (\ c : A . true) then (case b of < e = b > => "apple" | < e = c > => c) else ({ d = unit , c = 2 })) })
(case (case (unit as ({ c : Nat , b : B })) of < c = d > => (fix (fix 1)) | < c = c > => (let a = (2 . c) in (case c of < b = b > => 1 | < b = c > => c))) of < c = c > => ((({ d = 2 , e = "apple" }) . c) (case true of < e = b > => ({ e = c , b = c }) | < c = a > => (pred false))) | < d = c > => ({ a = (let a = (c as Unit) in (case 2 of < d = e > => a | < e = b > => false)) , e = (pred 1) }))
(case (fix (pred (succ (iszero c)))) of < c = c > => (< d = (true as (Rec E . String)) > as (< d : Bool , a : B >)) | < a = c > => ((b (\ b : Float . true)) (let e = "boy" in false)))
(< a = (if (fix 1) then (0 unit) else (b b)) > as (Rec B . (Rec D . (< e : Nat , e : Float >))))
(case (if (< b = (a false) > as String) then (pred (pred (if true then "apple" else 2))) else (case (\ e : Unit . 0) of < a = d > => (case (let d = 1 in "boy") of < e = b > => b | < c = e > => "boy") | < e = e > => (pred a))) of < b = d > => (let b = ((if "apple" then b else b) (iszero true)) in (\ c : ({ b : String , e : Float }) . (let a = "boy" in 0))) | < c = d > => ((case (iszero false) of < d = c > => (pred "boy") | < a = b > => (if 0 then 1 else "boy")) . b))
(case ((unit . d) as (< a : (Rec D . Float) , e : (< d : Nat , d : String >) >)) of < a = d > => (< d = (case (pred c) of < b = a > => (fix 1) | < c = b > => (succ (1 c))) > as (< d : (Rec E . B) , a : (Rec C . String) >)) | < a = b > => (let b = (let e = (if unit then 2 else "boy") in c) in (pred b)))
(succ ((< c = (fix unit) > as ((Float -> Bool) -> (Rec B . B))) . e))
(\ b : (< c : (Rec E . ((< e : Float , a : C >) -> ({ b : Bool , a : A }))) , a : (< a : Nat , a : (Rec B . Bool) >) >) . ((iszero (false . a)) . c))
(if (case (fix a) of < d = a > => (({ e = true , b = true }) as A) | < e = e > => (c b)) then (let b = (((fix false) . d) . b) in (case 0 of < b = c > => c | < d = e > => true)) else (fix (\ a : Unit . false)))
(\ b : ({ a : (< b : ((B -> C) -> (< b : String , b : Unit >)) , c : (Rec D . (Rec E . Float)) >) , e : ({ d : (< d : Nat , a : Unit >) , d : ({ b : B , c : C }) }) }) . (if (\ a : (String -> C) . false) then (if ({ c = c , e = (fix false) }) then (let e = (1 . b) in (2 true)) else (succ false)) else (fix (case (2 0) of < e = a > => (let a = "apple" in false) | < c = c > => true))))
(< a = (pred (c unit)) > as (< c : (< d : ({ a : A , d : String }) , e : Float >) , a : (< b : Unit , c : Float >) >))
((iszero (((< a = false > as String) as (< b : Bool , e : Bool >)) as ({ c : Float , a : String }))) ((2 . d) (case false of < e = b > => "apple" | < c = a > => (fix true))))
(let a = (fix ({ d = 2 , a = c })) in (let c = (succ 1) in (unit . b)))
(((if (case false of < b = e > => c | < c = e > => true) then (fix 2) else (if 1 then unit else c)) (fix (iszero (pred 2)))) . e)
(< b = (fix (let e = (unit c) in (let e = a in a))) > as (Rec E . ((Rec A . Bool) -> ({ c : Unit , d : Unit }))))
(if (< c = (if ({ b = true , d = (succ 2) }) then (pred (pred 1)) else (\ d : String . 1)) > as ((Rec D . (Rec D . C)) -> ((A -> Unit) -> (Rec D . Float)))) then (let e = (iszero (let b = (\ d : String . false) in unit)) in ((b as String) 2)) else ((succ c) as ({ a : (B -> Bool) , d : (C -> C) })))
(if (fix (case ({ a = "boy" , a = (< e = a > as Unit) }) of < b = b > => ({ b = (false . e) , d = (let e = 2 in false) }) | < b = d > => (\ c : Float . (let e = a in 1)))) then (pred (if a then "boy" else ("boy" as String))) else ((b 1) . d))
(case (pred (< e = (< a = "apple" > as String) > as (String -> Float))) of < c = e > => (succ (1 as String)) | < a = e > => ((if (true false) then (case 2 of < e = c > => b | < a = d > => "apple") else (let b = 0 in "apple")) ((b . c) as (< a : B , a : String >))))
(\ b : (Rec C . (Unit -> C)) . (if (pred (case c of < d = c > => false | < a = c > => (iszero unit))) then (\ a : (A -> B) . (case (fix unit) of < b = e > => 0 | < c = d > => 0)) else (fix (case a of < b = a > => 1 | < d = b > => unit))))
(let b = (("apple" 2) ("apple" . d)) in ((fix a) as ({ e : Bool , b : Unit })))
((< c = ((iszero true) . e) > as (< a : ({ d : Bool , a : A }) , a : (Rec C . Unit) >)) . c)
((if (if false then a else false) then ({ c = true , e = false }) else (let c = 0 in ({ a = 0 , b = true }))) as ((Rec D . Nat) -> (Rec E . C)))
(if (("boy" as String) (if c then "boy" else a)) then (iszero (a 1)) else (iszero ({ e = (pred true) , b = (iszero (if true then a else "boy")) })))
(pred (iszero ({ d = unit , b = 2 })))
(case (if (if b then (1 . a) else (0 unit)) then (if c then true else true) else (fix "boy")) of < e = a > => (let e = (1 . e) in (let e = false in "apple")) | < b = a > => (let a = (2 as (Rec E . C)) in (iszero (let d = b in (case false of < b = a > => true | < c = b > => true)))))
((if ((pred "apple") (let d = a in "apple")) then (({ c = (unit as B) , c = b }) . c) else (fix 0)) . e)
(let a = (fix (unit . d)) in ((fix b) as (< d : Nat , c : Unit >)))
(iszero (pred (1 1)))
(let b = (< a = (iszero (iszero 0)) > as (< c : (< a : A , a : A >) , b : (Rec A . A) >)) in ((< d = (iszero false) > as Bool) . b))
(\ b : ({ c : ({ c : ({ d : (< a : A , e : Unit >) , c : (B -> C) }) , b : (Rec C . Unit) }) , c : ({ c : (Bool -> Unit) , c : ({ d : Float , e : Float }) }) }) . (case (let c = 0 in true) of < b = a > => (succ 0) | < c = b > => (fix b)))
(< b = ({ d = (iszero c) , a = (let c = "apple" in 2) }) > as ((Float -> ({ e : Float , a : A })) -> ({ c : A , d : A })))
(succ (\ a : (Rec E . (Nat -> Unit)) . (case 0 of < b = c > => unit | < b = e > => c)))
(< e = (if (iszero (succ true)) then (succ 1) else (\ a : Bool . "apple")) > as (Rec A . (< e : Unit , b : (Rec A . Nat) >)))
(({ a = (succ ({ b = unit , e = 1 })) , b = (< e = 0 > as String) }) (\ c : (< a : Unit , a : String >) . (iszero c)))
(let c = (let c = ("boy" (succ 1)) in (\ d : Bool . c)) in (fix (1 (b . c))))
(if (iszero ({ d = 1 , a = (pred 2) })) then (pred (if (unit false) then c else 1)) else ((succ (pred a)) . e))
(if (pred (if a then c else "apple")) then (case (if "boy" then c else (iszero false)) of < c = a > => (fix ({ d = true , b = (let c = "apple" in false) })) | < a = a > => ((fix 2) as Bool)) else ((unit . b) ("apple" . a)))
(< d = (< a = (fix 0) > as (< a : B , d : A >)) > as ({ b : ((Rec B . Bool) -> (B -> Float)) , c : ((< b : Bool , c : String >) -> Bool) }))
(let a = (succ (succ "apple")) in ((pred c) (let e = 1 in a)))
(\ a : (Rec E . (Rec E . B)) . ((if (fix false) then "boy" else true) as (B -> Unit)))
(case (\ c : (Rec D . ({ d : (< b : String , b : Nat >) , b : A })) . (2 as Float)) of < e = e > => (pred (fix false)) | < a = b > => (\ b : (Rec D . Unit) . (pred true)))
(((iszero 0) (pred (if ("boy" . a) then (succ unit) else ({ e = false , d = 0 })))) (\ b : ({ e : Unit , d : Bool }) . (pred c)))
({ d = (fix (if b then b else (false as Float))) , c = (fix (pred (2 . a))) })
(fix (pred (pred 0)))
((if (a as (< b : Float , d : A >)) then (pred "apple") else (if "boy" then b else "boy")) as (< b : ({ e : ({ b : Float , b : String }) , b : ({ b : Unit , c : Unit }) }) , b : (Rec B . A) >))
(< c = ({ e = ({ e = ({ d = false , e = unit }) , c = "boy" }) , a = ((< c = true > as String) . d) }) > as ((String -> ({ a : C , a : A })) -> (Rec B . (Rec B . ({ d : Unit , a : Nat })))))
(case (\ b : ({ e : String , a : Float }) . (true . b)) of < e = b > => (< b = (unit as Bool) > as ({ e : Bool , c : B })) | < e = a > => (iszero ((< a = "boy" > as Float) as (Bool -> Unit))))
(pred (succ (succ (if unit then (let e = "apple" in c) else ({ d = b , e = b })))))
({ a = (let a = (let a = (false . b) in unit) in ({ d = (pred "apple") , c = (iszero (if "boy" then b else unit)) })) , b = (({ e = (iszero 1) , d = "boy" }) (pred ({ a = unit , c = (< d = true > as C) }))) })
(iszero (iszero (< d = (b as C) > as Float)))
((\ b : (B -> (Rec E . Float)) . (case 2 of < b = e > => 2 | < b = e > => c)) as ({ c : (Rec C . B) , c : ({ a : Unit , b : Nat }) }))
(< c = (iszero (< c = "boy" > as String)) > as ({ c : (< b : C , e : Nat >) , c : ({ c : Unit , d : Unit }) }))
(< c = (pred (pred (unit unit))) > as (< d : (< e : String , e : ({ d : Nat , a : C }) >) , a : ({ a : String , a : (Rec A . Bool) }) >))
(case (succ (let d = (iszero true) in (2 as Bool))) of < e = b > => (iszero ((\ e : ({ a : B , d : B }) . 0) as (Unit -> C))) | < b = d > => (succ (iszero 2)))
(iszero (\ e : (< d : (String -> Unit) , a : Nat >) . (if false then b else (1 . c))))
(fix (case (case (if 0 then true else b) of < c = c > => b | < c = a > => (let a = "apple" in 2)) of < d = b > => (succ unit) | < b = e > => (pred c)))
(pred (case (iszero (succ unit)) of < a = e > => (fix 0) | < a = a > => (pred 2)))
(succ (pred (\ c : B . a)))
(let e = (if (("boy" as Bool) . a) then ((let d = b in unit) as ({ b : A , c : Bool })) else (iszero (pred 2))) in ({ a = ({ b = 0 , c = ({ e = 2 , e = 2 }) }) , e = (pred (b . c)) }))
(if (if (pred (< c = false > as Unit)) then (succ b) else (let b = (< c = "apple" > as (< e : Nat , c : Nat >)) in ((case false of < b = a > => a | < b = e > => true) (if a then c else c)))) then (case ((fix 1) (pred false)) of < d = d > => ((iszero (case 0 of < d = d > => 1 | < d = b > => a)) . a) | < e = b > => (pred (succ 1))) else (if (if (iszero c) then (< e = b > as Bool) else (succ "apple")) then (fix (let a = "boy" in a)) else ({ c = 1 , e = true })))
(iszero (fix (iszero true)))
(iszero ({ e = (fix c) , d = (pred unit) }))
((< a = (fix b) > as (< a : Unit , e : C >)) as ((< b : String , b : B >) -> (Rec C . A)))
(fix ({ a = (< a = 0 > as A) , a = (\ c : Nat . unit) }))
(case (let b = (pred (< e = 0 > as C)) in (c . e)) of < e = d > => (let b = (iszero ("boy" as C)) in (iszero (case (c "apple") of < d = a > => ({ c = b , a = "apple" }) | < c = d > => (fix "boy")))) | < a = c > => ((case c of < e = d > => (succ unit) | < d = a > => (\ d : A . true)) as (Rec E . Unit)))
(iszero ((fix (2 . a)) as (Rec C . ({ a : (< a : String , d : C >) , b : (A -> String) }))))
(if ((let d = "boy" in 0) as ((< a : C , c : B >) -> ({ a : A , a : Nat }))) then (case (\ c : String . b) of < a = c > => (succ (let c = 2 in 1)) | < e = b > => (\ a : String . unit)) else (pred ((succ (succ "apple")) (< a = unit > as C))))
(({ a = (c . c) , d = (let a = "boy" in 2) }) (iszero (let e = (if a then c else 0) in true)))
(({ d = (< c = (true as Nat) > as ({ b : ({ a : C , e : C }) , a : A })) , b = (succ (< c = (if 2 then 1 else b) > as Nat)) }) . b)
(case (let b = (case "apple" of < a = c > => (fix 2) | < b = c > => (c . a)) in ((true "apple") as String)) of < c = c > => (succ (\ c : (Rec C . C) . (a . b))) | < e = d > => ({ b = (iszero ("apple" as Bool)) , a = (case (true as Unit) of < c = c > => c | < d = d > => (\ b : Unit . "apple")) }))
(pred (succ (case (iszero (iszero "apple")) of < b = e > => (if unit then 1 else 1) | < a = d > => (if (2 as Unit) then false else b))))
(pred (< c = (({ d = "apple" , e = c }) as C) > as (Rec D . (< a : C , a : B >))))
(((iszero "apple") . a) as (< e : (< d : Unit , c : (< d : Bool , a : String >) >) , b : (Rec E . String) >))
({ c = (succ ((fix "apple") . e)) , b = (let e = ({ d = (\ a : Unit . "apple") , a = ("boy" as Nat) }) in ("boy" as Unit)) })
(succ (case (true . a) of < e = e > => (fix b) | < c = b > => (if (iszero "boy") then (c . b) else a)))
((((< e = 2 > as Unit) as (< e : B , a : Bool >)) . d) ((let e = unit in (< b = "apple" > as A)) (case 0 of < a = d > => 2 | < e = e > => "boy")))
(pred (fix ({ c = false , c = (iszero 2) })))
(fix (pred (false true)))
((iszero (succ (< b = unit > as Bool))) as (({ a : ({ b : Unit , a : ({ e : A , e : Float }) }) , d : ({ a : B , a : Float }) }) -> ({ a : (Nat -> Float) , a : (String -> A) })))
(let c = (pred (< a = "apple" > as Unit)) in (if (succ "apple") then ("boy" . b) else (if a then c else c)))
((fix (succ ("apple" as Unit))) as (< d : (Rec A . (Rec D . B)) , b : (Rec A . (Rec E . Nat)) >))
((fix ((pred 1) . c)) as (Rec C . (Rec B . C)))
((if (0 as (< e : Bool , b : Float >)) then ((succ "boy") . c) else (1 . b)) as ((Rec D . (Rec A . Nat)) -> (< a : (({ a : String , b : String }) -> ({ a : Unit , e : Unit })) , b : (Rec D . (A -> A)) >)))
(succ (succ (let c = unit in b)))
(fix (pred ((unit as String) as A)))
(succ (pred ("apple" "apple")))
(succ (case ({ d = true , e = "boy" }) of < e = b > => ((case 2 of < b = a > => "boy" | < c = d > => b) 2) | < e = e > => (< e = 0 > as (Rec C . String))))
(succ (if (let d = (\ e : (Rec A . Nat) . true) in ((pred "apple") as A)) then ((fix b) . a) else ((b as String) (pred false))))
(fix (if (fix false) then ({ a = (case 0 of < e = a > => "boy" | < a = e > => b) , c = (\ c : String . true) }) else (let c = (iszero true) in ("boy" as String))))
(pred (pred (< b = (if a then unit else "boy") > as ({ b : B , d : Float }))))
(pred (pred (\ e : ({ a : (String -> B) , a : A }) . (succ unit))))
(if ((iszero "apple") . e) then (\ c : (A -> String) . (2 as C)) else (succ (iszero 1)))
((succ (false as A)) . d)
(succ ((fix "apple") as (< c : Float , b : B >)))
(if (< e = (fix true) > as (Rec C . C)) then ((let d = 0 in false) (case c of < e = a > => (pred b) | < a = b > => "apple")) else (case (if (iszero unit) then (fix 2) else 1) of < d = b > => (pred false) | < a = e > => (0 (false . a))))
((((unit as Bool) ("apple" as B)) . e) as (Rec C . (Rec C . (Rec A . ({ c : Bool , e : A })))))
((fix ((fix false) ("boy" as Bool))) . e)
(succ (succ (iszero (fix (\ d : Nat . 2)))))
(if (((fix (true . a)) (succ 2)) (let c = (2 unit) in (let a = (pred a) in (pred 0)))) then (case (case false of < a = b > => 0 | < e = c > => c) of < b = e > => (succ true) | < b = b > => ((case unit of < a = d > => "boy" | < e = c > => 0) as ({ d : C , e : Bool }))) else (pred (let e = true in b)))
(fix (case (\ c : (< b : C , e : (< c : Bool , b : Bool >) >) . (iszero 1)) of < d = a > => (a a) | < c = e > => (c as B)))
((if ("apple" as ({ d : Bool , b : A })) then (< d = "boy" > as (Rec E . Unit)) else (a false)) as (< a : ({ c : (Nat -> String) , b : ({ c : A , d : Nat }) }) , b : ({ c : ({ d : Float , e : String }) , b : (Rec A . Float) }) >))
(let b = ((succ (succ (\ c : Unit . a))) . e) in (succ (fix ({ c = false , e = b }))))
((("boy" . c) . e) . a)
(succ (fix (\ b : ({ d : Float , b : ({ b : String , e : Nat }) }) . (if (case 2 of < e = e > => 0 | < b = e > => c) then (true . d) else (iszero unit)))))
(let c = (pred (c . c)) in (\ c : (({ b : Unit , b : C }) -> (Rec A . Float)) . (b as (Unit -> C))))
(((\ c : Bool . c) as (< a : Nat , a : B >)) . d)
({ d = (((let e = (fix b) in (fix false)) . c) as ((< c : (< b : Unit , c : Bool >) , b : (Rec C . B) >) -> (Float -> Unit))) , a = (< e = (case (iszero 1) of < d = d > => c | < c = d > => true) > as (({ b : B , b : String }) -> (Rec B . C))) })
(if ((< a = "boy" > as (B -> Nat)) as ((Bool -> Bool) -> (Rec B . ({ e : Bool , e : Nat })))) then (((\ a : Nat . true) (let b = ({ c = "apple" , a = c }) in unit)) . c) else ((if (if c then "apple" else 2) then (< c = 2 > as B) else (pred unit)) . e))
({ b = (fix (< b = unit > as Float)) , d = (if ("boy" b) then (b . c) else (iszero "apple")) })
(iszero (pred (pred (iszero 0))))
((("boy" . b) (iszero (fix "boy"))) (succ (iszero (case "boy" of < e = c > => 2 | < e = a > => c))))
((({ b = (case 1 of < c = a > => a | < d = a > => 0) , e = 1 }) (iszero ("boy" as B))) (iszero (pred (fix 0))))
(case ({ b = ((succ a) "apple") , b = (if 0 then (if false then "apple" else "boy") else (let c = a in c)) }) of < b = c > => (if (succ false) then (let b = 0 in 1) else (succ "boy")) | < c = b > => (\ c : (Rec C . (< d : C , d : String >)) . (({ e = "apple" , e = a }) unit)))
(let d = (let c = ((\ c : ({ a : Bool , b : C }) . (< d = unit > as Float)) (fix 1)) in (iszero (\ a : Float . true))) in (let a = (case true of < e = a > => (succ false) | < c = a > => (iszero 1)) in (case 2 of < a = c > => 0 | < a = c > => "apple")))
(let b = ((case (2 as Unit) of < e = c > => (pred 1) | < e = e > => (if a then 1 else true)) . d) in ({ e = (\ c : (Rec A . Float) . ({ c = a , b = true })) , a = ({ b = unit , b = 0 }) }))
(({ e = (if (if "apple" then 0 else c) then (case unit of < c = d > => (let e = b in b) | < e = a > => (< a = "boy" > as A)) else (false "apple")) , a = (\ a : (< c : String , e : String >) . (fix (fix 1))) }) as ((Rec B . String) -> (A -> Nat)))
((if (case "boy" of < c = a > => ({ a = 0 , e = 0 }) | < e = d > => 0) then (let d = 0 in 2) else (iszero ("boy" as C))) ((c . d) (\ c : (Rec D . Unit) . (fix 0))))
(((case b of < d = b > => (< e = "apple" > as B) | < c = d > => 0) (true as A)) as (< b : ({ b : (Bool -> Bool) , d : (B -> B) }) , a : (Rec D . (< e : A , e : String >)) >))
(case (if (case (iszero b) of < c = a > => ((succ b) . c) | < e = b > => ((\ e : Unit . "apple") . e)) then (pred true) else (case (succ a) of < c = d > => a | < b = c > => 2)) of < d = d > => (let d = (if (let b = unit in a) then 2 else 1) in (case ({ a = ({ a = "apple" , a = a }) , b = (fix c) }) of < a = b > => (< e = (if 0 then 2 else a) > as Float) | < c = d > => (pred unit))) | < c = e > => (fix (("apple" . c) 0)))
(if (let e = (a . d) in (< b = (b 1) > as C)) then (iszero (iszero "boy")) else ({ e = (case ((succ unit) . d) of < c = b > => (pred a) | < e = d > => ((< d = c > as Nat) . e)) , b = (\ d : C . (pred 1)) }))
((case (succ true) of < e = c > => ((pred c) . c) | < b = e > => (< a = 2 > as (Rec A . A))) as (< d : ({ c : Float , b : Bool }) , d : (< b : Bool , c : Bool >) >))
(if (let a = (({ b = (let d = 0 in b) , b = ({ c = b , e = b }) }) . a) in (\ e : String . 2)) then ({ e = (pred "boy") , b = (1 . d) }) else (if ("boy" as A) then (case 2 of < c = e > => b | < c = c > => true) else (let c = (case 1 of < b = a > => false | < c = d > => "apple") in ({ d = true , e = c }))))
(case (fix (\ d : Bool . (iszero "boy"))) of < d = d > => ((iszero (fix unit)) . a) | < d = a > => (iszero ({ a = (let e = 2 in 2) , b = c })))
((fix (a . b)) (\ d : ({ a : Unit , e : C }) . ("boy" 0)))
(if (< b = (iszero b) > as ({ c : String , a : (< c : A , c : Float >) })) then (iszero (fix ({ e = ({ a = unit , e = c }) , e = true }))) else (case (if b then (if false then a else 0) else a) of < d = e > => (succ (< a = 0 > as Nat)) | < a = e > => (1 as (< b : B , d : Float >))))
