((fix (2 . c)) (succ (case (if (fold [ Nat ] false) then "apple" else a) of < d = c > => (\ b : String . b) | < e = e > => (\ a : B . a))))
(case ((pred (pred (\ d : Float . 1))) as (< e : (Rec C . C) , a : (Rec A . (Bool -> B)) >)) of < c = b > => (iszero ("apple" b)) | < d = c > => ((let c = a in 1) as (< b : (Rec D . B) , b : (Float -> B) >)))
(if (pred (case (case b of < d = e > => "boy" | < d = d > => c) of < c = a > => (if 1 then unit else "apple") | < e = b > => "apple")) then ((fold [ Nat ] false) . e) else (< e = (if a then 1 else c) > as ({ b : (B -> A) , c : (< a : (Rec E . C) , a : String >) })))
(let b = (fix (0 . e)) in (if (pred "boy") then (pred (fold [ Nat ] b)) else ((pred unit) . c)))
(\ b : ({ b : ((< e : (< c : B , d : B >) , c : B >) -> ((B -> Nat) -> Nat)) , c : (< a : (A -> Unit) , b : B >) }) . ((pred (let c = unit in true)) . e))
({ c = (let c = ({ d = unit , e = 0 }) in ("apple" . e)) , a = ((if false then (iszero b) else (\ e : Float . 1)) as (Rec B . ((< e : Unit , b : Bool >) -> (Float -> Nat)))) })
(< a = (case (unit . e) of < a = d > => (< a = ({ c = unit , a = true }) > as Float) | < a = b > => (let a = (let e = "apple" in "apple") in (0 as Bool))) > as (((B -> B) -> String) -> ({ c : Nat , e : A })))
(pred (fold [ (< e : (Nat -> Unit) , a : (Rec B . Bool) >) ] (unit b)))
(({ d = (iszero (unfold [ Float ] unit)) , a = (if "apple" then (unfold [ Float ] 2) else true) }) . e)
(pred (case (2 (1 as A)) of < c = d > => (\ a : Unit . a) | < e = a > => (case 1 of < c = e > => (\ c : Unit . 0) | < d = b > => (a . e))))
(iszero (succ (pred "boy")))
(unfold [ (Rec E . (< e : (< d : Nat , a : String >) , e : (< b : Float , e : Bool >) >)) ] (unfold [ ({ c : Unit , c : C }) ] ((\ c : Bool . c) as ({ d : Nat , c : Unit }))))
({ e = (unfold [ ({ b : A , a : B }) ] (< b = false > as Unit)) , c = ((let a = c in (succ "boy")) (fix b)) })
(\ c : ({ e : (< c : (< d : Unit , d : A >) , b : (C -> Float) >) , b : (Rec E . (< a : B , a : B >)) }) . (fold [ (Rec A . (< c : Bool , c : ({ c : Float , e : Unit }) >)) ] (< e = (if false then b else false) > as (C -> C))))
(< d = ((case 2 of < c = d > => 2 | < e = a > => unit) ((let b = unit in 1) . e)) > as ((< a : Nat , b : (Rec B . A) >) -> (Rec E . A)))
(fold [ (Rec D . (Rec D . (Rec B . A))) ] (< d = ((fix (2 0)) . a) > as (Rec D . (< c : C , c : Bool >))))
(let d = (< c = (fix (unit as (< a : Nat , e : Nat >))) > as (< b : Bool , b : Nat >)) in (succ (succ (succ unit))))
(fold [ (< c : ({ b : Unit , b : B }) , b : (Rec D . ({ e : A , a : String })) >) ] (iszero (let d = "boy" in "apple")))
(unfold [ (Rec E . ({ a : (String -> Unit) , a : (Nat -> C) })) ] (unfold [ (Rec C . Nat) ] ({ e = true , e = 0 })))
(if ((if "apple" then "apple" else "apple") (iszero false)) then (if (< d = (true . e) > as (Rec B . C)) then (if ({ d = true , a = false }) then (2 as C) else (fold [ Float ] 1)) else (c . e)) else (unfold [ (A -> String) ] ({ e = 0 , a = "boy" })))
((let b = (\ d : (< c : C , d : (C -> Float) >) . ((succ "apple") 0)) in (unfold [ ({ d : Unit , d : Bool }) ] (c . d))) (unfold [ (({ b : Unit , a : A }) -> Float) ] (fix ({ b = "apple" , d = (fold [ Bool ] a) }))))
(unfold [ (Rec D . (Rec D . Unit)) ] (let d = (pred (0 as Unit)) in (< d = (case true of < a = b > => b | < e = c > => c) > as Bool)))
(pred (({ c = 0 , a = 1 }) as ({ b : (Rec E . (A -> String)) , a : (< e : A , d : B >) })))
(let e = (if ((a . c) as (Bool -> Nat)) then (case (pred 2) of < a = c > => (unfold [ Unit ] "apple") | < b = c > => false) else (2 a)) in (fix (fold [ (< d : B , b : C >) ] (fix "apple"))))
(let d = (if (let a = (if true then 1 else b) in (let e = (succ true) in (unfold [ Nat ] "boy"))) then (let b = ({ c = false , c = false }) in (succ 0)) else (fix false)) in ((fold [ Float ] "apple") . b))
(if ({ e = (unfold [ (Rec E . String) ] (case a of < c = c > => a | < b = d > => b)) , e = (< e = (fold [ Float ] b) > as (Rec B . Unit)) }) then ((< d = 2 > as B) (iszero "boy")) else ((iszero (if ({ d = 1 , b = "boy" }) then (unfold [ Unit ] "boy") else unit)) (< b = (if "boy" then a else 2) > as (< a : C , a : String >))))
(\ c : (({ b : (< d : C , a : Float >) , d : ({ e : Bool , d : C }) }) -> (< d : (< c : Unit , c : A >) , d : ({ b : Nat , e : A }) >)) . (iszero (succ a)))
((if (fix 2) then (\ d : C . (let d = false in c)) else (case a of < d = e > => (fold [ Nat ] a) | < c = e > => 0)) as ({ a : (String -> (Rec C . String)) , c : ({ a : Bool , a : String }) }))
(((pred (case (fix c) of < c = d > => b | < b = c > => unit)) as (Rec E . ({ e : ({ d : C , c : Unit }) , d : Bool }))) as (Rec A . ({ e : Nat , c : (Rec C . A) })))
(fold [ (< b : (< a : (< e : Nat , a : String >) , b : (Unit -> A) >) , e : (Rec A . (Rec E . A)) >) ] (pred (fold [ C ] 1)))
((if (({ a = (pred 2) , b = "boy" }) (\ e : Float . 2)) then ((pred c) . a) else ((succ b) as ((Rec A . Bool) -> (< e : C , e : String >)))) as ((< e : B , b : (< d : B , b : Bool >) >) -> (Float -> B)))
(((({ e = true , a = a }) . a) as ({ c : (String -> Bool) , b : (< e : (Rec A . Float) , a : Nat >) })) as (Rec D . (< e : Float , e : Bool >)))
(if (\ e : ((< b : Unit , d : Float >) -> (< e : Unit , b : A >)) . (if (if b then "boy" else false) then (fix unit) else 1)) then ({ e = (case true of < e = b > => a | < e = e > => c) , e = (succ b) }) else (case ("boy" b) of < c = a > => (a as (Rec A . String)) | < b = b > => (pred false)))
(fold [ (({ b : (< e : Nat , d : C >) , d : (Rec D . Float) }) -> ({ b : (Rec B . Float) , a : (A -> B) })) ] (let b = (true b) in (case (fold [ Float ] false) of < d = a > => unit | < d = a > => 2)))
((case (iszero ("boy" . b)) of < b = c > => (succ (unfold [ C ] true)) | < b = c > => (< a = (succ 0) > as (Rec B . B))) (iszero (a (let b = 0 in b))))
((fold [ (({ e : C , d : A }) -> (Rec B . String)) ] (let e = false in ({ c = 1 , a = 2 }))) as (< c : ({ d : Bool , a : String }) , b : (Rec E . Unit) >))
((iszero (iszero c)) as (< c : (Rec A . B) , c : ((< d : Nat , e : A >) -> (Rec C . C)) >))
(let c = ((succ 1) (succ true)) in ((pred (< a = 0 > as Bool)) (< b = 0 > as Float)))
(pred (succ (unfold [ (Rec C . (< c : C , c : String >)) ] (case (fold [ Float ] 2) of < b = e > => (fold [ B ] unit) | < b = b > => a))))
(((c a) . e) . c)
((let a = ({ d = (true true) , e = (\ b : C . unit) }) in (pred (unit as Float))) (fold [ (Rec C . Nat) ] (fold [ ({ c : C , c : Float }) ] (iszero 1))))
(fold [ (Rec D . (({ c : Bool , b : String }) -> (< e : C , a : Nat >))) ] (pred (< a = 0 > as Float)))
(iszero (pred (unfold [ A ] 1)))
((\ d : ({ e : ({ d : Unit , b : String }) , d : ({ b : A , a : Bool }) }) . (fix (if 1 then "boy" else false))) as ({ b : (B -> Bool) , d : (< a : (< b : C , d : String >) , a : ({ d : Unit , e : Unit }) >) }))
(case ((< c = b > as B) as ({ b : Bool , a : (< d : String , d : Float >) })) of < b = b > => (case (let c = unit in (< a = a > as Float)) of < e = d > => (case true of < c = d > => b | < d = a > => a) | < d = a > => (succ 1)) | < e = a > => (if (iszero c) then (case a of < c = d > => 1 | < a = c > => b) else ({ b = (a . c) , e = (pred true) })))
((fix (let c = false in (succ false))) as (Rec E . (< e : (Rec A . Bool) , a : Bool >)))
(pred (iszero ((succ b) ((iszero c) . b))))
((\ d : (({ d : String , b : Unit }) -> (Rec C . C)) . ((case true of < b = b > => "apple" | < a = a > => 0) . a)) (unfold [ (< e : B , b : A >) ] (< b = a > as A)))
((if (if 1 then 0 else true) then (iszero "boy") else ((unfold [ Nat ] 0) as ({ d : B , c : C }))) . c)
((iszero (\ e : (String -> Unit) . (pred a))) as (Rec D . (< b : (Rec B . C) , b : (String -> C) >)))
(fix ((("boy" . d) as (Rec A . A)) as (< e : (Rec E . String) , e : (Rec A . ({ b : Unit , b : Nat })) >)))
(let b = ((let d = unit in 1) . d) in ((let d = 1 in (c . b)) . c))
(fix ((\ b : (< d : Unit , b : A >) . (iszero "boy")) (({ b = 2 , c = a }) ("boy" as Unit))))
(\ a : (< c : ((Rec C . C) -> ({ a : Unit , d : String })) , d : (Rec C . Float) >) . (fold [ (Rec B . (< a : C , d : String >)) ] (unfold [ ({ a : ({ b : String , b : C }) , a : Unit }) ] (let e = 0 in 2))))
(fold [ ((Rec C . (Float -> C)) -> ({ d : (< b : String , c : Unit >) , d : ({ d : B , e : Bool }) })) ] ((fix "apple") as (Unit -> C)))
(fix (case (iszero 1) of < c = a > => (\ a : B . c) | < a = a > => (let a = (pred "apple") in true)))
(succ (case ({ d = ("boy" as Nat) , b = (case true of < a = a > => "apple" | < e = c > => "apple") }) of < d = d > => (succ (fix b)) | < b = e > => (({ b = true , b = 1 }) (b unit))))
(succ (fold [ (< d : Float , e : C >) ] (let d = false in "apple")))
(fix (\ a : (Rec E . Nat) . ({ b = false , c = (< b = 1 > as Nat) })))
(fold [ (Rec A . ({ e : Unit , c : Nat })) ] (let a = (\ c : C . unit) in (unit 2)))
(case (fix (case true of < c = c > => 1 | < a = c > => (iszero a))) of < c = c > => (if (pred true) then (fold [ (Rec B . B) ] (0 as Float)) else (iszero a)) | < e = a > => ((case 1 of < b = c > => (fix a) | < a = e > => (\ d : A . c)) as ({ b : Nat , b : A })))
(fold [ ({ a : ((Rec A . Float) -> (< e : String , e : Float >)) , a : (({ c : A , a : C }) -> (Rec B . B)) }) ] (if (fold [ Unit ] unit) then (b as Float) else (fold [ Bool ] false)))
(((< e = 2 > as Unit) as (< b : (< c : Bool , d : Float >) , a : (Rec B . Unit) >)) ((if a then "apple" else "apple") as (Rec E . String)))
(case (unfold [ ({ e : (Rec C . Bool) , a : A }) ] (fix (unfold [ String ] 1))) of < b = e > => (if ((unfold [ Unit ] (\ a : String . false)) as (< c : ({ a : Bool , a : C }) , a : (Rec D . Bool) >)) then (succ ({ e = unit , e = (fix 2) })) else (unfold [ Float ] a)) | < a = b > => (< a = (fold [ ({ a : (< e : B , b : Float >) , b : Unit }) ] (let d = 1 in unit)) > as ((C -> String) -> (< b : Bool , e : Nat >))))
((succ (succ 2)) as (< d : (({ e : Float , b : A }) -> String) , c : ({ d : A , b : String }) >))
(succ ({ c = (\ c : A . ({ a = unit , c = true })) , b = (fold [ (< c : Nat , e : Float >) ] (iszero 2)) }))
(succ ({ e = (iszero 2) , d = (< d = (pred 2) > as (Unit -> A)) }))
(case (\ b : ({ b : (< c : Unit , d : Unit >) , b : ({ a : A , e : Nat }) }) . (\ b : (Rec B . Unit) . (pred b))) of < b = d > => (if (unfold [ C ] b) then (fix b) else (\ c : Bool . 2)) | < b = d > => ({ e = ((true as Unit) "apple") , b = (< d = c > as Float) }))
(< c = ((fix (fold [ B ] unit)) as (Rec E . Nat)) > as ((Rec C . B) -> (Unit -> String)))
((fold [ (< e : ({ b : Nat , e : B }) , a : B >) ] (fold [ Bool ] false)) . a)
(fix ({ e = ({ c = 0 , a = unit }) , d = (case ("apple" as Bool) of < b = d > => (unfold [ B ] b) | < c = d > => (fix 1)) }))
(let b = (if (unfold [ (Rec B . Float) ] ({ c = b , c = false })) then (\ b : (< d : A , d : String >) . (fold [ String ] false)) else (iszero (2 . c))) in (\ b : (({ e : B , e : Float }) -> (Rec A . Float)) . ({ b = (c . d) , c = (fix 1) })))
(fold [ ({ a : ((< d : A , a : Nat >) -> (< c : String , e : ({ c : Float , b : Unit }) >)) , b : (Rec B . (< b : C , d : C >)) }) ] (fix (if unit then unit else (let d = 0 in "boy"))))
({ b = (\ d : (({ d : A , e : Float }) -> Unit) . (fold [ (Rec C . String) ] (fold [ (< e : C , a : B >) ] c))) , e = (((pred (\ c : Bool . 0)) as ({ d : ({ a : Bool , c : Nat }) , c : (Rec B . B) })) . a) })
(pred ((pred (case b of < c = e > => "apple" | < d = b > => a)) . e))
(if (if (case (let b = true in "apple") of < a = b > => (fix 2) | < c = d > => (< a = "apple" > as Float)) then (true as A) else (let e = (unit true) in (2 . d))) then (pred (c . b)) else (\ d : ((Rec A . (Rec D . String)) -> ({ e : Float , c : Unit })) . (let c = (unit as (Unit -> String)) in (if (\ e : B . unit) then "boy" else false))))
({ b = (fold [ (A -> Bool) ] (pred unit)) , b = ((let b = (pred "apple") in (fold [ (String -> String) ] false)) as (< a : Unit , d : C >)) })
(unfold [ (Rec A . ({ b : A , a : B })) ] (if (pred (\ c : Unit . "boy")) then (fix (a . c)) else (fold [ (< e : Unit , a : B >) ] (fix 1))))
(iszero (< b = (unfold [ String ] unit) > as ({ a : C , a : B })))
(if (\ e : ((Rec D . A) -> (< e : B , e : A >)) . (< e = c > as (< a : Unit , c : B >))) then ((\ a : (< c : String , d : Nat >) . 0) (\ b : A . 2)) else ({ e = (pred 0) , a = (iszero 0) }))
(let b = (pred (if (unfold [ B ] "boy") then (< e = true > as Float) else true)) in (if (fix unit) then (fix (< b = true > as A)) else (case (unit as A) of < b = b > => (< d = c > as Bool) | < b = b > => (1 false))))
(succ (succ (fold [ ({ e : A , c : Nat }) ] (c as Bool))))
({ a = (((fix 0) as (B -> B)) . d) , b = (if (if (if true then true else (succ 0)) then (< a = (fold [ Unit ] true) > as B) else (succ a)) then (fix (succ 1)) else ((iszero b) as B)) })
(\ c : (Rec B . (Rec B . (< a : Bool , e : Bool >))) . ((\ e : (Rec B . Float) . 0) as (Rec B . (< b : String , b : String >))))
(if (({ c = (true as (Rec D . B)) , e = (let a = 0 in b) }) . a) then (case (let a = "apple" in 2) of < a = c > => (unfold [ B ] (b "apple")) | < d = b > => (if (pred 0) then (fold [ Nat ] false) else (unit as Nat))) else (fold [ (Rec A . ({ a : String , e : (C -> Nat) })) ] (if (let e = 0 in 0) then (let a = (c . b) in (\ b : String . 1)) else (succ "apple"))))
(succ ((unfold [ ({ c : (< a : Nat , b : Nat >) , e : Unit }) ] (false as Nat)) as (Rec A . (< e : Nat , a : Nat >))))
(succ (fold [ (Nat -> Unit) ] (unfold [ Unit ] 2)))
({ c = ((\ c : Float . "boy") as (B -> Bool)) , b = (case (iszero (let c = 2 in (case c of < b = a > => true | < b = a > => "apple"))) of < e = c > => (2 . e) | < d = d > => (unfold [ (C -> Nat) ] (fold [ C ] "boy"))) })
(< a = (case (\ c : (Float -> Float) . 1) of < a = b > => (if (fix a) then (pred "boy") else (case "apple" of < b = e > => 1 | < e = a > => unit)) | < a = d > => (fold [ B ] c)) > as ((String -> ({ c : B , e : B })) -> (< c : Float , c : (Rec A . Bool) >)))
({ d = (iszero (let a = (fix false) in b)) , d = (if (a . b) then (if (if c then c else false) then (case 2 of < c = a > => 0 | < c = c > => false) else (if true then true else b)) else (let b = b in unit)) })
((pred (unit false)) . c)
((iszero (0 (0 as Unit))) as (Rec D . ({ b : Unit , a : String })))
((fold [ (< b : String , a : A >) ] (false . d)) as (< c : ({ d : A , a : Float }) , a : ({ b : ((< e : Unit , e : Unit >) -> ({ a : B , e : C })) , b : (String -> B) }) >))
(fix ((< b = (iszero "apple") > as (Rec A . (< c : Unit , b : B >))) . a))
(\ a : (< c : (Rec D . (C -> Nat)) , a : (Rec C . (Rec C . Bool)) >) . (let d = (unfold [ Unit ] (fold [ Bool ] "boy")) in (fold [ (< b : Bool , b : (String -> Bool) >) ] (let a = (iszero true) in true))))
(iszero (pred (let d = 2 in unit)))
(succ (if (< b = c > as C) then (\ b : String . a) else (pred a)))
(fix (({ c = unit , c = "apple" }) . e))
(succ (pred (if (unfold [ Bool ] "boy") then (iszero "boy") else (succ unit))))
((< d = (< b = (fix true) > as (< e : Bool , d : Nat >)) > as (Nat -> C)) as ({ a : (< e : Bool , a : A >) , e : (Rec D . C) }))
(iszero ({ c = (iszero 1) , b = (unfold [ ({ d : Nat , d : Unit }) ] (c b)) }))
(succ ((unit . b) (< d = (fold [ Nat ] true) > as A)))
(< e = (succ (a false)) > as (Rec E . (< b : A , c : Float >)))
(fold [ (< d : (Float -> (B -> C)) , b : (Rec C . (< c : (Nat -> String) , c : Unit >)) >) ] (\ d : ({ e : (< e : (Rec A . B) , d : Bool >) , d : (< c : A , d : String >) }) . (iszero ({ e = 0 , e = c }))))
(if ((let c = ({ c = true , b = "apple" }) in (< c = 0 > as String)) (if (\ b : Bool . unit) then 2 else (fold [ String ] 2))) then (unfold [ (< b : ({ d : Float , d : C }) , e : Bool >) ] (< a = (case 1 of < c = e > => c | < e = e > => false) > as (Nat -> Nat))) else (fold [ (C -> Bool) ] ({ a = "apple" , e = false })))
(if (pred (< b = (succ c) > as (Rec B . Nat))) then (fix (succ b)) else (fold [ (Bool -> Float) ] (c 0)))
({ c = (((\ e : Unit . 0) b) as (< c : ({ d : Bool , d : A }) , c : ({ b : String , e : Float }) >)) , c = (let c = (a as String) in (iszero b)) })
(if (fix (\ b : ({ c : Nat , c : Bool }) . (fix 1))) then ({ a = (iszero (pred 1)) , d = (let b = (fix (if 2 then 1 else false)) in (succ false)) }) else (fix (fold [ ({ b : String , a : Nat }) ] (let a = "boy" in (0 as Float)))))
((let b = (succ unit) in (fold [ ({ a : C , d : Float }) ] a)) . a)
(fold [ ((B -> (Rec A . Unit)) -> ((Rec C . String) -> ({ d : String , a : A }))) ] (pred (let e = (\ b : B . 2) in (case 2 of < a = e > => unit | < b = e > => unit))))
(((pred a) . e) as (< b : (Unit -> B) , b : ((< e : Nat , d : C >) -> String) >))
((unfold [ (< a : B , e : (B -> A) >) ] ((fix 1) (\ a : Bool . false))) as (< b : ((Rec E . A) -> (String -> String)) , a : ({ b : (Rec A . Nat) , c : ({ e : Unit , c : B }) }) >))
(succ (fix (\ d : C . b)))
(pred (iszero (fold [ B ] c)))
(let c = (case (< e = "boy" > as (Rec B . Nat)) of < e = b > => (let e = (succ false) in (iszero "apple")) | < e = a > => (succ true)) in ((\ e : ({ a : String , d : Unit }) . (0 . a)) (fold [ ({ a : Unit , b : Float }) ] b)))
(if ((pred (false . b)) . c) then (iszero (fix false)) else (unfold [ (< c : Float , c : Float >) ] (case 0 of < e = d > => b | < d = e > => 1)))
(((unfold [ Float ] b) as (Rec C . (Rec A . Bool))) ((let d = false in a) . e))
(\ b : (Rec D . (< a : (Float -> A) , b : (Rec B . Nat) >)) . (let b = (let b = (case "apple" of < d = e > => 1 | < d = b > => true) in (if "boy" then b else unit)) in (if 2 then 0 else "boy")))
(\ d : ({ d : (< d : C , c : Bool >) , d : ({ e : A , e : Unit }) }) . ({ a = (case (pred b) of < b = b > => true | < d = d > => (unfold [ String ] true)) , c = (pred "apple") }))
(case ((< d = false > as A) . d) of < d = e > => (unfold [ (Bool -> ({ b : C , e : Bool })) ] ("apple" . e)) | < c = a > => (if ("apple" . e) then (case "boy" of < a = e > => ("apple" . a) | < a = c > => (fix "apple")) else (if "boy" then 1 else (c as String))))
(\ b : (Rec A . ({ c : (Nat -> (< c : Bool , a : C >)) , c : ({ b : Unit , d : String }) })) . (fold [ (Rec B . Bool) ] ({ d = "boy" , d = a })))
(case (iszero (iszero (fold [ Unit ] unit))) of < b = d > => (case (\ e : B . unit) of < b = e > => (\ e : A . (unfold [ String ] "boy")) | < c = c > => ({ e = (if 1 then 0 else 2) , d = 0 })) | < c = d > => ((fix (case (a 2) of < b = a > => c | < a = d > => (iszero true))) (succ (fold [ B ] true))))
(iszero (< c = (let a = (if false then c else 2) in 2) > as (Rec E . C)))
(iszero (succ (succ unit)))
(fix ((let a = (\ b : Float . "boy") in (pred unit)) . d))
({ b = ((fix unit) . d) , e = (fix (if (< a = a > as Nat) then (\ c : Bool . (< c = true > as String)) else ("boy" 1))) })
(fix (succ (case (fix unit) of < e = b > => 2 | < c = a > => (unfold [ Unit ] c))))
(((< d = (if 1 then "apple" else false) > as (A -> Bool)) . c) . b)
(fold [ (Rec B . ({ b : ({ c : B , b : Unit }) , a : ({ c : B , e : Bool }) })) ] (if (< d = (iszero b) > as ({ d : C , d : Nat })) then (case (fold [ String ] unit) of < d = a > => ({ b = (fix false) , c = (let c = b in "boy") }) | < b = e > => ({ c = 1 , b = (\ c : Float . false) })) else (case false of < b = a > => b | < c = d > => (fold [ A ] false))))
(fold [ ((< b : C , b : C >) -> (Bool -> (Rec D . Bool))) ] ({ d = ((a as B) . e) , d = (fold [ (String -> B) ] (pred 0)) }))
(succ ({ c = (< e = ({ e = a , d = b }) > as A) , d = (unfold [ Nat ] "apple") }))
(case (let c = (if false then true else (unfold [ String ] "apple")) in ({ e = unit , d = (fix "boy") })) of < b = c > => (fold [ (Float -> (Unit -> String)) ] (case "boy" of < e = c > => (iszero b) | < b = c > => (unfold [ String ] unit))) | < b = b > => (unfold [ (< d : String , a : String >) ] (fix (case (let c = false in unit) of < b = d > => (unit unit) | < d = e > => true))))
(case (if (fold [ Unit ] true) then (succ "apple") else (iszero true)) of < c = c > => (let d = (case false of < a = c > => true | < a = e > => "boy") in (unfold [ B ] (fix a))) | < e = e > => (unfold [ ((< d : Float , b : Nat >) -> Unit) ] (fix 1)))
(< c = (iszero (\ c : ({ a : (< e : Nat , e : String >) , b : B }) . (unfold [ String ] 1))) > as ((Unit -> String) -> (Rec B . (Unit -> A))))
(< b = (< a = (if (fold [ String ] false) then (case false of < a = c > => 2 | < e = d > => false) else 2) > as (< e : String , c : Nat >)) > as (({ c : Bool , d : Nat }) -> (< b : C , a : Nat >)))
((pred (c as ({ c : Nat , b : B }))) . d)
(< b = (fold [ ({ a : (Unit -> Bool) , b : (< d : A , a : String >) }) ] (\ c : (Unit -> Unit) . true)) > as ({ d : (< e : (< c : A , c : String >) , e : (Rec E . (Rec B . Bool)) >) , a : ({ d : (Bool -> String) , d : (A -> Nat) }) }))
({ b = (case (< d = 1 > as B) of < b = b > => (pred 1) | < d = e > => (fold [ A ] unit)) , c = (unfold [ (< d : Bool , e : B >) ] (succ (let e = a in 1))) })
(fold [ (< c : (Rec E . (Rec E . Bool)) , a : (Rec E . Unit) >) ] (iszero (< d = false > as C)))
(let b = (let e = (< d = 2 > as (A -> Bool)) in (let e = "apple" in "apple")) in (unfold [ (< b : ({ e : (B -> B) , e : (< b : Bool , e : B >) }) , d : (Rec D . Unit) >) ] ((0 0) as ((B -> A) -> (< c : Float , d : Nat >)))))
(\ d : ((A -> B) -> (< a : C , b : Bool >)) . (let d = (< d = "apple" > as (< c : Float , d : Nat >)) in (pred b)))
(fix (pred (fold [ Bool ] false)))
(unfold [ ({ e : (Rec D . Bool) , d : (({ c : Bool , d : Nat }) -> (Bool -> Unit)) }) ] (let a = (case a of < b = c > => (let a = "apple" in b) | < d = e > => "boy") in ((iszero 1) as (A -> B))))
(fix (< c = (\ e : Nat . (succ true)) > as ({ b : (Rec B . ({ a : B , d : Nat })) , d : (Float -> C) })))
(unfold [ (< d : (< b : (Rec B . A) , e : Float >) , e : (Nat -> C) >) ] (if ({ b = (b unit) , c = (pred false) }) then (unfold [ (Rec E . C) ] 2) else ({ e = (fold [ A ] "boy") , c = (unfold [ Unit ] a) })))
(if (pred (0 (if b then 2 else false))) then (unfold [ (< d : B , a : (< b : Nat , b : C >) >) ] (pred b)) else (< e = (fix true) > as (< d : Bool , a : C >)))
((\ d : ((Rec B . B) -> (< b : String , b : Unit >)) . (\ c : String . true)) (iszero (pred (c as Bool))))
(case (case ((succ (succ b)) (succ 1)) of < d = a > => (if (case b of < e = b > => 1 | < b = c > => unit) then (if c then true else 1) else 2) | < e = b > => (succ (fix 0))) of < c = e > => ({ c = ((case 0 of < c = c > => a | < e = d > => a) as (Rec D . Nat)) , d = (if "apple" then (pred 1) else (pred 0)) }) | < e = c > => (fold [ (({ d : Unit , e : Nat }) -> Nat) ] (succ true)))
(if (case (iszero (unfold [ Float ] b)) of < e = d > => (let a = (succ true) in (case a of < d = d > => a | < d = d > => a)) | < b = e > => ({ c = "boy" , a = c })) then (iszero (pred (b "apple"))) else (iszero ((0 a) as C)))
(if (succ (unfold [ (Rec B . Float) ] (succ false))) then (unfold [ ({ a : (Rec A . String) , b : C }) ] (unfold [ (C -> C) ] (unfold [ C ] (iszero b)))) else (succ (if (unit . a) then "boy" else (a as Float))))
(((fix b) as (Rec D . ({ e : Float , c : B }))) as (Rec A . ({ e : (Nat -> Bool) , d : ({ b : Float , c : Unit }) })))
(let e = (succ (unfold [ Unit ] (iszero c))) in ((case (0 2) of < a = e > => (unfold [ String ] 0) | < d = a > => (succ 2)) (fold [ (Nat -> B) ] (2 2))))
(let c = (iszero (succ (if "boy" then false else b))) in (\ d : (< c : String , a : ({ c : Float , d : Float }) >) . ((case unit of < c = d > => "boy" | < a = c > => 0) as (< c : A , e : Nat >))))
({ d = (unfold [ (Rec C . Bool) ] (fold [ (< c : ({ e : C , d : Bool }) , a : (< a : C , e : Float >) >) ] (case 0 of < a = b > => 2 | < a = b > => true))) , b = ((succ (2 b)) (fix (pred 0))) })
(fix ((fold [ String ] true) (unfold [ (< b : B , b : Nat >) ] (if "apple" then (< e = c > as String) else unit))))
(\ e : (< b : ({ c : A , d : B }) , a : (Bool -> (Rec B . Bool)) >) . (let a = (case 2 of < a = c > => c | < a = b > => b) in ((1 as Nat) as B)))
(if ((1 as ({ e : C , d : B })) . d) then (let e = (fold [ (Rec E . A) ] (succ (let e = unit in 0))) in (case (fold [ (Nat -> B) ] 2) of < d = a > => (let b = 1 in 1) | < c = e > => (let b = 2 in false))) else (< c = (< e = false > as Bool) > as (C -> Float)))
({ b = ((< c = "boy" > as Float) . b) , e = ((iszero "apple") . a) })
(pred (fix (if (fold [ Bool ] a) then false else 1)))
((unfold [ ({ b : String , d : (Rec E . Bool) }) ] (pred false)) (case (if (\ e : Unit . c) then (unfold [ C ] "boy") else ("boy" as C)) of < e = a > => (< d = true > as C) | < a = a > => (if 0 then true else false)))
(iszero (\ b : ({ a : (< a : Nat , c : (< a : Unit , c : Unit >) >) , b : (< a : (< d : B , b : Nat >) , c : (< e : Unit , d : B >) >) }) . ((unfold [ B ] 2) . a)))
(fix (\ b : (Rec D . Nat) . (case (< c = 0 > as Bool) of < b = b > => (fold [ Float ] "apple") | < b = e > => (pred "apple"))))
(unfold [ (Rec B . (Bool -> Float)) ] (succ (if true then a else (let c = unit in 0))))
(unfold [ (< e : (< b : C , a : ({ b : Unit , c : Bool }) >) , a : ({ e : Nat , a : Nat }) >) ] (< e = ((\ c : (Rec E . Unit) . true) (unfold [ A ] 1)) > as ({ d : (Bool -> Unit) , a : ({ a : Nat , b : String }) })))
((iszero (< d = (< c = a > as A) > as (Nat -> B))) . a)
(iszero (fold [ ({ b : (Rec A . String) , c : C }) ] (("boy" . b) ({ c = (fix true) , b = b }))))
(fix (case (if true then (if b then "boy" else 0) else ({ b = 2 , d = c })) of < b = d > => (\ e : Unit . b) | < b = b > => (iszero false)))
(let e = (fix (if (0 unit) then ("boy" b) else a)) in (let d = ("boy" . c) in (< a = (if 0 then "apple" else 2) > as C)))
(if (fix (pred 2)) then ((fold [ String ] unit) . d) else (< c = (fold [ Unit ] 0) > as (Rec E . Bool)))
(case (iszero (pred 1)) of < c = b > => (\ a : (< e : Unit , d : A >) . ({ c = c , b = true })) | < e = d > => ((< a = "apple" > as Bool) as (< a : Float , d : Nat >)))
(unfold [ (Rec D . ({ b : Bool , e : ({ a : C , c : Nat }) })) ] (iszero (false as (< e : C , d : String >))))
(\ d : ({ c : ({ b : Float , a : C }) , d : (< d : (< c : Nat , a : String >) , b : A >) }) . (succ (< d = a > as ({ d : Nat , a : C }))))
(if (fold [ (C -> (< e : Nat , c : B >)) ] (c 2)) then (\ c : (< b : (< c : String , b : Unit >) , c : (< d : (Rec A . B) , e : Bool >) >) . (1 a)) else (\ c : ((< b : C , a : Nat >) -> Float) . (case true of < c = c > => (fold [ B ] b) | < d = d > => (2 . e))))
(fix (iszero (< a = c > as C)))
(fix ((fold [ (Rec A . Nat) ] "apple") . c))
(let d = (iszero (c as A)) in (unfold [ ({ c : Float , a : C }) ] (succ 1)))
(case (let e = (fold [ (Rec E . A) ] 1) in ({ d = (fold [ B ] a) , c = (unit c) })) of < a = a > => (case (({ c = a , b = a }) as ({ a : (Rec B . String) , b : (< e : String , e : Unit >) })) of < c = a > => (fold [ ({ c : B , a : String }) ] (let a = (case a of < b = b > => b | < b = b > => a) in a)) | < d = c > => (iszero ((unfold [ B ] 2) . c))) | < b = e > => (pred (iszero 1)))
((succ (if (let d = 1 in "apple") then true else (case 2 of < a = c > => unit | < a = b > => 0))) as ((Rec E . (< b : (Unit -> Nat) , d : Unit >)) -> (Rec A . (Rec C . (Nat -> Nat)))))
(\ d : (Rec E . ({ b : ((Rec B . Float) -> Float) , c : (< d : B , b : Float >) })) . (("boy" . c) (iszero (iszero a))))
((pred ((iszero 0) (fold [ Float ] unit))) (pred (let c = ({ b = false , a = 0 }) in 1)))
(if ((fold [ Float ] 2) (2 as B)) then (unfold [ (Float -> Nat) ] ("boy" . b)) else ((iszero true) . d))
(\ d : (Rec C . (Rec C . Nat)) . (pred (fold [ (< d : A , b : Nat >) ] (let a = (unfold [ A ] a) in unit))))
(< c = ({ d = (succ (fix unit)) , b = (fold [ ({ d : B , e : Nat }) ] (\ d : A . 2)) }) > as (({ e : (Nat -> Nat) , e : (Rec D . String) }) -> (Rec A . (< a : Unit , c : Bool >))))
((\ d : (Rec A . B) . (unfold [ B ] true)) (fix (if c then ("boy" . c) else b)))
(pred (let d = (fix ((if unit then unit else 2) (< e = true > as Unit))) in (let e = ("apple" . a) in a)))
(unfold [ ({ d : ({ e : C , e : A }) , c : ({ a : C , b : C }) }) ] (unfold [ (Rec C . Float) ] ((iszero false) as (< a : Bool , b : (String -> String) >))))
(if (\ c : (Rec A . (< a : ({ e : Bool , e : String }) , e : ({ c : B , d : Nat }) >)) . (fix (fold [ C ] 1))) then ((let a = unit in ("apple" . e)) ({ e = (1 as Bool) , a = (< b = a > as ({ a : A , b : Float })) })) else (if (succ c) then (pred false) else (let b = 2 in (2 . b))))
((fix (unfold [ String ] (1 a))) as ({ a : (< a : ({ e : Unit , d : Float }) , b : (Float -> ({ e : Bool , c : A })) >) , b : (String -> Float) }))
(\ b : ((A -> C) -> (Rec E . String)) . ((case 2 of < b = a > => 1 | < a = a > => unit) . d))
(case (let a = (pred false) in (\ a : A . unit)) of < b = d > => (let a = (false 1) in (1 as Float)) | < d = d > => (unfold [ ({ e : (Float -> Float) , a : A }) ] (iszero (iszero (\ e : Bool . 0)))))
(iszero (unfold [ (Rec B . (Rec A . C)) ] (fix ({ b = b , b = a }))))
(if (case (iszero b) of < a = a > => (a . a) | < b = b > => (let c = c in true)) then (fold [ (< d : (C -> Unit) , d : (< c : Float , e : Bool >) >) ] ((\ e : ({ a : A , c : Unit }) . (succ "apple")) . b)) else (case (iszero 2) of < a = a > => (unfold [ Nat ] "boy") | < e = a > => (case (fold [ Bool ] 0) of < c = d > => (if a then 1 else 1) | < a = a > => (\ c : String . unit))))
({ e = (fix (pred b)) , d = (((fix ({ e = true , e = "boy" })) as (A -> Float)) (succ (let b = true in true))) })
({ c = ((fold [ ({ d : C , e : Bool }) ] (\ d : B . b)) (unfold [ Float ] 0)) , e = (case (iszero 1) of < a = e > => (let c = b in 2) | < d = d > => (let b = b in c)) })
(< b = (if (fix ((let e = 0 in 0) true)) then (unfold [ C ] (0 unit)) else (\ c : A . true)) > as ({ c : ({ e : ({ a : Float , b : Bool }) , a : Nat }) , d : (Float -> ({ b : String , b : A })) }))
(let d = (fix (iszero (\ e : C . c))) in (succ (fix 1)))
(fix ((fold [ C ] (succ unit)) as ({ d : Bool , a : Float })))
(succ (< d = (if (iszero "apple") then (fix unit) else (succ (\ c : String . b))) > as (Rec C . ({ c : (Rec E . B) , d : A }))))
({ c = ((\ a : B . (if 0 then "apple" else c)) as (({ b : Float , b : A }) -> (Rec A . C))) , b = (< c = (pred b) > as (< b : (A -> Float) , a : (< c : String , d : Bool >) >)) })
(iszero (iszero ((iszero unit) as (< c : Unit , e : Float >))))
(fix (fix (false . b)))
(let c = (iszero (iszero c)) in (((iszero a) (let e = a in "apple")) . e))
(< b = ({ b = ((iszero "boy") as Float) , c = (if true then false else (fold [ A ] unit)) }) > as ({ a : ({ a : Unit , a : ({ b : Float , b : Nat }) }) , c : (Rec C . Float) }))
(unfold [ (< c : (Bool -> Bool) , e : (Nat -> Bool) >) ] (pred (< e = false > as B)))
(pred (unfold [ (< d : ({ e : Unit , a : C }) , c : (Rec E . Nat) >) ] (pred 2)))
((pred ({ a = (pred false) , e = (fold [ ({ b : B , d : Bool }) ] unit) })) . c)
((unfold [ (Rec A . ({ e : C , c : C })) ] (fix 1)) as (< e : (Rec E . Nat) , c : (< c : ({ e : String , d : Bool }) , a : ({ b : ({ a : Nat , e : B }) , b : (B -> Nat) }) >) >))
(fold [ ((Rec A . (< e : Bool , a : Unit >)) -> (Rec A . (< e : C , d : C >))) ] ({ b = (false as A) , e = (0 . b) }))
(case (let d = (iszero a) in (fix false)) of < a = b > => (if (\ e : C . false) then (fix (iszero 1)) else (false false)) | < c = a > => (let b = (\ d : ({ d : Float , a : String }) . (if 0 then unit else unit)) in ("apple" c)))
(fix (\ e : (C -> B) . (unfold [ B ] "boy")))
(iszero (({ b = b , c = "apple" }) (fold [ Bool ] "apple")))
(fold [ ((Rec B . (Rec B . String)) -> (< e : (Rec B . Unit) , e : (Unit -> B) >)) ] (\ d : (< d : Float , b : String >) . (if "boy" then true else b)))
((succ (iszero (case b of < d = d > => unit | < a = e > => c))) (\ b : ({ d : (Rec E . Bool) , d : (C -> C) }) . (if true then (if "boy" then b else b) else 1)))
(let d = (case (< d = (0 c) > as (< e : Unit , b : Float >)) of < b = d > => (pred ("boy" a)) | < b = b > => (case (if false then 0 else 0) of < a = e > => ({ a = "apple" , d = (case c of < d = d > => a | < d = e > => c) }) | < d = b > => (let a = b in (iszero "boy")))) in (fold [ ((< d : C , b : C >) -> (Rec E . A)) ] (let a = (b 2) in (\ e : B . true))))
(let a = (succ (\ c : Float . (iszero unit))) in (if (fold [ (Rec E . B) ] (fix 2)) then ({ b = (unfold [ (C -> Nat) ] (b false)) , e = (fold [ (< a : A , c : Nat >) ] (\ c : A . a)) }) else (succ ("apple" (succ 0)))))
((succ (succ (< a = c > as Nat))) (let d = (\ a : (A -> A) . (< a = 0 > as Float)) in ((if "boy" then "boy" else "apple") ({ c = false , d = a }))))
(iszero (succ ((unfold [ C ] c) (pred false))))
((\ b : ({ c : (B -> Unit) , b : Unit }) . (pred b)) as ({ a : (< b : Float , b : String >) , e : ({ b : (< d : C , c : Nat >) , c : (< e : Float , c : Bool >) }) }))
(case (fold [ ((< a : (Rec B . B) , e : Nat >) -> (Rec D . B)) ] ({ c = b , e = a })) of < e = c > => (< c = (iszero (succ a)) > as ((B -> Float) -> ({ b : Unit , e : Float }))) | < a = e > => (pred (if false then 0 else "boy")))
(succ (fold [ (Rec B . (Rec C . Float)) ] (iszero 2)))
(((< c = a > as C) as (< e : (A -> Nat) , a : String >)) as ({ b : (Unit -> Float) , e : (< c : String , d : Bool >) }))
((fold [ (Rec A . A) ] (unfold [ ({ c : Bool , b : Unit }) ] c)) (fix ("boy" (unfold [ B ] b))))
(((< c = ({ d = a , a = true }) > as A) (pred (pred c))) (fix (pred true)))
(({ d = (pred ({ e = false , e = 0 })) , c = ((0 (< b = c > as Unit)) . b) }) ((fix "apple") as (Rec D . (C -> Unit))))
(\ d : ((< c : (< a : Unit , b : Unit >) , d : Bool >) -> (({ a : (< a : Bool , b : String >) , a : A }) -> (Nat -> Nat))) . (< c = (case true of < c = c > => "apple" | < a = e > => "apple") > as (< a : C , b : Bool >)))
(case ((pred unit) as ({ a : (Bool -> (Rec E . Nat)) , e : (Rec C . String) })) of < b = a > => (if (fold [ A ] c) then (case ({ d = 2 , d = 1 }) of < c = a > => (fold [ Unit ] 2) | < c = b > => (unfold [ B ] "apple")) else ({ d = "apple" , a = (iszero true) })) | < c = e > => (let c = (fix 0) in (fold [ Nat ] 2)))
((unfold [ ((Rec B . C) -> Bool) ] (let e = a in (false as Unit))) (\ a : (< b : Float , e : C >) . (iszero (pred "apple"))))
(succ (iszero (let e = (let c = "apple" in 0) in c)))
(case (pred (case (let c = false in true) of < d = e > => (\ c : A . (2 . c)) | < b = a > => (2 true))) of < e = e > => (pred (("apple" as Unit) . d)) | < a = c > => (case (< c = (fix true) > as (Float -> String)) of < e = c > => (< b = "apple" > as Unit) | < e = e > => (\ d : (Rec B . String) . (pred 1))))
(succ (fold [ (B -> (< a : Nat , a : A >)) ] (pred a)))
(let c = (iszero (unfold [ Unit ] a)) in (((fold [ Nat ] b) . d) . a))
(iszero (if ((case 2 of < c = e > => a | < a = c > => 2) as String) then (0 as Bool) else (fold [ (Rec B . Float) ] (c . e))))
({ e = (if (\ a : (Rec B . Unit) . (let b = "apple" in 1)) then (< e = (pred 0) > as A) else (case "apple" of < a = c > => unit | < a = d > => true)) , d = (\ a : (Rec E . (Rec E . Bool)) . (iszero (("apple" as B) as (< e : String , a : Float >)))) })
(fold [ (< d : ({ e : B , d : Nat }) , c : ((Float -> Unit) -> (< b : Unit , e : B >)) >) ] (let c = (< b = "apple" > as C) in (unit as Unit)))
(succ (if (case unit of < c = e > => "boy" | < a = e > => "apple") then (unit as Float) else (succ (if b then c else 0))))
(let a = (\ a : (C -> Unit) . (case (if c then "boy" else 2) of < c = d > => (pred 0) | < d = a > => (unfold [ Nat ] c))) in (case (succ "boy") of < a = a > => (succ "apple") | < d = e > => (let d = (unfold [ B ] false) in (succ "boy"))))
({ b = (\ b : ({ e : (Bool -> Nat) , c : B }) . (\ c : (Rec A . Nat) . "boy")) , e = (let d = (if (succ (let a = c in "boy")) then (if "boy" then 0 else 1) else (< d = false > as Float)) in (iszero (succ unit))) })
(pred ({ d = (case (if 1 then (fix unit) else ({ e = 1 , d = true })) of < d = c > => (< b = a > as C) | < e = a > => (let b = 0 in "apple")) , c = ({ a = (fold [ C ] 1) , d = (0 . d) }) }))
(fold [ (< b : ({ a : A , c : Bool }) , a : (Rec A . B) >) ] (case (true (pred "boy")) of < c = c > => ((unit . d) as Unit) | < b = c > => (fix (case false of < e = c > => false | < c = a > => 1))))
(pred (case (let e = (0 "boy") in 2) of < b = b > => (pred ("boy" . c)) | < a = c > => (pred a)))
((succ (if (succ "apple") then (case a of < b = c > => 1 | < a = d > => true) else (pred c))) . a)
(let a = (((if 0 then true else b) (case 0 of < c = e > => "boy" | < b = a > => 1)) . c) in (unfold [ (Rec A . ({ a : B , c : A })) ] (iszero 0)))
(iszero (succ (({ c = (\ e : Unit . c) , a = (pred c) }) ((unfold [ C ] "apple") . a))))
(if ((fix (let e = 1 in 1)) as (Rec A . C)) then (case (fix (case (< d = 2 > as Bool) of < c = e > => b | < d = a > => "apple")) of < a = e > => (let a = (< e = b > as (Rec A . Bool)) in (unit . d)) | < e = d > => ("boy" (unfold [ Bool ] "apple"))) else (if ({ e = "boy" , a = c }) then (succ ("boy" . c)) else ((c . e) (fold [ C ] a))))
(let a = ({ e = (pred (b as A)) , a = (let d = (if false then 0 else a) in (iszero a)) }) in ({ b = ("boy" as (Rec B . C)) , b = (succ (if b then (fold [ Float ] a) else ({ a = "boy" , c = true }))) }))
((let d = (pred (case c of < b = a > => "apple" | < e = e > => c)) in (unfold [ A ] a)) as (Rec C . ({ b : Bool , a : (B -> String) })))
(succ (if (\ a : A . 2) then (\ b : (Nat -> B) . (fix false)) else ((fold [ Float ] unit) (case unit of < c = e > => a | < d = d > => 1))))
(fix (< c = (fix (fix false)) > as (< e : (C -> Float) , d : (Rec D . Nat) >)))
(((let a = ({ c = 2 , b = a }) in "apple") as (A -> Unit)) . e)
(fold [ ({ b : ({ e : B , a : Bool }) , e : ((Float -> B) -> Nat) }) ] (fold [ ((Nat -> A) -> (< c : Bool , a : Nat >)) ] (case true of < b = a > => "apple" | < c = d > => 1)))
(\ b : (Rec B . ({ c : Float , d : ({ d : String , c : Unit }) })) . (fold [ ({ b : (Float -> String) , c : (Rec A . B) }) ] ((unfold [ B ] 0) as ({ c : C , a : Unit }))))
((case (succ unit) of < a = c > => (\ e : (String -> String) . false) | < a = c > => ((< b = 1 > as Float) as (< d : (< a : Nat , a : Bool >) , a : ({ c : A , d : Float }) >))) as (Rec E . ({ b : (Rec A . A) , c : Nat })))
(unfold [ ({ d : ({ b : (Rec D . C) , a : (Unit -> String) }) , c : (< b : ({ c : Float , e : Bool }) , b : (C -> A) >) }) ] (if (< a = (iszero 2) > as (< b : ({ d : Unit , e : Unit }) , c : Float >)) then ((\ b : C . false) as Unit) else (let d = c in true)))
(iszero (iszero (\ b : (Rec A . Float) . 2)))
(< a = (let a = (if 1 then (fix c) else (unfold [ B ] unit)) in (iszero (let c = 2 in c))) > as (Rec C . (< b : (< b : Bool , a : C >) , d : (< c : Nat , a : Float >) >)))
(if (\ c : (Rec C . Unit) . (fix 1)) then (pred ((\ a : (Rec D . Unit) . a) (case 1 of < c = c > => 1 | < c = b > => (iszero c)))) else (let b = ((\ d : A . 2) . c) in (iszero false)))
(\ a : ({ b : (Rec A . ({ c : Float , d : String })) , c : ((Nat -> A) -> Bool) }) . (iszero (case (fold [ Unit ] c) of < b = e > => (\ d : Nat . "apple") | < e = a > => (succ c))))
(< c = (let c = (unfold [ (B -> String) ] (\ a : ({ c : Unit , d : B }) . (1 . a))) in (let b = false in false)) > as (< d : ({ e : (Rec C . Float) , a : (< e : String , e : Float >) }) , c : (Rec D . (Rec A . ({ e : B , b : Nat }))) >))
((let b = (let e = a in a) in (fold [ Nat ] c)) (if (iszero (if false then false else (let e = unit in a))) then ((fold [ ({ e : Float , c : B }) ] (let c = a in true)) (unfold [ Float ] c)) else (fold [ ({ b : A , e : C }) ] 2)))
((case (fold [ String ] false) of < a = b > => (let e = (let c = 1 in c) in (iszero 0)) | < b = b > => (unfold [ Float ] 0)) as ((A -> Unit) -> ({ d : C , c : Float })))
((pred (iszero (0 unit))) as ((Rec C . String) -> (< b : B , d : C >)))
(\ a : (Rec A . ({ d : (Rec D . (Unit -> Bool)) , b : (< e : Unit , c : (< a : Unit , b : String >) >) })) . (succ ((case "apple" of < a = d > => 2 | < b = d > => false) . d)))
(\ e : (({ d : ({ e : String , e : Float }) , c : C }) -> ({ b : Bool , a : Nat })) . (\ d : (Unit -> B) . (fold [ ({ d : B , d : Unit }) ] (\ b : Unit . unit))))
((case (pred "apple") of < c = a > => (< a = "boy" > as (Float -> A)) | < b = c > => (succ c)) as (< a : ((< b : B , e : String >) -> C) , b : ({ d : (Rec D . Nat) , b : Nat }) >))
({ a = (fold [ (Rec B . (({ c : Unit , b : B }) -> A)) ] (unfold [ Float ] a)) , c = (iszero (let a = 1 in false)) })
(case (((false (unfold [ Bool ] false)) ({ e = 2 , c = 0 })) as ({ d : (Rec E . Nat) , e : (Rec D . (< b : String , b : Float >)) })) of < b = a > => ({ a = (fix true) , d = (if "apple" then (\ d : Float . 2) else (b . a)) }) | < a = c > => (case (false as Float) of < e = d > => (iszero (\ d : A . 0)) | < d = c > => (fix "apple")))
(\ a : (< d : (< d : (Rec D . Bool) , d : Unit >) , d : ({ e : Unit , d : B }) >) . (fold [ (< b : (Unit -> C) , a : ({ b : Unit , d : A }) >) ] ({ b = (iszero (let b = false in false)) , a = (fold [ A ] (pred unit)) })))
(fold [ (< d : (< a : (Rec E . Bool) , b : Float >) , e : (Rec C . B) >) ] ((\ c : ({ b : Float , d : Nat }) . (2 as B)) (fix (unfold [ Unit ] 2))))
(succ ((\ c : Bool . 2) . e))
(\ e : (Rec E . (Rec C . (Rec C . C))) . (iszero (case "apple" of < d = e > => false | < b = d > => "boy")))
(if (fold [ ((Nat -> Unit) -> (Rec C . B)) ] (fold [ Nat ] (case 2 of < b = d > => 0 | < d = a > => 2))) then (succ ((succ 1) (succ "apple"))) else (case ({ b = false , a = true }) of < b = b > => (false . b) | < b = a > => (< a = 2 > as Bool)))
(fold [ ({ c : (< b : C , e : C >) , e : (< c : Bool , b : Bool >) }) ] (((iszero "apple") as ({ b : B , c : C })) as (< d : (< d : Float , a : Float >) , a : (Rec C . Nat) >)))
((let e = (succ 0) in (let b = "boy" in a)) . b)
((unfold [ ({ a : Nat , b : B }) ] (< b = (1 true) > as A)) as ((Rec D . Unit) -> (Rec C . String)))
(case ({ a = (iszero (iszero 0)) , d = (fold [ ({ a : (B -> Nat) , b : Bool }) ] ((pred false) as B)) }) of < d = d > => ((fix true) as ((Rec A . C) -> (String -> A))) | < a = a > => (fix (< d = (pred "boy") > as Float)))
(fold [ ({ e : ({ e : (Rec C . C) , e : (< c : Float , b : Bool >) }) , d : (< a : ({ e : Bool , b : Bool }) , c : (Rec D . ({ a : String , b : Bool })) >) }) ] (unfold [ (Rec E . B) ] (pred "apple")))
(unfold [ (Rec C . (Bool -> Nat)) ] ((if 0 then true else 1) as (Rec B . Float)))
((iszero (pred (pred 0))) . c)
(fix (\ a : (C -> Unit) . (if "apple" then c else "boy")))
(fold [ ({ a : (< c : B , a : (< c : Bool , e : Nat >) >) , d : (String -> B) }) ] (iszero (if ({ d = true , b = c }) then (case b of < b = b > => "apple" | < b = e > => false) else ((false . a) . c))))
((if (pred (fold [ ({ c : Bool , c : B }) ] true)) then (< c = (c (1 as A)) > as (Rec C . (< d : Unit , a : Bool >))) else (case (2 as (Rec E . Bool)) of < b = d > => (pred 0) | < a = a > => (\ d : A . 0))) as (Rec E . ({ b : String , d : C })))
(fix (\ a : ((String -> C) -> ({ b : B , a : ({ d : String , a : B }) })) . ((succ "boy") as (C -> String))))
((pred ((2 . d) . b)) (pred (fix 1)))
((((if false then 2 else 1) (succ true)) ((pred c) as Float)) (if (unfold [ A ] "boy") then (fix (fix 2)) else (b . e)))
({ c = (iszero (unfold [ (Bool -> A) ] (false false))) , d = (succ (pred (c as C))) })
(fix (let d = (\ b : String . a) in ("boy" as B)))
(case (pred (a . c)) of < b = a > => (succ (unfold [ Unit ] unit)) | < c = b > => (({ d = unit , c = a }) . d))
(pred (< e = (fold [ ({ d : Bool , c : Bool }) ] 1) > as ({ c : C , e : String })))
(case (fold [ (Float -> B) ] (< e = (case a of < d = d > => b | < a = d > => "apple") > as A)) of < d = e > => ((< e = (fix 1) > as (Rec E . String)) . b) | < c = d > => (fold [ (Rec C . Bool) ] (if true then 0 else 0)))
(succ (\ c : (< b : Nat , a : C >) . (pred (c . e))))
(fix (fix (let b = false in (unfold [ B ] unit))))
(iszero (succ (< b = (case "boy" of < d = c > => (fix 2) | < d = c > => a) > as (Rec B . (Rec D . A)))))
((fix (case 2 of < e = d > => (< c = a > as Float) | < b = e > => "apple")) as (< d : (Rec C . (C -> A)) , c : ({ a : B , b : Float }) >))
(\ d : (< d : (Rec D . Nat) , d : ({ d : Float , e : Nat }) >) . ((pred 1) . d))
(unfold [ ((Rec C . String) -> (C -> A)) ] ({ a = (\ d : String . c) , d = (pred (b as Bool)) }))
(pred (\ d : (({ d : (Unit -> Float) , a : String }) -> (< b : C , e : ({ c : Bool , b : Float }) >)) . ({ c = 1 , e = false })))
((let c = (let e = (if ({ b = c , c = false }) then (< b = a > as Nat) else true) in (< c = "apple" > as A)) in (unfold [ (Rec A . (< c : Nat , b : Nat >)) ] (fix a))) . d)
((< c = (fix (false as Bool)) > as (String -> Bool)) . a)
(fold [ (< a : (< e : B , e : String >) , b : ({ e : Unit , e : Bool }) >) ] (let c = (if (iszero a) then "boy" else (case c of < a = e > => false | < c = d > => 1)) in (pred "apple")))
(if (< e = (if (pred b) then (if c then 2 else "apple") else b) > as (< b : Bool , d : Bool >)) then (unfold [ ({ a : String , b : B }) ] (fix (fold [ A ] b))) else (case (fix (fold [ Unit ] c)) of < e = b > => ((0 (unfold [ String ] 1)) (fold [ A ] a)) | < e = c > => (succ (unit as A))))
(if (iszero (let d = (fold [ (< b : C , c : Nat >) ] a) in (1 . d))) then (iszero (fix 1)) else ((succ (1 (fix 2))) as ({ e : (A -> String) , c : (< c : A , d : A >) })))
(unfold [ ((Rec C . B) -> (B -> Float)) ] (unfold [ ({ c : (B -> String) , a : ({ c : Float , e : C }) }) ] (\ b : ({ d : A , b : A }) . (true as Nat))))
(unfold [ (Rec B . ({ e : B , d : A })) ] ((let b = 2 in "apple") as ({ a : ({ a : Nat , e : A }) , e : String })))
(iszero (fold [ (< b : Nat , b : String >) ] (< e = "apple" > as (C -> B))))
(< d = (if (fix (1 0)) then (\ a : (Unit -> Float) . (case a of < d = c > => "apple" | < b = e > => unit)) else ({ d = b , d = true })) > as (< e : (Rec E . (Rec E . Bool)) , c : (< e : (< b : Nat , b : B >) , c : (< d : B , a : Nat >) >) >))
((succ ({ c = (unfold [ Nat ] c) , a = 0 })) as ({ d : ({ b : Bool , b : (< a : Bool , c : Bool >) }) , a : (A -> C) }))
(({ e = ((unfold [ A ] (unfold [ C ] "apple")) . a) , a = (if ((case unit of < e = b > => a | < e = e > => a) . b) then (fold [ A ] 1) else (unit . a)) }) as (Rec C . ({ c : (Rec B . C) , e : ({ d : A , e : Float }) })))
(unfold [ (< e : ({ c : Unit , e : Nat }) , c : (< c : ({ c : (Rec E . Nat) , a : Float }) , d : ((Rec A . A) -> (< a : A , a : String >)) >) >) ] (fold [ (< e : ({ e : C , e : ({ d : String , c : B }) }) , b : (C -> A) >) ] ((case 2 of < b = b > => c | < a = e > => 0) . a)))
(pred (case (unfold [ Float ] c) of < e = b > => (if 1 then c else a) | < c = d > => (unfold [ Bool ] "apple")))
(case (\ e : (< c : String , c : ({ b : String , e : Unit }) >) . (fix 2)) of < c = d > => (if ((< e = b > as A) . a) then (succ ({ c = "apple" , d = (b as C) })) else (iszero c)) | < c = a > => (iszero ({ a = (pred "apple") , c = ("boy" . a) })))
(succ (({ d = (\ a : String . a) , c = (c "apple") }) as (< d : (Rec D . Unit) , a : ({ b : Nat , e : A }) >)))
((fold [ (Rec E . Unit) ] (unfold [ (< c : A , c : A >) ] false)) as (< d : (A -> C) , c : ({ e : (Rec B . Bool) , a : String }) >))
(pred (fix (if (if "boy" then 2 else c) then ({ c = unit , b = true }) else (< c = 0 > as A))))
(iszero (fold [ ({ c : Float , a : ({ e : Float , a : Float }) }) ] ("apple" as Float)))
(fix (case (fix (let b = b in a)) of < a = d > => (fold [ C ] true) | < c = b > => (pred 1)))
({ e = ((unfold [ ({ e : Float , c : A }) ] (b as String)) as (< c : (Rec B . A) , e : Float >)) , e = (fix ({ d = (\ e : Bool . 2) , b = (2 a) })) })
((pred (case "apple" of < c = e > => (unfold [ String ] b) | < a = e > => (fix false))) (< b = (\ d : ({ d : Float , d : Nat }) . (fold [ Bool ] true)) > as (< a : Float , a : Bool >)))
(fix (< d = (fold [ C ] (1 "boy")) > as ({ b : (Rec E . Bool) , b : C })))
(succ ({ d = (("boy" as (Rec E . Bool)) . a) , c = (unfold [ Float ] true) }))
(< d = (iszero (succ (pred c))) > as (((A -> Nat) -> (< e : Float , e : Float >)) -> (String -> Unit)))
((if (if 2 then 2 else true) then (let b = true in true) else (fold [ ({ a : Nat , c : Unit }) ] a)) as ((Float -> C) -> (String -> Float)))
(fix (case (pred unit) of < d = e > => (iszero (pred a)) | < c = c > => (let a = (c . b) in 1)))
(fix (fix (iszero 2)))
(succ (pred (iszero (if b then 0 else unit))))
((case ({ e = (fold [ (Rec D . Float) ] (iszero unit)) , a = (c . d) }) of < d = c > => ((unfold [ A ] (case 2 of < b = d > => 0 | < b = d > => a)) . e) | < e = b > => (let d = 2 in unit)) as ((< a : (< e : String , b : B >) , d : String >) -> (B -> ({ c : Float , d : B }))))
(pred (fold [ ((String -> B) -> (Rec A . Float)) ] (fold [ (Rec A . Unit) ] (iszero 1))))
(unfold [ (< a : (Rec C . (B -> A)) , d : ({ e : ({ b : Bool , b : Nat }) , a : (Nat -> (Rec E . Bool)) }) >) ] (case (if ({ e = 0 , b = unit }) then (succ (iszero 0)) else (1 as A)) of < a = b > => (succ unit) | < d = c > => ((0 c) . e)))
(({ e = (if (fix b) then false else a) , e = (pred true) }) (succ (< b = 0 > as Nat)))
(\ b : (< c : (Rec B . (Rec B . Float)) , d : ({ a : String , a : String }) >) . (pred (fix (succ 1))))
(succ (let a = (< e = (pred 2) > as B) in ((\ b : String . 1) . a)))
(< b = (fix (1 1)) > as ({ b : ({ d : (< e : Float , c : String >) , b : Bool }) , a : (Rec E . (B -> Nat)) }))
(case (< b = ({ c = (fix c) , c = (1 true) }) > as ({ a : ((Rec D . B) -> ({ b : Float , d : Unit })) , b : ({ c : (Rec A . C) , b : Float }) })) of < d = b > => (case ({ e = (succ "apple") , c = (iszero (let a = "apple" in c)) }) of < d = a > => (case ({ b = 0 , c = "boy" }) of < e = e > => ({ c = (if "boy" then false else a) , d = 0 }) | < e = c > => (1 . b)) | < e = a > => (fold [ Float ] (iszero 2))) | < b = b > => ((if "apple" then 0 else 2) . b))
((\ e : (< b : Bool , c : Bool >) . (unfold [ C ] "apple")) (let a = (iszero "apple") in (case "apple" of < a = b > => unit | < d = c > => ({ b = b , c = c }))))
(< a = (fold [ (({ b : Unit , a : String }) -> Unit) ] (fix ({ a = "boy" , c = true }))) > as (Rec B . ({ a : A , b : C })))
(let c = ((b as C) (succ c)) in ({ a = (succ "boy") , d = ({ c = "apple" , b = (unfold [ A ] "boy") }) }))
(if (if (let b = b in 0) then (iszero c) else (unfold [ Nat ] 1)) then (fix (let a = 2 in 0)) else (< a = ((< a = "apple" > as String) . b) > as (Rec A . (Rec D . (< c : B , d : Unit >)))))
(let e = (\ a : ({ c : Unit , c : Bool }) . (case 2 of < d = b > => b | < c = c > => unit)) in (case (succ (if a then b else (fix true))) of < b = e > => (if (fix ("apple" as A)) then (pred (case false of < d = e > => b | < b = c > => 0)) else (2 . e)) | < d = c > => (let c = (unfold [ (< d : Bool , e : A >) ] a) in (pred true))))
(((fix (case a of < e = d > => true | < a = c > => a)) . a) as ({ e : (Unit -> (Rec C . Nat)) , c : (< a : (Rec E . Float) , c : (A -> A) >) }))
(fix (unfold [ ({ c : ({ b : Float , d : String }) , a : (String -> Bool) }) ] (succ (iszero b))))
(({ b = (\ c : Nat . "apple") , b = (fix 1) }) as ({ e : (Bool -> C) , b : ({ c : A , e : B }) }))
((iszero (({ d = 0 , a = 0 }) . c)) . d)
(unfold [ (Rec D . (String -> Unit)) ] (unfold [ ({ b : B , b : Bool }) ] (let a = (< d = "apple" > as B) in (fix 0))))
(((\ c : String . (a as A)) as (Rec D . C)) (pred (("apple" as C) (fix b))))
((pred (succ false)) . a)
((< c = (let a = a in false) > as ({ d : Unit , e : Unit })) ((pred (0 false)) (case (succ a) of < c = e > => 0 | < a = a > => ("boy" a))))
(\ e : (< c : ({ e : ({ d : Unit , c : C }) , b : (Rec E . Float) }) , a : (String -> B) >) . ((if (pred 0) then ("apple" as Bool) else (let e = 0 in "boy")) . e))
(if (succ ((case "apple" of < e = e > => true | < a = a > => "boy") ("boy" . b))) then (pred ({ b = (succ false) , d = 2 })) else ((fix c) as ({ e : ({ e : B , b : B }) , e : Bool })))
(((\ d : (String -> A) . c) (unfold [ (< c : Nat , b : Nat >) ] 0)) . a)
(let d = ((fix c) (false as C)) in (((succ false) as (< c : Bool , a : A >)) . e))
(fold [ (Rec E . ({ b : Bool , e : C })) ] (\ d : (< d : Float , a : String >) . (pred c)))
(((unfold [ Unit ] "boy") (let a = c in 1)) ((if (if true then 1 else 2) then (if a then false else 2) else (0 2)) (if (unfold [ String ] b) then (fold [ Unit ] "apple") else true)))
({ a = (\ e : (< c : String , c : Unit >) . (\ b : C . 0)) , c = (succ (if (fold [ Float ] c) then 1 else unit)) })
(pred (((fix 2) . e) as ((< a : (C -> Bool) , c : (< d : String , a : Nat >) >) -> (C -> Float))))
(if (case (< c = (unfold [ C ] "apple") > as ({ d : String , e : Nat })) of < d = d > => (\ a : Nat . (let e = true in true)) | < d = b > => (pred (2 . e))) then ((\ e : ({ b : Bool , e : Nat }) . 2) (b a)) else (let e = (\ d : ({ c : A , e : Float }) . (case b of < a = b > => unit | < d = a > => 2)) in (c . a)))
(pred (let e = (fold [ Float ] (unfold [ Float ] "boy")) in ((succ "boy") as ({ e : ({ c : B , b : String }) , c : (C -> Bool) }))))
(succ (unfold [ (< b : String , a : Float >) ] (false . b)))
(unfold [ (Rec C . ({ b : (Rec C . Float) , a : (Rec E . A) })) ] (iszero (if (case 0 of < c = b > => 2 | < a = b > => false) then (b . d) else (pred b))))
(succ (pred (((if "apple" then false else "apple") . d) as (< d : Bool , a : (B -> Float) >))))
(((fold [ String ] (succ "boy")) as (Rec E . String)) . b)
(case ((let b = (1 as Nat) in (< d = a > as Float)) ((fix unit) as ({ d : Float , a : Unit }))) of < a = d > => (fold [ ((Rec A . Float) -> (Rec A . (< d : String , a : Nat >))) ] ((unfold [ A ] a) as (< c : (< a : A , d : Nat >) , a : (String -> A) >))) | < e = d > => ({ b = (let b = c in (let a = "boy" in b)) , a = ({ c = 2 , d = (c as B) }) }))
((unfold [ (B -> (Rec A . Bool)) ] (fold [ (< d : Nat , d : C >) ] b)) as (((< d : C , a : C >) -> (Nat -> Nat)) -> ((B -> String) -> (Rec D . String))))
(let b = (case (succ (let b = unit in "apple")) of < b = e > => (< a = true > as B) | < b = a > => ((< b = b > as Unit) as Bool)) in (unfold [ (< b : (< e : Float , b : Nat >) , b : ({ e : B , e : Unit }) >) ] ((let b = 2 in b) . b)))
(pred ((let a = (< a = true > as A) in 1) . c))
(let c = ((iszero (pred 0)) as (< d : ((B -> B) -> (< c : C , a : B >)) , e : (C -> A) >)) in ((unfold [ Nat ] 2) . a))
(pred (let c = (a as Nat) in ({ a = true , d = (unit as String) })))
(let c = ((\ d : String . (unfold [ A ] false)) ((fold [ C ] c) ("boy" as Bool))) in (({ a = (unfold [ B ] unit) , d = (pred 1) }) . b))
(fix (let e = (unfold [ (Float -> A) ] (fix b)) in (let c = true in "boy")))
(case (fold [ ({ b : C , c : Float }) ] (case 0 of < a = d > => 0 | < c = e > => c)) of < e = d > => (((unit . e) . d) (iszero (iszero (b unit)))) | < d = d > => (\ c : (Rec D . Float) . (fix (c 2))))
(let d = (if (fix 2) then ({ c = ({ b = a , e = "boy" }) , c = a }) else (unfold [ (Rec A . ({ b : C , a : String })) ] (\ b : Bool . a))) in ({ b = (fix 0) , b = (iszero "boy") }))
(unfold [ ((Rec A . B) -> (Rec D . C)) ] (iszero (case "boy" of < b = d > => 2 | < e = b > => (2 "apple"))))
((iszero (succ 2)) . e)
(succ (case (false . e) of < b = d > => (iszero 1) | < b = b > => (2 as Bool)))
({ b = (fix (fold [ (B -> B) ] (if "boy" then unit else 0))) , b = (\ c : (< e : ({ d : Bool , d : C }) , d : (< c : (< d : A , a : String >) , a : String >) >) . (iszero true)) })
((< d = (\ e : B . b) > as (B -> (< e : Float , b : Float >))) as (Rec B . ({ e : (Nat -> (Rec A . B)) , a : (Nat -> A) })))
(((fold [ C ] b) (let b = b in (if true then "boy" else "boy"))) as ({ c : ((Unit -> Unit) -> (Nat -> String)) , a : ((Rec C . ({ c : B , c : Nat })) -> (< c : String , b : C >)) }))
(fix (succ ((let e = (a as B) in (c as Bool)) as (< d : Nat , c : B >))))
(case (fix (case (\ c : Unit . true) of < c = b > => (if 0 then 1 else b) | < c = c > => (unfold [ Nat ] "apple"))) of < a = b > => (let d = ((fix "boy") as (< d : ({ a : Nat , a : B }) , b : (Nat -> C) >)) in ({ d = (fix 0) , a = ({ a = c , e = "apple" }) })) | < b = a > => (< e = (if false then (\ a : B . false) else (let b = 2 in a)) > as (< e : (< e : Bool , b : Float >) , e : C >)))
(unfold [ (Rec C . (< b : A , a : Nat >)) ] (< e = (unfold [ ({ c : B , d : C }) ] (unfold [ B ] c)) > as ({ e : ({ c : A , a : Float }) , b : B })))
({ a = (fix (pred (fold [ B ] c))) , d = (pred (c . b)) })
(let b = (< e = (if (< e = unit > as (< e : String , a : C >)) then (\ c : (< e : C , d : C >) . (unfold [ B ] a)) else (iszero false)) > as ({ b : (Rec D . Unit) , d : (Float -> Float) })) in (("apple" as Nat) (let d = (succ true) in ("apple" 1))))
(\ e : (< d : (< a : B , a : Nat >) , b : ((Rec D . Nat) -> A) >) . (\ e : (< c : A , b : B >) . (< a = a > as (Float -> A))))
(iszero ({ a = (< a = (< a = true > as String) > as ({ e : B , e : A })) , e = (let c = (pred 0) in (iszero (succ c))) }))
((let e = (\ e : A . (if b then 2 else 1)) in (\ a : ({ a : (< b : C , c : Bool >) , c : ({ e : C , e : Nat }) }) . (if ({ d = "boy" , e = unit }) then 2 else (iszero 2)))) (iszero (\ c : Bool . (pred 1))))
(iszero (({ a = 2 , a = ({ b = "apple" , b = c }) }) as (Rec C . Unit)))
(let d = (let c = (if false then false else "boy") in ((true . e) a)) in ({ b = (if (if 1 then "boy" else true) then "apple" else (b "apple")) , c = ("apple" (if 0 then c else true)) }))
(unfold [ (< c : (< d : Nat , c : Bool >) , e : (Rec D . String) >) ] ((let e = 2 in false) . e))
(succ ((case (let c = a in unit) of < b = d > => (a 1) | < c = d > => true) . c))
(iszero (if (((unfold [ Nat ] true) as Unit) as (Rec C . (< c : C , b : Bool >))) then (succ (< e = c > as Bool)) else (fold [ (Bool -> Float) ] (0 as B))))
(iszero (iszero (if (pred c) then c else (let c = false in true))))
(pred (pred (\ b : Bool . false)))
(case (< a = (fix b) > as ({ b : Bool , b : Bool })) of < b = c > => (succ (if unit then 1 else c)) | < d = c > => ((< c = (let d = 1 in "apple") > as (Rec E . String)) (c . a)))
(iszero (if (< b = 0 > as (< b : Bool , b : Float >)) then (< d = 1 > as String) else (unfold [ ({ a : B , e : (Bool -> Unit) }) ] (let e = (true as Float) in c))))
(\ d : ((Rec E . ({ c : B , d : C })) -> (Rec D . ({ e : A , a : (Rec B . Nat) }))) . (case (fold [ (< b : Nat , c : B >) ] (unfold [ Nat ] unit)) of < c = e > => ({ c = (unfold [ Nat ] "boy") , a = (c as (< d : Nat , a : Nat >)) }) | < e = e > => (unfold [ Nat ] (1 . e))))
(unfold [ ((C -> Nat) -> (Nat -> String)) ] (case (succ 2) of < c = d > => (< d = (c false) > as Float) | < e = c > => ({ e = 1 , d = b })))
(fix (< c = (succ false) > as (Rec A . String)))
(succ (\ d : (Rec A . A) . (if (case 2 of < b = e > => 1 | < a = c > => 1) then (fix (2 2)) else (fold [ Bool ] 2))))
({ b = ({ e = (< b = ("apple" as B) > as (Bool -> Nat)) , c = (pred (unit true)) }) , a = (\ b : (Bool -> (Rec B . Float)) . (iszero (iszero true))) })
(pred (< e = (2 . e) > as (Rec E . ({ d : A , b : String }))))
({ a = (fix ({ a = ({ c = "boy" , e = c }) , d = 2 })) , d = (< d = ((iszero true) as ({ c : Nat , d : C })) > as (((< b : Float , b : Unit >) -> Float) -> ({ a : Nat , b : Nat }))) })
(fold [ ((Rec D . Float) -> (Rec A . (C -> B))) ] (succ (iszero b)))
(iszero (((fix 0) as (Rec A . Float)) as (Rec A . A)))
(iszero (iszero (case (fix unit) of < d = b > => ((case 1 of < a = c > => a | < c = a > => b) (fix 1)) | < b = a > => (let a = c in 2))))
(case (unfold [ (Rec C . Unit) ] ((\ d : Bool . (iszero a)) . a)) of < a = e > => ((fix ({ b = b , c = 1 })) (fold [ ({ e : Unit , c : B }) ] (fix (iszero c)))) | < b = e > => ((fold [ ({ b : String , c : Bool }) ] 0) ((let d = "apple" in "boy") as (Rec D . Bool))))
(iszero (fold [ (< c : Nat , b : (Rec E . Bool) >) ] (pred (b "boy"))))
(fix (case (pred "boy") of < d = d > => (pred (case a of < e = d > => 1 | < c = c > => 1)) | < c = d > => (fix "apple")))
(fold [ ({ d : ({ c : Nat , b : String }) , a : ({ b : A , c : ({ a : C , d : Nat }) }) }) ] (fix (fix "apple")))
(\ e : (< d : ((< c : (< c : String , b : B >) , c : Nat >) -> (Rec C . (< c : C , b : Nat >))) , c : ((Rec B . C) -> ({ b : Unit , b : Bool })) >) . (({ b = (iszero (iszero "boy")) , a = (iszero false) }) (c as (Bool -> String))))
(succ (pred (unfold [ Nat ] a)))
({ d = (\ a : (< b : ({ b : C , e : String }) , e : ({ c : Bool , a : A }) >) . (if (b . a) then ({ d = 2 , c = false }) else (< b = 0 > as String))) , a = (fix (\ d : (Unit -> B) . (\ d : String . true))) })
((let d = (if b then "boy" else b) in (pred b)) (case (succ (1 . b)) of < c = e > => ((unfold [ Bool ] 0) (if 0 then 1 else 0)) | < b = e > => (iszero ({ b = "boy" , c = 0 }))))
(\ b : (< c : (Rec A . (< a : Bool , a : B >)) , c : (< e : (Nat -> Float) , a : (A -> B) >) >) . (fix ({ a = 2 , b = (if "apple" then true else "apple") })))
(pred (pred ({ b = (true as C) , c = 2 })))
(succ (((c . e) as ({ b : Bool , b : B })) as (Rec A . ({ a : Float , d : String }))))
(unfold [ (< a : (< d : (B -> Float) , d : (Rec C . C) >) , a : ({ c : B , b : Nat }) >) ] (let e = (case 1 of < e = a > => unit | < d = d > => true) in (< d = "apple" > as Float)))
(unfold [ (< a : (B -> Float) , d : ({ b : A , b : Float }) >) ] (let b = ({ a = 1 , c = (if "boy" then b else false) }) in (iszero a)))
(fold [ ({ d : (< a : (< a : A , c : A >) , c : (Rec B . Nat) >) , e : ((C -> Nat) -> (Rec E . Unit)) }) ] (unfold [ ({ c : String , d : Bool }) ] (a as String)))
((\ d : (Rec E . Float) . (< d = b > as A)) (case ({ a = "boy" , a = (fold [ B ] b) }) of < a = c > => ({ d = (c as Nat) , e = (fold [ C ] c) }) | < d = d > => (\ c : ({ d : B , c : Bool }) . ({ c = "boy" , e = 0 }))))
({ b = (succ ((if "boy" then "apple" else (case 0 of < e = a > => "boy" | < e = b > => 0)) as (< d : Unit , c : Nat >))) , a = ({ e = (if (fold [ A ] c) then (0 . c) else (case 0 of < e = a > => "boy" | < e = e > => "apple")) , d = (fold [ A ] (c . a)) }) })
(< c = ((case (fold [ B ] true) of < b = e > => ({ d = "apple" , d = b }) | < b = d > => false) (unfold [ B ] "apple")) > as (< c : ({ d : (< c : C , c : B >) , b : ({ d : Bool , d : C }) }) , c : ({ d : (< a : Unit , e : Unit >) , c : C }) >))
(succ (case (fold [ (Rec E . B) ] ("apple" 0)) of < c = a > => (succ a) | < e = c > => (\ c : String . 2)))
(unfold [ (Rec B . (Rec D . C)) ] (< a = ((fold [ A ] false) (fold [ Bool ] 1)) > as (({ d : B , e : (< d : A , a : C >) }) -> (Rec B . Nat))))
((if (a . c) then (fix (fix true)) else ((if a then true else b) . e)) (case (pred b) of < e = d > => (fix (\ e : Nat . "boy")) | < e = a > => ({ d = "boy" , c = (if c then "boy" else true) })))
(case ({ a = (unfold [ String ] "boy") , e = (let a = (let a = "apple" in 1) in 0) }) of < d = c > => ((< c = 1 > as Float) (pred 0)) | < a = c > => (unfold [ (Nat -> A) ] (< b = b > as Bool)))
(fold [ (Rec A . ({ e : (Rec C . Nat) , a : ((< c : Nat , b : A >) -> Nat) })) ] (unfold [ ({ d : String , e : C }) ] (iszero (\ d : A . (fold [ Nat ] b)))))
((unfold [ (< c : (Rec A . String) , d : (String -> C) >) ] (if (succ c) then (< e = true > as Unit) else ((if "apple" then "boy" else unit) as B))) as (Rec B . (Rec D . ({ c : Float , d : Float }))))
(fold [ ({ c : (< e : String , a : (Rec E . Unit) >) , d : ({ b : String , a : Bool }) }) ] ({ a = (case (if (succ true) then ({ c = false , a = b }) else (fix c)) of < e = c > => (iszero "boy") | < d = d > => (fix 2)) , b = (case b of < e = c > => unit | < d = a > => (c "apple")) }))
(fix (((true b) as (Bool -> B)) . b))
(unfold [ ({ a : (< c : Nat , a : Float >) , a : (< e : Float , a : (< b : Bool , e : A >) >) }) ] ((0 . c) . c))
(fold [ (< b : (Rec E . (Rec C . String)) , c : (Nat -> C) >) ] (iszero (succ (succ 2))))
({ b = (\ a : (Rec D . (Rec D . Bool)) . (case 2 of < b = c > => 1 | < b = a > => (succ "apple"))) , d = (fix ({ b = 0 , d = c })) })
(unfold [ (Rec C . (({ e : Float , b : Unit }) -> (< b : Bool , a : Unit >))) ] (unfold [ (Rec A . (Rec D . Bool)) ] (let a = (fold [ Bool ] 0) in ("apple" as String))))
(fold [ (< d : (< a : ({ c : B , e : Float }) , b : ({ c : Bool , c : Unit }) >) , e : (< e : Nat , d : Nat >) >) ] ((1 . c) . e))
(case (let e = (let b = ({ a = unit , b = a }) in "boy") in ((fold [ B ] false) . c)) of < b = c > => ((succ "boy") as (< c : Float , c : A >)) | < a = a > => ({ e = (unit as C) , b = (succ "apple") }))
((case (< d = (let e = b in a) > as (< b : B , a : Bool >)) of < a = c > => (iszero (\ a : C . c)) | < d = a > => ("apple" (let e = unit in 1))) . b)
(((c as String) (fix 0)) (fix (if (if unit then unit else 0) then (if 0 then 2 else "boy") else (unfold [ ({ a : String , e : Unit }) ] (unfold [ Unit ] c)))))
(if (unfold [ ({ b : (Rec E . Unit) , b : A }) ] (iszero "apple")) then (succ (fold [ (Rec B . A) ] ((if false then true else 2) as Float))) else (unfold [ (< b : C , d : String >) ] ((if "boy" then "boy" else 0) as Unit)))
(fix (let c = ((a as B) . e) in (< d = (succ a) > as Bool)))
(pred ({ a = (fix (unfold [ Unit ] c)) , e = ((succ (0 . e)) (true . d)) }))
(fix (if (c as Bool) then (if (fix unit) then (case 0 of < e = a > => 0 | < a = d > => c) else 0) else (pred (a as Bool))))
(fold [ (< b : (< c : String , a : String >) , c : ({ d : Unit , d : (Rec A . Nat) }) >) ] ((let c = b in false) (succ true)))
((unfold [ (< e : (< b : B , c : Float >) , d : String >) ] ((fold [ Nat ] "apple") ({ e = (succ 0) , c = (if 2 then c else b) }))) as (Rec A . ({ e : Unit , b : (Rec A . B) })))
({ a = (unfold [ (< b : Float , d : ({ b : Float , e : Float }) >) ] (fold [ (Rec E . Bool) ] unit)) , a = (\ d : (A -> A) . (< b = 2 > as Float)) })
(case (((fold [ Float ] 0) . c) (\ a : (Rec A . Unit) . (unfold [ Bool ] 1))) of < e = e > => (succ (unfold [ Float ] 0)) | < a = d > => ((fold [ (String -> Bool) ] 2) . a))
(fix ((c as Bool) . c))
(< a = (let d = (succ ({ c = a , a = b })) in (\ b : (Rec D . A) . ("boy" as B))) > as ((String -> Float) -> (< a : Nat , c : Unit >)))
(succ (let c = (case c of < e = d > => c | < c = c > => c) in (\ c : (< a : Float , e : C >) . (fix false))))
(case (fold [ (Rec B . B) ] (unfold [ (< d : C , a : A >) ] ({ c = false , d = unit }))) of < c = b > => (< e = (fix (< d = c > as C)) > as ({ b : ({ a : C , d : String }) , b : (Unit -> A) })) | < d = c > => (< b = (a 0) > as (< a : Nat , c : A >)))
(succ (\ a : (Rec D . ({ e : C , d : (Rec B . Unit) })) . ({ c = ((fold [ B ] 2) ({ b = a , a = 2 })) , a = ((a . b) 0) })))
(case (\ d : ((Rec E . String) -> (< c : (Rec A . B) , b : ({ b : Bool , a : Float }) >)) . (if (iszero (false . c)) then (if (pred b) then (fold [ String ] b) else "apple") else (\ e : ({ c : Bool , c : Bool }) . (2 as Nat)))) of < d = b > => (let d = (unfold [ String ] 2) in (< d = "boy" > as Bool)) | < e = a > => ((let d = "apple" in (pred true)) . a))
((let a = (if unit then unit else 0) in (unfold [ Float ] "boy")) as ({ e : (< e : Float , c : ({ a : String , d : A }) >) , b : (Rec A . Unit) }))
(< b = (fix (fix (fold [ Nat ] 1))) > as (< c : (Bool -> B) , d : ({ a : Float , c : String }) >))
(iszero (pred (let e = a in c)))
((if ({ c = "boy" , c = (let c = 0 in a) }) then (pred unit) else (unfold [ B ] false)) ({ c = (2 as Bool) , d = (a as Nat) }))
(pred (if (if (< e = false > as Bool) then "boy" else a) then (let c = ("boy" as Bool) in 2) else (true as String)))
(if (< c = (< c = (< a = ({ e = 0 , d = "boy" }) > as ({ c : String , d : C })) > as (Rec D . C)) > as ({ a : (A -> A) , e : String })) then (fold [ (Rec D . (Rec A . Bool)) ] ({ e = (unfold [ B ] false) , b = (if "boy" then "apple" else (if c then c else unit)) })) else (pred (pred false)))
(iszero (let c = (iszero false) in (fix 0)))
(case (case (unfold [ (A -> Bool) ] (a . a)) of < e = e > => (let c = true in 1) | < b = c > => (succ "boy")) of < e = d > => ({ e = (if (pred b) then (unfold [ Float ] unit) else true) , c = ((unit . d) (iszero b)) }) | < d = b > => (let d = ((unfold [ Float ] false) . d) in (unfold [ ({ c : (< a : Unit , c : String >) , b : ({ e : B , e : C }) }) ] ({ c = (case false of < a = a > => 0 | < e = d > => true) , d = 1 }))))
(\ a : (< a : ({ e : (C -> B) , e : (< c : C , a : String >) }) , e : (Rec B . ({ d : Unit , b : Float })) >) . (succ (< a = (iszero 0) > as (Rec E . A))))
(let c = (case (let b = ("boy" as B) in (case a of < c = a > => true | < a = e > => c)) of < e = d > => (< b = true > as Nat) | < c = e > => (if (< e = b > as B) then "apple" else "boy")) in ((succ (2 as String)) . e))
(if (iszero (succ false)) then (iszero (if (unfold [ Float ] 2) then (fold [ Nat ] a) else c)) else ((unfold [ A ] 1) . a))
(fold [ (Rec D . ({ d : ({ e : String , c : Unit }) , b : (< e : Float , a : Float >) })) ] (({ c = false , a = 0 }) . d))
(if ((succ unit) . c) then ({ b = (let a = (unfold [ String ] 1) in (fix (pred "boy"))) , e = (iszero unit) }) else ((fix true) . d))
({ d = (fold [ (< a : Unit , d : C >) ] (case a of < a = e > => (succ "apple") | < c = a > => (\ a : C . b))) , b = (< c = (pred false) > as (A -> (< c : Unit , e : Nat >))) })
((< a = ({ a = (pred false) , a = ({ d = 1 , e = false }) }) > as ({ e : Nat , a : B })) . a)
(fold [ ((Bool -> Unit) -> (Rec E . Unit)) ] (if (pred ("apple" . a)) then ({ e = (fold [ Float ] unit) , e = (fix "boy") }) else (if ("apple" as Nat) then (\ c : C . c) else (unfold [ String ] false))))
(case (\ d : (< e : (B -> A) , b : B >) . (fix "apple")) of < a = c > => (case ((if unit then unit else true) as Nat) of < c = a > => (iszero unit) | < c = e > => (let a = (fold [ B ] 1) in (if 2 then 0 else true))) | < b = c > => (fold [ ((< b : A , d : A >) -> (Rec C . Bool)) ] (if b then (unfold [ Nat ] 0) else (case c of < e = c > => 0 | < b = d > => a))))
(iszero (let c = ({ e = (unit . b) , e = (if false then unit else b) }) in (case b of < c = c > => 0 | < a = e > => "boy")))
(succ (pred (fold [ (< c : Unit , e : Bool >) ] (let a = false in unit))))
(if (iszero (unfold [ (< b : (< e : String , b : A >) , b : Bool >) ] ({ a = a , a = c }))) then (case (succ "apple") of < e = d > => (unfold [ (< b : A , b : B >) ] (pred (fix 2))) | < d = b > => (let c = "boy" in (succ true))) else (let c = (iszero 1) in (unfold [ (< a : C , c : A >) ] 0)))
(if ((("apple" . d) (1 true)) . c) then (\ a : (Rec C . (A -> Unit)) . (fix (unfold [ Bool ] (c "apple")))) else (fix (if unit then "apple" else unit)))
(\ a : (< d : ({ c : ({ a : Unit , b : ({ d : C , a : String }) }) , b : (Rec E . (Rec C . String)) }) , d : ((Rec D . C) -> (Rec E . (< b : Nat , e : B >))) >) . (let c = (\ e : String . c) in (\ d : (Unit -> Bool) . (\ b : B . a))))
(case (fix ({ e = (iszero true) , c = (let c = (succ "apple") in b) })) of < d = a > => (case ((if a then false else 1) false) of < c = a > => (fold [ ({ d : Bool , a : B }) ] false) | < c = c > => ({ c = false , a = "boy" })) | < c = a > => (pred ((unit . a) . c)))
({ b = (iszero (fix "boy")) , c = ({ a = (if (succ 1) then (if true then "apple" else a) else (if unit then 2 else "apple")) , b = (fix (fold [ A ] "boy")) }) })
(\ c : (Rec B . (< a : A , d : (< c : Float , a : A >) >)) . (succ (unfold [ Float ] (if c then 2 else 1))))
(fix (pred (unfold [ (Rec D . Nat) ] (case (\ a : Nat . true) of < a = d > => (\ b : C . 1) | < e = e > => "boy"))))
((fold [ (Rec C . ({ c : (< e : B , d : Nat >) , b : (< c : Unit , d : Float >) })) ] (succ (fix "apple"))) (case (let c = (< d = "apple" > as A) in (c true)) of < c = e > => (\ d : Float . (< e = false > as Float)) | < e = a > => (unit . d)))
(succ (unfold [ (({ e : Unit , c : Unit }) -> (< a : A , c : A >)) ] (\ e : ({ a : B , b : Nat }) . (succ false))))
(< c = (let d = (\ d : (Rec C . Nat) . true) in (iszero (fold [ Float ] true))) > as ((< d : Float , d : Bool >) -> (< d : (< a : Nat , d : Nat >) , d : (Nat -> Bool) >)))
({ b = (unfold [ ({ b : String , d : ({ d : Float , b : Bool }) }) ] (a unit)) , d = ({ b = (iszero c) , e = ({ c = unit , c = (a . b) }) }) })
((< c = (if (pred "boy") then (pred true) else (< e = 1 > as String)) > as (C -> Unit)) ((a . e) as (< d : (< a : (B -> Nat) , e : B >) , e : (Nat -> String) >)))
(fix (if (let a = "boy" in (if unit then 1 else unit)) then (if (fix b) then (fix true) else (pred false)) else ((fold [ Nat ] b) . a)))
(\ d : (((Rec C . A) -> (Rec B . (< d : A , c : Float >))) -> ((Rec A . Unit) -> (Rec B . B))) . ({ d = (case "boy" of < a = a > => a | < c = c > => 2) , b = (fold [ B ] 1) }))
({ e = (pred (fold [ (< a : B , d : C >) ] (if unit then false else c))) , e = (case (unfold [ B ] (1 . d)) of < b = a > => (< c = (succ c) > as Unit) | < a = e > => (fold [ ({ b : (< b : Nat , c : B >) , a : (Rec D . C) }) ] (let e = 2 in a))) })
(unfold [ (Rec C . (Bool -> Bool)) ] ((fold [ A ] (pred false)) as ({ e : B , a : ({ d : String , a : Float }) })))
(case (< a = ({ d = a , d = true }) > as (< c : Float , c : A >)) of < c = e > => (let d = (case 2 of < d = a > => c | < d = c > => (unit . e)) in (succ b)) | < d = a > => (< c = (unfold [ B ] 1) > as (< d : Unit , b : C >)))
(pred (let a = (let a = (let d = 2 in a) in ({ a = false , a = a })) in (fold [ ({ d : B , b : B }) ] (< b = 2 > as C))))
(fix (if (< a = ({ d = (unfold [ Float ] c) , b = 0 }) > as ({ e : Unit , b : Bool })) then (fold [ ({ d : Unit , b : C }) ] unit) else (let a = (2 a) in (pred b))))
(< b = (\ b : (Rec A . B) . (unfold [ (String -> String) ] a)) > as ((< a : (Rec A . ({ d : A , d : Nat })) , c : (Bool -> B) >) -> (< e : Float , d : Bool >)))
(unfold [ ({ c : (Rec C . C) , a : (< b : ({ e : A , b : B }) , b : B >) }) ] (pred (pred c)))
(fix (let d = (if 0 then c else false) in (fix "boy")))
(succ (({ b = (fold [ (A -> Float) ] (pred unit)) , b = (let c = (c . d) in 2) }) as (({ d : C , b : C }) -> (C -> B))))
(fix (unfold [ (({ d : Bool , a : Unit }) -> ({ e : B , d : String })) ] (((\ a : Float . "boy") "apple") as (Rec C . ({ e : Unit , b : Bool })))))
(let a = (let a = (< a = (succ unit) > as (Rec A . ({ e : Bool , c : Nat }))) in ((iszero 1) (iszero (pred c)))) in (fix (unit ({ d = 2 , c = 0 }))))
(pred (pred (fold [ (< a : Float , d : Bool >) ] (fix 0))))
(\ a : ({ e : (Rec B . (< e : ({ e : Float , e : Bool }) , e : String >)) , a : (Rec B . (Float -> C)) }) . (succ (pred "apple")))
({ a = (< c = (fold [ (< d : B , a : A >) ] ({ e = ({ e = a , e = 0 }) , a = (succ 2) })) > as ({ d : (Rec E . Bool) , e : (< b : (A -> String) , a : Float >) })) , b = ((pred (succ 0)) as (< d : (Float -> B) , c : B >)) })
(< e = (iszero ((unit as Unit) as (C -> (Rec A . String)))) > as ((< c : (< b : Bool , a : Nat >) , c : ({ c : C , c : A }) >) -> (< b : Float , a : A >)))
(((iszero ((b . d) as ({ d : Unit , b : String }))) as ((A -> B) -> (Rec C . Unit))) . b)
(iszero (case (unfold [ ({ a : Nat , e : Float }) ] (pred b)) of < c = b > => ({ c = (let e = (true "apple") in (case 2 of < e = a > => "apple" | < b = a > => 2)) , b = (fold [ String ] (< e = b > as Float)) }) | < c = e > => ((case "apple" of < c = b > => c | < a = e > => unit) as B)))
(let d = (pred ((pred "apple") as (Rec D . Nat))) in (let c = (2 true) in (iszero 0)))
(fix (let b = ((iszero unit) . c) in (fold [ A ] true)))
((unfold [ ({ a : Bool , b : (String -> C) }) ] (let c = true in false)) as ((A -> Float) -> ((< b : Float , b : Float >) -> B)))
(pred ((fix "boy") . e))
(succ (\ d : (< e : (B -> Float) , e : ({ e : (< d : B , d : B >) , d : Bool }) >) . ((iszero "apple") . e)))
((succ (false . e)) as (< d : (Rec D . Unit) , b : (({ e : A , d : (B -> Unit) }) -> (< a : ({ e : C , b : A }) , c : (Rec C . String) >)) >))
(iszero (fold [ (Rec C . ({ d : String , a : Bool })) ] (1 unit)))
({ b = (unfold [ ({ e : Unit , c : Nat }) ] (succ (unfold [ (< d : Bool , e : Bool >) ] (fold [ Unit ] true)))) , d = (if (2 as Unit) then (< e = 1 > as (< c : Float , a : B >)) else (let b = (iszero c) in (succ ("boy" as String)))) })
({ c = (iszero ((iszero false) unit)) , d = (fold [ (Rec E . (Rec E . Unit)) ] (pred (unfold [ String ] a))) })
(pred (let a = ("boy" . c) in (true (fold [ String ] a))))
(iszero (iszero ((let b = 1 in unit) . a)))
(let e = (case (succ (\ e : String . b)) of < d = a > => ((\ c : String . c) true) | < d = a > => (pred "apple")) in (let a = ("boy" 1) in (fold [ Unit ] "boy")))
(succ (unfold [ (Rec D . String) ] (let a = 2 in a)))
((let b = (unfold [ ({ b : String , d : (C -> B) }) ] (let d = 0 in "boy")) in (if (pred b) then unit else a)) . c)
((let d = (pred ({ e = 0 , e = 1 })) in (unfold [ (Rec B . Float) ] (if 1 then c else "apple"))) as (({ e : A , e : Unit }) -> (Rec E . ({ b : Nat , a : C }))))
(iszero ((if (fix unit) then (< c = c > as Bool) else c) (< a = (let a = true in "apple") > as String)))
(\ a : ((Rec D . A) -> (< a : (String -> Unit) , a : ({ d : Bool , a : Unit }) >)) . ({ a = (< e = ("boy" as A) > as (Rec C . (< c : Nat , e : Nat >))) , c = (fix "apple") }))
(unfold [ (< a : ((< c : Nat , b : Bool >) -> ({ e : Nat , a : C })) , b : ({ b : Bool , c : (< d : Unit , d : Bool >) }) >) ] (\ e : (Rec A . (Unit -> B)) . (let d = (< e = (2 0) > as Bool) in (pred c))))
(case ({ a = ((< b = "boy" > as Unit) as (< a : Bool , c : Unit >)) , b = (true . d) }) of < b = b > => (let a = (unfold [ Unit ] b) in ((fold [ A ] unit) as ({ d : String , d : A }))) | < a = c > => (< d = (< d = (case 2 of < e = d > => "apple" | < a = d > => (\ a : Float . 0)) > as ({ e : (Unit -> Unit) , a : Nat })) > as ({ e : (< d : Unit , d : Float >) , b : (< a : Bool , b : B >) })))
(fix (if ({ b = "apple" , b = c }) then (let b = (case true of < c = b > => "apple" | < e = b > => unit) in (< a = a > as B)) else (unfold [ (Rec E . B) ] ("apple" . b))))
((let e = (unfold [ (Rec E . Unit) ] (false . b)) in (fold [ (< c : A , d : C >) ] ({ d = true , c = 2 }))) (unfold [ (Rec C . A) ] (case b of < b = c > => (let e = unit in "apple") | < c = d > => 1)))
((case (let b = (iszero 2) in c) of < e = d > => (pred (let b = 0 in (unfold [ C ] true))) | < c = c > => (case (fold [ Float ] a) of < d = b > => (< b = (fix unit) > as B) | < b = c > => (let a = c in c))) as ((< b : (< d : Bool , b : Nat >) , e : (Rec E . C) >) -> (< a : ({ b : A , a : Unit }) , d : (C -> A) >)))
(fold [ (< c : ((Rec C . Nat) -> (C -> (Rec A . String))) , c : (Rec B . Bool) >) ] (unfold [ (< c : ({ d : (< b : Bool , c : C >) , b : ({ c : Float , e : Nat }) }) , e : (< b : (< b : Nat , c : B >) , c : A >) >) ] (\ a : ({ c : ({ c : Bool , a : Unit }) , a : (A -> B) }) . (\ d : A . true))))
({ b = ((\ b : C . 2) as (Rec E . ({ b : Bool , d : Nat }))) , c = (succ ((let a = b in c) (0 1))) })
(\ e : ((< e : (Float -> Bool) , c : (Rec A . Nat) >) -> ({ d : (String -> B) , b : ({ d : (String -> B) , a : (Rec D . C) }) })) . (fix (unfold [ (Rec B . B) ] (case b of < d = c > => ({ a = true , b = true }) | < c = d > => 0))))
(\ a : (Rec A . ({ b : C , a : Nat })) . (iszero (iszero ({ e = "apple" , d = "apple" }))))
(case (pred (if (1 as ({ a : Float , c : Nat })) then (\ a : A . 2) else (unfold [ Float ] unit))) of < d = e > => ((pred (2 . c)) as (((< a : String , c : A >) -> (Bool -> Bool)) -> (Rec B . String))) | < b = e > => (unfold [ ({ d : (Unit -> Float) , a : (Rec D . Bool) }) ] (if "boy" then c else "boy")))
({ e = ((< b = a > as String) (case unit of < c = e > => false | < b = e > => a)) , c = (let d = (("apple" as Float) (succ 1)) in ((b as Nat) (1 . e))) })
(pred ((c . d) as (String -> B)))
(case (pred ((if a then (if b then c else c) else a) . e)) of < c = c > => ((pred true) as ((B -> A) -> Unit)) | < b = b > => (iszero (iszero a)))
(unfold [ (< a : (C -> A) , e : (< e : Unit , e : ({ b : B , a : Unit }) >) >) ] (let d = (fold [ A ] a) in (unfold [ B ] 0)))
({ d = ((\ d : (Bool -> B) . (\ c : (Unit -> B) . "boy")) ({ d = (fold [ Nat ] 0) , b = (< d = (\ b : Nat . "boy") > as Nat) })) , a = (< b = (iszero a) > as (< e : Unit , a : Float >)) })
(let c = (succ (\ c : String . false)) in (if (iszero b) then (fix (b a)) else (case (let b = c in true) of < c = d > => (true as B) | < c = d > => false)))
(fold [ (< d : (< c : ({ c : C , d : Bool }) , b : B >) , a : ({ a : (Rec A . A) , a : B }) >) ] (< e = (pred 1) > as (Rec E . Unit)))
(case (\ e : (({ b : Float , e : String }) -> (Rec D . String)) . (unfold [ (Rec A . Float) ] (case c of < a = a > => true | < b = b > => "boy"))) of < c = a > => ((unfold [ C ] (false . d)) (\ a : A . 2)) | < d = b > => (iszero (if false then "apple" else false)))
(< d = (iszero (pred (< c = unit > as B))) > as (< b : (Rec A . (< a : Unit , a : Float >)) , b : (< e : (< a : Nat , d : Float >) , e : B >) >))
(if (iszero (let a = 0 in (case 1 of < d = a > => false | < a = e > => false))) then (let b = (if unit then 1 else c) in (let e = (iszero b) in (case false of < c = b > => (succ true) | < c = c > => (\ e : String . 0)))) else ((\ e : (Rec B . Unit) . ({ b = unit , b = true })) (succ a)))
(\ e : (Rec B . ((Rec E . (B -> Unit)) -> (Rec D . C))) . (case ("boy" b) of < a = d > => (if (unit . a) then 2 else (fix unit)) | < c = e > => ((0 1) . c)))
({ a = ((case 1 of < c = e > => "apple" | < e = a > => 2) ({ d = (unfold [ ({ d : C , b : A }) ] true) , a = (iszero false) })) , e = (fold [ (< c : Bool , b : Float >) ] (if false then 2 else "apple")) })
(if (unfold [ (Bool -> Nat) ] (fold [ B ] "apple")) then (pred (< c = (fix ({ d = c , a = unit })) > as (< a : A , c : Float >))) else (\ c : (Rec E . C) . (let d = (case false of < e = b > => 0 | < d = a > => b) in (fold [ Float ] 0))))
(succ ((succ (pred a)) ((({ e = "apple" , a = true }) . c) (false "apple"))))
(let d = (let e = (case 1 of < c = b > => "apple" | < b = d > => (b . e)) in (case (true . e) of < a = c > => 2 | < b = c > => 1)) in (fix (fix a)))
(succ (pred (< e = 0 > as Float)))
(pred ((pred (succ (\ b : B . c))) (pred (fix unit))))
({ d = (let a = (case unit of < e = b > => "boy" | < a = c > => false) in (fix (succ "boy"))) , a = ({ c = (fold [ (Rec B . Nat) ] c) , c = (unfold [ (< e : (< b : Float , a : Float >) , a : Unit >) ] (succ c)) }) })
(iszero ({ e = (succ (if a then c else "boy")) , b = ((unfold [ B ] a) as (Rec B . Unit)) }))
(pred (< e = (< e = 1 > as B) > as ({ a : A , a : String })))
(pred (case (a . c) of < c = d > => (pred b) | < a = c > => (false a)))
({ d = ((\ d : (String -> Unit) . (if (succ true) then (2 as Bool) else (iszero c))) . d) , b = (let e = ({ a = (let a = "apple" in c) , d = (fold [ (Bool -> Nat) ] "boy") }) in (< a = ("apple" as Bool) > as (String -> C))) })
(pred (< c = (c (pred true)) > as (String -> Nat)))
(succ (pred (fix (pred c))))
(let a = ({ b = ((\ c : Bool . false) . e) , d = (unfold [ (< b : (< d : Bool , a : String >) , a : (Rec A . B) >) ] (if "boy" then a else 0)) }) in (let c = (succ (2 . b)) in (unfold [ ({ e : B , a : Float }) ] (iszero (pred "boy")))))
({ b = ((1 c) (let a = 2 in false)) , d = (fix (unfold [ A ] "apple")) })
({ c = (fold [ ({ d : (C -> C) , e : ({ b : A , b : C }) }) ] (\ d : Nat . (unfold [ Bool ] unit))) , d = (\ d : (({ e : Float , e : Bool }) -> Unit) . (succ false)) })
(succ (iszero (unfold [ Float ] c)))
(({ a = (succ (< e = 0 > as Bool)) , e = (pred "boy") }) as (Rec A . (B -> B)))
(\ b : (Rec B . (Rec B . (String -> (C -> String)))) . (iszero (\ a : (< c : Bool , e : Unit >) . ("boy" unit))))
(unfold [ (({ b : String , c : A }) -> (Rec E . (< a : Unit , c : B >))) ] (let d = (succ (< b = 1 > as A)) in (< b = ({ c = unit , b = true }) > as Unit)))
((case (case ("boy" . d) of < d = b > => true | < e = b > => (\ c : Nat . false)) of < d = b > => (fix (let b = 2 in "boy")) | < e = e > => ({ c = 1 , c = b })) . d)
(pred (if (case true of < e = b > => "apple" | < d = a > => (\ c : Nat . 0)) then ((unit . a) (pred (let a = 2 in 0))) else (fix 2)))
(({ b = (pred (if 0 then c else b)) , e = (fix false) }) . c)
(\ b : (Rec B . (< a : Float , e : A >)) . ({ e = (if (fix a) then a else unit) , a = ((succ 0) (\ a : String . "boy")) }))
(iszero (succ (fix false)))
(if ((fold [ (< a : A , c : Unit >) ] a) (let b = (unfold [ Unit ] true) in (fix 1))) then (if ({ d = true , a = 0 }) then (succ c) else (unfold [ Bool ] 2)) else ({ e = (iszero (\ e : B . "apple")) , c = (let c = (fold [ String ] true) in (if 2 then c else unit)) }))
(fix (case (pred "boy") of < c = e > => (fold [ Bool ] c) | < a = e > => (iszero 1)))
((fold [ ({ a : ({ e : Float , e : Unit }) , d : (< c : C , b : (< a : B , a : B >) >) }) ] (let e = (< d = false > as C) in (succ "boy"))) . b)
(fold [ (Rec A . ((C -> String) -> Unit)) ] (< a = ({ d = false , b = c }) > as ({ a : Unit , e : B })))
(\ a : (< e : (Rec B . Unit) , e : (Rec A . A) >) . (((let e = 2 in unit) (case 0 of < c = e > => c | < d = c > => unit)) (\ d : (< b : B , a : (< b : Unit , c : String >) >) . (< c = a > as C))))
(< c = (\ e : (< d : (< e : A , a : B >) , b : (Rec D . B) >) . (iszero (case a of < c = d > => b | < d = c > => 2))) > as (Rec A . ({ d : String , a : Nat })))
(let c = (\ e : (({ d : C , a : Bool }) -> C) . (let b = 1 in c)) in (if (let d = (if false then "boy" else "apple") in a) then ({ c = true , c = c }) else (c as B)))
(case (iszero (pred (case 1 of < c = c > => 2 | < e = e > => unit))) of < c = b > => ({ a = (pred false) , a = ((false . a) (case true of < a = c > => 1 | < c = b > => "apple")) }) | < c = c > => (fold [ ({ b : (Nat -> (< a : B , e : Bool >)) , c : ({ c : B , c : ({ c : String , d : Nat }) }) }) ] (unfold [ Nat ] true)))
((< a = (fold [ C ] a) > as (Rec C . ({ e : Bool , e : C }))) . c)
(unfold [ ((Rec D . Unit) -> (Bool -> Nat)) ] (let e = (unit as Bool) in (if (fold [ Nat ] true) then (unfold [ Nat ] c) else (fix "boy"))))
(\ d : (< c : (< b : A , b : Nat >) , b : (Rec B . Float) >) . (case (succ (pred b)) of < a = d > => (case (unfold [ Nat ] unit) of < e = b > => (true true) | < e = e > => unit) | < e = c > => (fix (case false of < b = a > => 0 | < a = a > => true))))
(pred (\ c : (Rec E . (B -> C)) . ((succ "apple") . a)))
(fix ({ d = (fix (fold [ B ] 2)) , c = (succ "boy") }))
(case (succ (fold [ Nat ] "apple")) of < b = e > => (fix (1 . c)) | < d = e > => ((if (\ e : Bool . (0 . e)) then (succ b) else (b as Unit)) as (< d : ((Rec E . Unit) -> B) , b : (Rec D . Float) >)))
(succ (\ a : ({ c : Nat , e : A }) . (unfold [ A ] (succ 0))))
(fold [ (< a : (Rec E . ({ d : Bool , b : Float })) , e : (String -> Float) >) ] (let a = (pred (c unit)) in (pred true)))
(unfold [ ({ d : ({ d : (< b : (< c : Float , a : Nat >) , a : (Rec C . Float) >) , e : ({ b : Nat , a : Bool }) }) , e : ({ e : ({ e : Float , a : C }) , d : ({ e : (< a : Bool , a : C >) , a : Unit }) }) }) ] (case (succ (\ e : Nat . 1)) of < d = c > => (succ (pred 1)) | < e = c > => ("apple" b)))
(fix (\ d : (< c : B , a : (< c : C , b : Nat >) >) . (pred "apple")))
(unfold [ ({ a : (Rec D . ({ d : B , a : Unit })) , a : ({ b : ({ c : Nat , d : Nat }) , e : B }) }) ] ({ a = (fix false) , b = ({ e = (0 . b) , b = 0 }) }))
(fold [ ((Rec C . Bool) -> (< c : (< a : Nat , a : Nat >) , e : (Rec E . Float) >)) ] (\ b : (Rec C . String) . ({ e = c , d = (if 1 then c else a) })))
((unfold [ (< e : Unit , d : (Rec E . C) >) ] (\ c : A . 1)) . d)
((fix ({ a = c , b = (if unit then 0 else 1) })) (fold [ ({ d : ({ a : B , b : Unit }) , e : Unit }) ] (let e = false in (\ b : B . 2))))
(succ (< c = (pred (fold [ Nat ] 0)) > as (< a : Bool , d : (< e : A , c : A >) >)))
(case ({ a = (iszero ("apple" 1)) , c = (\ d : ({ a : Bool , e : Float }) . "boy") }) of < a = c > => ((succ false) . b) | < c = e > => ((case (iszero "apple") of < c = c > => true | < c = e > => (fix c)) . b))
(pred (< e = (let d = (1 0) in (unfold [ C ] false)) > as (< a : C , e : (< e : Unit , c : A >) >)))
((pred (iszero "boy")) (< a = (\ a : (< b : Nat , c : Bool >) . (< c = (iszero c) > as String)) > as (({ b : A , e : B }) -> (Unit -> B))))
(< c = (case (succ c) of < d = c > => ("boy" 0) | < b = c > => (succ true)) > as (< a : ((Float -> Float) -> ({ a : A , b : ({ c : Float , b : Unit }) })) , b : (Rec E . ({ d : Unit , e : Float })) >))
(\ e : (< c : (Rec E . (Float -> Unit)) , c : ({ a : A , b : Float }) >) . (((iszero "apple") as String) as ({ c : C , b : Float })))
(iszero (pred (let e = (\ a : Float . 0) in 2)))
(let a = (pred (false as (Bool -> C))) in (case (fix c) of < d = a > => (b . d) | < b = d > => (if ({ e = 2 , d = "apple" }) then ({ c = 0 , e = unit }) else (\ c : Unit . (< a = 0 > as Nat)))))
((\ a : (Unit -> C) . (unfold [ String ] "apple")) . a)
(iszero (\ d : (< b : Unit , d : Float >) . (fix "apple")))
(fix (fix ((1 b) 2)))
((pred (fix true)) ({ c = (if (case unit of < a = c > => 0 | < e = b > => "boy") then (iszero false) else (\ a : String . false)) , d = ("boy" . a) }))
(\ a : ({ e : ({ b : Bool , c : Bool }) , c : (< e : B , c : A >) }) . ((iszero (iszero 0)) . a))
(let c = (unfold [ (A -> C) ] (if 2 then 0 else unit)) in (let c = (if (b as Float) then (case 1 of < d = d > => true | < b = d > => 1) else ("apple" as Float)) in (if (fold [ B ] false) then (true as Float) else (case c of < d = c > => "boy" | < a = b > => 2))))
(\ e : (Rec C . (< c : (Rec E . (Float -> C)) , a : ({ e : A , a : Bool }) >)) . (pred (fold [ Float ] unit)))
(< d = (unfold [ ({ e : Nat , a : A }) ] (< b = true > as Float)) > as ((< d : A , d : Unit >) -> (Rec C . C)))
(if (iszero ((succ "apple") (a . e))) then (pred (fix (if 0 then true else (if "apple" then "boy" else false)))) else (if (\ c : A . 2) then (succ (2 as Unit)) else (unfold [ Nat ] "apple")))
(((succ (fix 0)) (succ b)) . b)
((\ a : ((Unit -> Float) -> (Rec A . Nat)) . (iszero 2)) as (Rec C . ({ c : C , c : B })))
((pred (fold [ (< a : Float , c : Nat >) ] (pred false))) as (< c : (< a : (A -> C) , b : Unit >) , c : (Rec E . (< c : (< c : Float , c : Nat >) , d : (< e : Unit , d : Bool >) >)) >))
((pred (iszero ({ d = 2 , d = true }))) as ({ a : (String -> String) , d : (Rec A . (A -> String)) }))
(let c = (\ c : ((< b : C , e : A >) -> ({ a : (< e : Unit , d : Unit >) , a : String })) . (let b = 0 in (fold [ String ] 2))) in (fix (fold [ (Unit -> B) ] ({ b = true , d = "boy" }))))
((unfold [ ((< d : Bool , d : String >) -> (< c : Unit , a : Unit >)) ] (iszero (let a = "apple" in false))) as ({ c : (Rec D . (< b : Float , d : B >)) , b : ({ b : A , c : String }) }))
(iszero (unfold [ (Rec D . Nat) ] (2 as Bool)))
(let c = (case (if (succ 1) then (< a = (1 b) > as (Float -> Bool)) else (2 0)) of < b = d > => (fix (iszero "apple")) | < b = e > => ((1 as Nat) true)) in (succ (fix (1 . a))))
(iszero (unfold [ (Rec D . (Rec A . Nat)) ] (iszero b)))
((< c = ({ b = unit , d = a }) > as (< e : (String -> Bool) , d : Nat >)) as ({ c : (< a : String , c : A >) , a : (C -> String) }))
(fold [ ((< a : (({ a : Bool , a : String }) -> (< c : String , b : String >)) , d : (Rec B . (< a : C , c : Unit >)) >) -> (< b : (< d : ({ e : Float , b : B }) , e : (Unit -> A) >) , a : (Rec B . Bool) >)) ] (pred ({ c = false , b = a })))
(< a = ((< c = false > as Unit) . a) > as ((Float -> A) -> (Rec A . A)))
(< e = (< a = (iszero false) > as (< d : ({ e : Float , a : A }) , b : (Rec C . (Nat -> A)) >)) > as (< e : (Rec E . A) , c : (< a : ({ a : B , c : Unit }) , d : (Rec B . C) >) >))
(unfold [ (< e : (Rec D . (Rec B . Float)) , c : ({ d : (< a : String , e : String >) , e : String }) >) ] (succ ({ a = "boy" , e = c })))
(let e = (succ (\ d : (Nat -> A) . (< e = a > as Unit))) in ((unfold [ B ] (succ 2)) as ({ c : Bool , e : A })))
(unfold [ (Rec B . (Rec A . Bool)) ] (succ (fix (let b = c in a))))
(((let d = (fix 0) in 1) (pred c)) (succ (unfold [ (Rec E . Bool) ] (pred "boy"))))
(iszero (((fold [ (Unit -> Nat) ] (b as Unit)) . d) (let b = (case unit of < e = e > => "boy" | < b = a > => a) in (if true then (iszero unit) else "boy"))))
(case ((let d = (unit as B) in ({ b = a , b = c })) as (< a : Bool , d : Nat >)) of < a = b > => (if (pred b) then (unfold [ ({ d : C , b : String }) ] (< e = 2 > as Bool)) else (fix (case "boy" of < e = d > => a | < d = e > => 0))) | < e = a > => (fix (unfold [ String ] 2)))
(if (if (case 1 of < e = d > => (\ a : A . "apple") | < d = d > => b) then (let c = (< e = true > as B) in (unfold [ Float ] 2)) else (fix b)) then ((succ (\ b : (B -> String) . 2)) as (Rec D . ({ e : Unit , b : Float }))) else (if (unfold [ (< e : C , a : Float >) ] (fold [ Unit ] 0)) then (if (iszero b) then (fold [ String ] 1) else (a false)) else ((2 2) (\ e : String . unit))))
(if ((case "apple" of < b = e > => c | < d = d > => "boy") (succ (pred "boy"))) then (fold [ (< e : Float , b : B >) ] (fix (true as Bool))) else (case (fix (fix false)) of < b = b > => (if (case a of < d = e > => unit | < e = a > => 0) then (fold [ Unit ] (case a of < e = a > => "boy" | < b = a > => false)) else (\ c : Unit . "boy")) | < b = d > => (pred true)))
(if ({ c = (iszero (iszero c)) , b = (case (\ e : B . c) of < a = c > => (iszero 2) | < d = d > => "boy") }) then (\ d : ({ e : String , a : (Rec A . String) }) . (let d = (succ true) in (fix false))) else (unfold [ (< a : B , d : (C -> B) >) ] (fix ({ a = b , b = 2 }))))
(iszero (succ ({ d = false , c = (if b then 1 else 0) })))
(succ ((\ a : ({ c : A , e : (Rec C . Unit) }) . (succ c)) . b))
((pred (< c = (fix "apple") > as (< b : A , d : Bool >))) as ({ d : (Float -> ({ e : Unit , d : A })) , d : (< a : String , a : ({ b : Unit , d : Float }) >) }))
(fix (\ b : (< a : ({ d : (Rec D . B) , a : Unit }) , a : (< e : C , c : B >) >) . (fix false)))
({ d = ({ c = ({ a = (\ b : A . true) , a = (< d = "apple" > as Float) }) , d = (fold [ (Bool -> Nat) ] (pred a)) }) , b = (succ (pred ((fold [ B ] true) (c . d)))) })
((succ (succ false)) as (Rec D . ((String -> Unit) -> (A -> Unit))))
(succ (fold [ (Unit -> String) ] (case b of < e = c > => 2 | < e = e > => true)))
(fold [ ((Nat -> Unit) -> (< b : (Rec E . Bool) , b : Float >)) ] (if (case (fix c) of < d = d > => (iszero c) | < a = c > => unit) then (fix 0) else ((< c = b > as A) . e)))
(if (fold [ (< c : B , e : Nat >) ] ((2 as Float) . a)) then ((let e = (unfold [ B ] 1) in unit) (({ e = true , e = 2 }) . d)) else (if (unit . e) then (\ e : Nat . 0) else ({ b = (case unit of < d = a > => 2 | < b = d > => "boy") , b = true })))
(\ d : (< c : (Rec B . (Rec B . A)) , e : (< a : ((< e : A , d : C >) -> Unit) , e : ({ d : A , c : Unit }) >) >) . (succ ({ d = (succ "apple") , c = (fold [ (Rec A . B) ] (if 2 then true else false)) })))
(< a = (< b = (succ "boy") > as (< b : ({ a : String , d : A }) , b : (String -> ({ e : A , e : Float })) >)) > as (Rec D . (Rec A . C)))
(iszero ((0 as A) as (Unit -> Nat)))
((iszero (let e = (let b = (fold [ Bool ] a) in false) in (< d = 0 > as (Rec D . Nat)))) . c)
(iszero (succ (< d = 1 > as Float)))
(succ ((b . b) . c))
(< d = ((unit c) . e) > as (Rec E . (< d : (Float -> Bool) , e : ({ d : (< a : Unit , b : C >) , b : Bool }) >)))
(succ (case (case true of < c = a > => unit | < d = b > => "boy") of < c = b > => ((c "boy") "boy") | < b = e > => (iszero a)))
(iszero (unfold [ ({ d : A , b : A }) ] (iszero (succ true))))
(succ (\ c : (< e : (Unit -> ({ b : String , a : B })) , c : (Rec D . Nat) >) . (succ (< b = false > as Unit))))
((succ ((unfold [ String ] 0) as (< a : Unit , a : A >))) as (((String -> Nat) -> (Float -> Bool)) -> (< b : (Rec B . Float) , e : (Rec E . Nat) >)))
((unfold [ (Rec E . Unit) ] (fix (fold [ C ] (fix true)))) as ({ a : (< e : (A -> B) , c : ({ d : ({ a : Float , e : A }) , a : Float }) >) , e : (Rec B . ({ d : Float , c : String })) }))
(fold [ (< a : (({ e : String , c : C }) -> String) , a : (< a : Nat , d : C >) >) ] (iszero (fold [ Unit ] unit)))
(pred (((iszero 0) as (Rec C . Nat)) (< a = 1 > as A)))
(iszero (\ c : (< a : Float , e : A >) . (false b)))
(if ((fix ("boy" 2)) as ({ b : (Rec C . Nat) , e : B })) then ((let b = (< c = true > as Float) in 0) . b) else ({ d = (pred 1) , a = (false . e) }))
((\ c : (Rec D . Float) . (succ a)) ((a as Nat) (fold [ (Unit -> Bool) ] "apple")))
(pred (case (let d = "apple" in 1) of < d = b > => (pred 0) | < a = c > => (0 "apple")))
(pred (fix ((\ e : Bool . false) . e)))
(iszero (unfold [ (Rec B . (< a : Unit , d : Float >)) ] (fix (case a of < a = a > => false | < e = a > => 0))))
(succ (< b = ({ e = (< c = (let d = unit in b) > as A) , a = (b . e) }) > as (< d : ({ a : Float , a : Bool }) , b : (Float -> String) >)))
(< e = (case ((< e = false > as C) "boy") of < b = d > => (< e = (fix c) > as C) | < c = c > => (((\ b : String . 1) . c) (pred (fix 1)))) > as (Rec D . ({ b : (B -> Float) , a : Float })))
(if (succ (unfold [ String ] (case 2 of < a = e > => 1 | < e = a > => false))) then ((unfold [ Nat ] (2 . e)) . c) else (unfold [ (< c : (< e : Nat , a : Unit >) , c : A >) ] (fold [ (Rec B . Nat) ] true)))
(pred (let d = (fix 1) in (fix a)))
((pred (fold [ Float ] ({ a = unit , d = false }))) ((pred true) . c))
(fold [ (Rec E . (< d : (String -> Float) , b : ({ a : A , d : (Rec C . A) }) >)) ] (fix (unit (fix c))))
(iszero (fold [ ({ e : C , c : (< b : Float , d : B >) }) ] (succ (2 . b))))
((succ (< b = false > as Nat)) (< e = ((succ 1) . b) > as (< b : Unit , b : C >)))
(case (if ((if "apple" then b else c) as (Bool -> Float)) then (< e = (if 2 then "boy" else true) > as (C -> Nat)) else (pred (unfold [ Float ] 2))) of < b = d > => ({ c = (if a then unit else (pred 2)) , e = (fold [ ({ b : A , e : A }) ] unit) }) | < b = e > => (if ({ a = (true . d) , c = (succ 1) }) then (case (false . a) of < c = d > => (0 b) | < b = b > => "boy") else (\ a : (Rec C . Nat) . (succ 2))))
(fold [ (Rec B . (Rec B . B)) ] ((a . c) (fold [ A ] c)))
(fold [ (< e : (Rec A . (Rec B . Float)) , b : (< a : (< d : B , a : Unit >) , a : (Rec A . Float) >) >) ] (< a = (succ "apple") > as (< e : (Unit -> A) , e : (Rec E . Unit) >)))
(pred (let e = ((fix (pred false)) ("boy" . c)) in ((< a = (pred a) > as String) . a)))
(let c = (fix (if false then (succ unit) else (0 . d))) in (let e = (iszero (iszero true)) in (succ b)))
(iszero (\ b : (Float -> B) . ({ a = 1 , a = unit })))
(case (let e = (fix (if 1 then 2 else 2)) in (if (succ 0) then (unit . b) else (if b then 0 else true))) of < a = b > => (< e = ({ e = ({ a = (unfold [ Float ] b) , c = (pred 1) }) , b = (b . d) }) > as (Rec C . Nat)) | < a = d > => ((fold [ (Unit -> A) ] 0) (fold [ C ] ("boy" as Float))))
(succ ({ e = (\ d : A . 2) , d = (false 0) }))
(< e = (fix (\ e : ({ c : (< c : A , e : C >) , e : Unit }) . (\ c : A . "boy"))) > as ({ c : (Rec C . (C -> Bool)) , b : (C -> ({ b : Float , b : B })) }))
(((case ({ a = (pred 2) , a = ({ b = 1 , b = unit }) }) of < b = c > => (pred false) | < e = d > => (let a = false in true)) . e) as ({ b : (< b : B , b : String >) , d : (< e : (({ a : Float , a : Nat }) -> (Float -> String)) , c : ({ a : (Rec A . Bool) , e : Nat }) >) }))
(fold [ (< e : ((Rec A . (Rec D . A)) -> ({ b : Float , a : A })) , b : ({ b : (< d : Nat , e : String >) , b : (< d : B , a : B >) }) >) ] (let b = (let d = ("boy" as Bool) in (iszero 0)) in (succ (case c of < c = e > => "apple" | < c = c > => "apple"))))
(if (case (succ 0) of < e = d > => ((let e = "apple" in 2) (if b then c else "apple")) | < b = c > => (succ (iszero (fix false)))) then (fix ((\ b : B . false) as Bool)) else (succ (let e = (case 1 of < e = d > => false | < e = a > => unit) in (< e = true > as Float))))
((unfold [ ({ d : ({ c : (< e : Nat , a : A >) , d : (Rec A . A) }) , c : (< b : A , b : String >) }) ] (< c = (pred b) > as (Rec E . (< e : Nat , c : Bool >)))) ({ e = (pred (iszero c)) , e = ((case (if 1 then unit else 2) of < b = b > => "apple" | < c = d > => (fold [ B ] true)) (1 . a)) }))
(fix (pred (fold [ C ] true)))
(\ e : (Rec C . (Float -> (Rec B . Nat))) . (unfold [ (Rec B . Nat) ] (pred ({ c = a , e = a }))))
(fold [ ((< b : (< a : Float , a : Nat >) , b : (< c : Float , a : C >) >) -> (Rec A . (String -> A))) ] (pred (pred c)))
(pred ((let c = b in 0) as (Rec D . B)))
(iszero (fold [ (String -> Float) ] (a . a)))
(succ (< e = (case false of < d = c > => "boy" | < c = e > => (< d = 2 > as String)) > as (Rec C . B)))
(fix ((c as (Unit -> Float)) (iszero (if "apple" then ({ b = b , c = "boy" }) else 0))))
(unfold [ (Rec C . (Rec B . B)) ] (fold [ (< e : (A -> B) , a : ({ e : Nat , d : A }) >) ] (< b = (case (fold [ C ] b) of < d = d > => c | < a = c > => (fix unit)) > as (Rec D . B))))
(succ ((case "boy" of < b = c > => "apple" | < e = a > => "boy") . d))
(if (let c = (let a = unit in "apple") in ((fix 1) as ((C -> Unit) -> Nat))) then (let a = (fold [ (Rec A . Bool) ] (< a = 2 > as Unit)) in (if (< a = unit > as (Rec E . Nat)) then (fix true) else (pred a))) else (case ("boy" 0) of < c = d > => ("apple" c) | < a = e > => (fold [ Bool ] "apple")))
(case (fix (< c = 1 > as Float)) of < d = d > => (let c = (pred 0) in (true as (Rec C . Float))) | < a = b > => (case ((< a = a > as Nat) (fold [ C ] "boy")) of < a = c > => ((\ e : (Rec C . Nat) . false) (\ b : (< c : String , d : A >) . (fix a))) | < a = a > => (case (fix (unfold [ String ] "boy")) of < c = c > => (0 "boy") | < e = a > => ({ b = (< e = a > as B) , e = (succ a) }))))
(< b = (((case a of < b = e > => b | < b = c > => "apple") (fold [ String ] "apple")) (let a = (\ e : B . 0) in (\ e : Float . "apple"))) > as ((< d : ({ b : Bool , a : B }) , d : (< e : Float , c : Unit >) >) -> (< d : ({ c : B , b : Bool }) , e : (Rec A . A) >)))
(if (if (< c = true > as Float) then (let c = 0 in c) else ({ d = unit , b = (unit . a) })) then (< d = (pred (unfold [ (< a : Nat , a : Bool >) ] (let e = false in 2))) > as (Rec D . ({ b : A , c : String }))) else (if (unfold [ C ] false) then (if "apple" then a else true) else (iszero (fold [ C ] 0))))
(\ d : ((< e : C , a : B >) -> (Nat -> Bool)) . (succ (< b = unit > as String)))
((pred (b c)) . c)
(fix ({ d = (case (if false then 0 else 2) of < a = c > => (\ a : C . (iszero unit)) | < c = b > => ({ d = 0 , d = false })) , e = (fold [ ({ b : Nat , d : Float }) ] (pred "boy")) }))
(< b = ((succ (succ unit)) . d) > as ((< c : B , e : Float >) -> (Rec E . String)))
(iszero (iszero ({ c = (pred unit) , c = (let d = 0 in a) })))
(pred (unfold [ (Rec E . Nat) ] (unfold [ (A -> A) ] (fold [ A ] false))))
(iszero (< e = (\ b : (Rec D . B) . (if 1 then (\ c : String . unit) else (case 2 of < b = d > => a | < e = e > => 2))) > as (Rec E . A)))
((fix (iszero (succ (pred "boy")))) (succ (iszero (< a = 0 > as C))))
(fold [ (Rec A . (B -> (String -> B))) ] (unfold [ ({ d : Bool , c : C }) ] (unfold [ B ] 0)))
(fix (unfold [ (C -> (Rec C . String)) ] (case (let a = false in "apple") of < a = a > => true | < e = b > => ("apple" false))))
({ d = (fold [ ({ a : Unit , b : Bool }) ] (unfold [ (B -> A) ] a)) , e = (\ c : (< d : Bool , d : Nat >) . (case b of < c = c > => false | < d = a > => unit)) })
(iszero ((fix b) . e))
(case ({ a = (pred (({ c = a , d = 0 }) . a)) , d = (let c = ("boy" as (Float -> Nat)) in (< c = 1 > as Unit)) }) of < a = c > => (if (fix (< b = 2 > as Float)) then ((pred (1 a)) . c) else (\ b : (< b : B , a : B >) . c)) | < a = c > => (("apple" as Nat) as (Rec A . B)))
(let a = ({ c = (let d = (if c then unit else "boy") in ((true as String) as C)) , b = (case ((iszero 1) . c) of < b = d > => (2 as B) | < d = d > => (fix c)) }) in (case (unfold [ (< b : String , b : C >) ] (succ "apple")) of < c = d > => (if a then 1 else false) | < b = b > => (iszero c)))
((< a = (\ a : (< d : C , d : B >) . (unfold [ Bool ] false)) > as (< e : (B -> B) , e : (Nat -> Float) >)) . b)
(fix (\ b : ({ e : (Bool -> Bool) , e : (< b : (Float -> A) , c : A >) }) . (({ c = 0 , d = false }) . c)))
(fix ((case (let d = false in "apple") of < d = a > => (pred c) | < e = b > => (< d = a > as Nat)) as ({ a : (A -> String) , e : (C -> ({ d : A , e : Float })) })))
((fix (\ d : Bool . false)) as ({ b : (< d : (Rec A . A) , c : ((Unit -> A) -> (< a : Unit , c : Unit >)) >) , c : (< d : (B -> String) , e : (< d : Float , c : Bool >) >) }))
(\ e : ((< d : Bool , a : Nat >) -> (Unit -> Float)) . (pred (pred (\ c : A . unit))))
(let b = (iszero ((true as String) as Float)) in (succ (\ b : (< a : Float , e : A >) . (if b then a else "boy"))))
(let a = (unfold [ ({ d : (< c : Unit , c : Float >) , e : ({ c : (< d : String , d : String >) , e : Float }) }) ] (fold [ (Rec D . Nat) ] ("apple" . e))) in (fix ({ d = "apple" , a = 0 })))
(< e = ((< c = false > as (Rec E . B)) as (< c : A , c : (A -> Unit) >)) > as (({ e : C , d : (< c : B , e : Nat >) }) -> (< c : String , d : Unit >)))
(pred (if ({ a = (fix "boy") , c = (succ c) }) then (2 true) else (unfold [ Nat ] (let a = 0 in b))))
(\ d : (Rec D . (A -> (< d : Unit , c : Unit >))) . (if (unfold [ (< c : Nat , a : String >) ] (c as A)) then (a . e) else (fold [ Unit ] 1)))
((< a = (a as A) > as (< e : Unit , c : A >)) . c)
((unfold [ ((Bool -> Unit) -> (Rec E . Bool)) ] (pred (pred (unfold [ C ] "apple")))) . c)
({ e = (unfold [ ({ a : Float , c : (Rec A . Float) }) ] (case (unfold [ B ] true) of < e = c > => (let b = a in false) | < a = d > => "apple")) , d = (fix (< e = "boy" > as (Unit -> C))) })
(let c = (fix ((case "boy" of < d = d > => 1 | < c = c > => 2) as (Nat -> A))) in (pred (1 (if "apple" then "boy" else 2))))
(\ c : (< d : ({ a : String , b : Bool }) , b : ({ b : ({ e : C , a : Float }) , b : (< b : Nat , b : Bool >) }) >) . (if ({ d = (unit . b) , e = "boy" }) then ({ a = (< d = false > as Nat) , b = "apple" }) else (pred (succ (pred true)))))
(fix (< e = (if (if a then "apple" else b) then (fold [ Nat ] "apple") else false) > as ({ d : C , a : A })))
((unfold [ (< b : (< d : Bool , e : B >) , e : (< c : String , e : Bool >) >) ] (iszero "apple")) as (Rec C . (< a : String , a : B >)))
(if (\ c : (Rec D . B) . (fold [ String ] (< d = 1 > as Unit))) then ((iszero (let d = unit in true)) (let b = (\ a : Bool . unit) in a)) else ((let d = c in 1) . e))
(((succ (\ c : String . 0)) as ({ a : (Rec C . B) , c : ({ b : Bool , b : Float }) })) (fix (fix (iszero (if 1 then unit else unit)))))
(if (< e = (a as Float) > as (Rec D . Float)) then (< b = (iszero (fix c)) > as (A -> ({ e : A , a : Float }))) else ((fold [ String ] true) (unfold [ C ] false)))
(iszero (pred (pred "boy")))
((iszero (< e = ("apple" "apple") > as (Rec C . Nat))) as (({ b : Float , c : (< b : B , b : Float >) }) -> ((< d : String , e : Bool >) -> (Rec C . A))))
(pred (unfold [ (Rec D . Nat) ] (iszero a)))
(let b = (((pred c) (pred "apple")) . a) in ((fix "apple") (if "boy" then c else "boy")))
(if (iszero ({ a = false , e = 2 })) then (< c = (fix (b . d)) > as (Rec E . Unit)) else (unfold [ ({ e : Float , e : Bool }) ] ((fix "boy") . d)))
(fold [ (Rec B . (< b : Nat , a : String >)) ] ({ c = (case (case 1 of < b = a > => unit | < e = a > => 2) of < a = d > => false | < c = d > => (\ a : A . unit)) , e = ((unfold [ Unit ] 1) as (Rec E . C)) }))
(\ e : ((< a : C , d : A >) -> (< d : Float , d : C >)) . (unfold [ ({ d : ({ e : Float , b : Nat }) , e : B }) ] (pred unit)))
({ a = (\ d : (Rec E . Float) . (succ b)) , e = (let b = (let c = "boy" in "boy") in (let c = (\ a : Bool . c) in (unfold [ C ] c))) })
(case (case (succ "boy") of < a = b > => (unfold [ (Rec D . String) ] ({ e = unit , c = "apple" })) | < b = d > => (fix (unfold [ Unit ] unit))) of < a = c > => (case (iszero (fold [ Bool ] 2)) of < d = d > => (unfold [ (Bool -> A) ] (pred 0)) | < e = b > => (case (false . d) of < c = e > => (succ (iszero unit)) | < a = a > => (succ "apple"))) | < d = b > => ((unfold [ B ] c) (pred true)))
(fix (fix ((fix 0) as B)))
((\ b : ({ e : Unit , c : C }) . (case c of < e = e > => "boy" | < d = d > => b)) (if (< d = unit > as Float) then (pred unit) else ({ d = "apple" , e = false })))
(unfold [ ({ c : ((< e : C , c : A >) -> (< d : B , c : Unit >)) , b : (Rec B . Nat) }) ] (succ (pred (fold [ Unit ] (succ true)))))
(case ((succ (fix ({ d = a , a = true }))) as (Rec C . Unit)) of < d = d > => (pred (fold [ Bool ] 2)) | < c = c > => (if (< c = (< b = "apple" > as Float) > as (Rec A . String)) then (b . b) else (if 2 then true else 1)))
({ e = (< b = (false as Nat) > as (Rec A . Bool)) , d = (case (\ c : ({ d : (String -> Unit) , e : ({ a : Float , a : C }) }) . (c 0)) of < e = e > => (iszero (fold [ C ] a)) | < e = c > => ({ e = 0 , d = ({ a = true , b = 1 }) })) })
(unfold [ ((< e : Unit , e : C >) -> (Nat -> A)) ] (iszero (case a of < e = b > => c | < b = e > => false)))
(iszero (if (let e = (iszero "boy") in ("apple" . a)) then (unfold [ ({ d : (C -> C) , d : ({ d : Bool , e : Float }) }) ] (case a of < a = c > => "apple" | < e = a > => ({ c = b , e = unit }))) else (< a = (let b = false in (succ true)) > as ({ e : (< b : Unit , c : Bool >) , d : ({ e : C , a : String }) }))))
((fix (< e = (succ a) > as ({ c : A , c : Float }))) . e)
(\ e : ((< c : Nat , b : (A -> String) >) -> ({ a : Nat , b : Bool })) . (iszero (< a = "boy" > as Unit)))
(< c = (< c = (pred 2) > as ({ d : Unit , b : (< d : Bool , d : A >) })) > as ({ e : (< b : (Rec C . String) , c : A >) , d : (< e : ({ c : B , b : Nat }) , e : (< c : A , b : (Float -> String) >) >) }))
(let b = (fix (let d = false in (pred "boy"))) in (< e = (\ a : Unit . (fix unit)) > as (Rec B . C)))
(let e = ((let c = 0 in c) . c) in (iszero (fix (succ b))))
(succ (fix (case 2 of < b = d > => false | < d = d > => (pred 0))))
({ a = (< a = (succ c) > as ((B -> Unit) -> ({ b : B , a : Bool }))) , c = (succ (1 . a)) })
(pred ((let b = a in 0) (fix (b as Float))))
(\ a : ((< a : ((< d : Bool , a : Bool >) -> (< b : Unit , c : Float >)) , d : (Rec C . B) >) -> ({ e : (Rec D . Unit) , b : String })) . ((case (succ unit) of < d = e > => (pred false) | < a = d > => (pred unit)) (pred false)))
(pred (if (iszero (1 as String)) then (< c = (< d = 0 > as A) > as (Rec D . A)) else ((if 1 then 0 else a) as C)))
(fix ((if (succ unit) then (succ 2) else (unit 0)) . e))
({ e = (((< c = false > as String) as ({ e : ({ a : Bool , a : String }) , d : C })) ({ a = (a . e) , d = ({ c = false , a = unit }) })) , d = (unfold [ (Rec D . Bool) ] (\ c : C . (if 0 then a else 1))) })
(case ({ d = ({ c = (false . d) , d = false }) , a = ({ e = a , a = false }) }) of < a = b > => (succ (case 0 of < a = e > => b | < e = d > => false)) | < a = b > => (fix (let b = ({ d = (false as Nat) , e = b }) in (pred c))))
((case (pred false) of < b = c > => (unfold [ Unit ] "apple") | < c = b > => (fold [ ({ b : C , d : String }) ] false)) . a)
(< e = (pred (if ("apple" as Nat) then (unit as Nat) else (true 2))) > as ({ b : ({ e : Float , b : Bool }) , e : (Rec B . Unit) }))
(if (iszero ((case b of < b = c > => true | < b = c > => 0) as (Rec B . Nat))) then (let e = (< c = (false . b) > as ({ c : Float , d : A })) in (\ e : String . (case a of < b = d > => "apple" | < c = c > => c))) else (fix (pred 1)))
(let a = (unfold [ (Rec A . (< e : Bool , d : A >)) ] (case (case 0 of < d = b > => unit | < a = c > => "apple") of < d = e > => (pred 1) | < a = d > => (succ 1))) in (pred (let d = "apple" in 2)))
(case (fix (fix (let b = "apple" in a))) of < d = d > => ({ e = ((let e = unit in false) (case (succ "apple") of < e = e > => 1 | < a = a > => (\ a : Float . 1))) , b = (iszero (fix unit)) }) | < c = b > => ((case (succ false) of < a = d > => "boy" | < e = c > => ({ a = 2 , a = a })) as (String -> B)))
(unfold [ ({ e : (< a : Unit , b : A >) , e : (< d : (< e : Float , a : B >) , b : B >) }) ] ({ a = (if unit then c else a) , c = (< d = false > as C) }))
((iszero (if ({ a = true , e = 1 }) then 2 else (\ e : Unit . 0))) ((if 2 then 1 else "apple") as (Bool -> String)))
(< b = ((unit as Nat) . c) > as ({ d : (Rec C . (< c : String , d : Nat >)) , c : (< a : Float , a : A >) }))
(< b = (case (\ a : (Rec C . Bool) . (fix unit)) of < c = c > => (fold [ B ] "boy") | < a = c > => (1 (unfold [ Bool ] 0))) > as (Rec A . (Rec A . ({ c : B , c : Unit }))))
((fold [ ({ e : (Rec B . C) , b : (< c : Nat , b : A >) }) ] (fix (let a = c in 2))) as (({ a : (< e : B , c : String >) , a : String }) -> ((Rec C . Float) -> Float)))
(if (pred (({ c = b , d = "boy" }) as A)) then (\ b : (< d : ({ a : Bool , b : B }) , d : (Rec C . B) >) . (unfold [ ({ e : A , b : Bool }) ] (succ a))) else (fix (if (let c = false in true) then (1 c) else "boy")))
({ b = (if (< a = 1 > as String) then (c as String) else (succ 0)) , e = (if (fold [ ({ e : Float , b : (< a : Nat , d : C >) }) ] (fold [ B ] a)) then (< d = ({ c = a , b = "apple" }) > as C) else ((a . d) (\ d : String . 1))) })
((fix ((< b = "boy" > as B) c)) . b)
((case (case false of < a = a > => (false true) | < a = d > => b) of < d = d > => (< d = 2 > as String) | < a = e > => (unit as C)) as ((< b : Nat , a : B >) -> (Rec C . A)))
(pred (succ (fold [ Bool ] false)))
(< b = (let c = (unfold [ (Rec D . C) ] (pred "boy")) in (((2 b) as (Rec D . A)) (case 0 of < e = c > => "boy" | < d = e > => false))) > as (({ a : B , b : A }) -> (Rec D . (< a : A , b : C >))))
((case (case 1 of < a = a > => (succ false) | < a = e > => (0 as B)) of < a = a > => (fold [ A ] c) | < a = b > => ({ b = (succ c) , c = 2 })) . c)
(if (fix (let b = unit in b)) then ((succ (\ a : Float . 1)) as (< b : Unit , d : ({ e : Bool , d : String }) >)) else (\ c : ({ a : (Rec D . Unit) , b : C }) . (case (let a = 0 in b) of < c = b > => 2 | < a = e > => (let b = false in 0))))
(if (pred ({ c = b , a = (succ "apple") })) then (\ b : ((A -> String) -> (< e : A , c : (Rec C . Bool) >)) . (fold [ (< e : Float , e : C >) ] (if false then "apple" else unit))) else (if (if a then unit else true) then (succ (fix 0)) else (fix a)))
(fold [ (Rec A . (< d : Nat , e : B >)) ] (unfold [ (A -> B) ] (iszero a)))
(iszero (fix ({ b = false , d = 0 })))
({ e = (fold [ ({ d : Float , b : Unit }) ] (\ d : (Rec C . B) . 1)) , c = ((if b then (0 . e) else ("apple" . b)) as (Rec E . Bool)) })
(iszero (< d = (case (1 as C) of < b = d > => (0 . a) | < b = c > => (case (case a of < c = b > => false | < c = e > => b) of < c = b > => ({ a = a , e = 0 }) | < e = c > => 2)) > as (({ e : String , b : String }) -> (Bool -> String))))
((iszero (pred "boy")) ((unfold [ (Rec D . Unit) ] (\ a : (< b : Float , c : Unit >) . (a a))) . a))
((< e = (let c = (if b then c else 0) in (a (false . e))) > as (Rec A . Nat)) (case (fix ({ a = unit , d = c })) of < b = c > => (iszero (if c then 0 else 2)) | < e = a > => ({ e = (\ b : String . a) , e = 2 })))
(pred (iszero (a (succ 0))))
(let e = (succ (succ (\ c : Nat . 0))) in (iszero ((fix unit) . e)))
(pred (if (iszero a) then (pred false) else ({ a = (c "boy") , d = (0 0) })))
(case ({ a = (iszero a) , e = (let e = 0 in "apple") }) of < e = b > => ({ c = (fix a) , e = ((let b = false in true) . a) }) | < b = a > => ((unfold [ Bool ] unit) (unfold [ Unit ] true)))
(let b = (unfold [ (({ a : C , d : C }) -> (C -> Float)) ] ({ c = 2 , b = 2 })) in ({ a = ({ b = (pred c) , c = (fold [ Float ] true) }) , e = ({ e = ({ a = c , a = 2 }) , a = (c . b) }) }))
(\ e : (< a : (Rec E . C) , c : (< d : Nat , d : Nat >) >) . (pred (fix ({ b = unit , b = 1 }))))
(if ({ e = (case "boy" of < e = a > => "apple" | < b = d > => "boy") , b = (2 . d) }) then (iszero (fold [ Float ] true)) else (< c = ((< a = (\ d : A . c) > as B) as ({ e : Float , c : String })) > as (< e : Nat , c : Nat >)))
(if (succ (fix 0)) then (\ a : ({ b : (C -> Unit) , b : ({ c : String , b : C }) }) . ((unfold [ C ] 2) . c)) else (("boy" as C) . a))
((pred ({ c = (if b then unit else unit) , b = false })) (pred (fix "boy")))
(pred ((b as C) (case c of < a = c > => (fix 2) | < a = c > => (fix "apple"))))
({ a = ((let e = (if (pred 0) then (if 0 then c else b) else a) in (fold [ ({ b : Float , c : Bool }) ] (fix 1))) . d) , c = ((false . d) (succ "apple")) })
(iszero (fold [ (Rec B . Unit) ] (let d = (iszero c) in (iszero 2))))
((unfold [ (< c : C , d : Nat >) ] ((fold [ C ] 0) true)) as ((Rec E . String) -> (Rec E . (Rec E . C))))
(case (\ b : (Rec A . ({ d : Unit , a : A })) . ({ e = (iszero (fix 1)) , d = (case (unfold [ A ] 2) of < a = a > => unit | < e = e > => ({ a = b , c = a })) })) of < d = d > => (\ a : ((B -> String) -> Float) . (< a = c > as ({ e : B , c : String }))) | < b = a > => (\ c : (A -> Unit) . (iszero (\ d : String . "apple"))))
(pred (< a = ((succ (\ a : Nat . "apple")) (let d = 0 in (case "boy" of < b = c > => unit | < e = a > => "apple"))) > as (< b : Nat , b : Unit >)))
(fold [ (((Rec C . Float) -> Float) -> (Rec B . C)) ] (iszero (fold [ (Rec B . Nat) ] (true . c))))
((iszero (case (\ c : String . a) of < e = c > => 2 | < c = e > => ({ d = b , e = "apple" }))) ((iszero (\ c : Bool . 1)) . a))
(fold [ (< c : ({ c : String , a : String }) , c : (Rec E . C) >) ] (pred (unfold [ Bool ] 1)))
(iszero (unfold [ (Nat -> Float) ] (fix "boy")))
(unfold [ ({ b : ({ c : (Unit -> String) , e : A }) , d : ((Rec E . (A -> B)) -> (Rec D . C)) }) ] (pred (\ e : B . ({ a = b , e = unit }))))
(iszero (fix (fix (succ false))))
(\ b : (({ a : A , a : (Rec B . Float) }) -> (Rec B . A)) . (case (iszero (< b = "boy" > as String)) of < a = c > => (case unit of < a = b > => true | < d = c > => (iszero true)) | < a = a > => (if (if true then "boy" else ({ c = false , e = false })) then (succ a) else (< e = "apple" > as B))))
(succ (let c = (succ (unfold [ B ] c)) in (if (case false of < a = a > => 1 | < a = c > => 2) then (iszero "boy") else 1)))
(< d = (({ e = c , c = false }) (if 2 then c else a)) > as (< b : ((A -> C) -> (String -> B)) , e : (Unit -> (Rec E . Nat)) >))
(case (succ (fold [ ({ b : B , d : A }) ] (b as Nat))) of < b = b > => (if (true as A) then (succ (case 0 of < d = a > => "apple" | < e = d > => b)) else (false false)) | < a = b > => (unfold [ ({ b : (Rec C . Float) , b : (< e : Nat , c : Nat >) }) ] (\ a : (C -> Bool) . (case a of < b = d > => "boy" | < b = c > => 0))))
((fix (case (case true of < d = d > => "apple" | < a = d > => c) of < b = b > => (\ e : Bool . unit) | < a = b > => true)) . d)
(case (\ a : ({ d : (Nat -> String) , b : (Nat -> (< e : B , c : Float >)) }) . (case (a as B) of < d = d > => (succ unit) | < d = a > => ("apple" as B))) of < a = e > => (fix ((iszero c) (if false then 2 else "apple"))) | < b = e > => (succ (< d = (unit . d) > as Nat)))
(succ (let e = (1 b) in ((fix "boy") (iszero c))))
((let a = (iszero 1) in (c (iszero 2))) . c)
(< e = (< e = ((case 1 of < b = b > => "boy" | < d = c > => "boy") (succ b)) > as (Rec E . Bool)) > as (({ c : (< b : Float , c : A >) , d : (Rec B . Bool) }) -> ({ d : ((< c : A , e : B >) -> (< c : C , d : Unit >)) , e : ({ e : A , d : Float }) })))
(unfold [ (< b : ({ e : (C -> Bool) , e : ({ e : Nat , b : String }) }) , e : ({ c : String , b : Unit }) >) ] (pred (< a = 0 > as C)))
(case (< e = ((fold [ ({ c : A , e : String }) ] true) (succ 2)) > as (< b : ({ c : Unit , d : B }) , b : (< b : Unit , d : Float >) >)) of < c = a > => (pred (let d = "apple" in (iszero unit))) | < d = e > => (succ (fix (unfold [ Float ] 0))))
(if (let a = ((let e = "boy" in "boy") ({ c = unit , e = c })) in (let a = (true 1) in (fold [ (Nat -> Nat) ] b))) then (fix (let d = (let d = c in unit) in (true 1))) else ((< b = (\ c : Bool . unit) > as B) as ((< c : Bool , a : String >) -> ({ d : (< d : B , d : Unit >) , b : Float }))))
(if (((succ "apple") (iszero false)) (pred ((c . a) . c))) then (< a = (\ d : C . true) > as (Rec D . C)) else (case (unfold [ String ] (fix c)) of < e = b > => (if (case a of < e = d > => c | < c = d > => 1) then false else (unit "apple")) | < c = e > => ({ b = unit , b = (case b of < d = e > => "boy" | < c = e > => "apple") })))
(fold [ (< a : (< d : (< e : A , c : Float >) , c : Nat >) , d : (B -> B) >) ] (\ c : (({ d : A , d : C }) -> (String -> A)) . ((iszero (pred true)) . a)))
(fold [ (Rec E . ({ b : A , a : Unit })) ] (unfold [ (< d : Unit , a : String >) ] (unfold [ Nat ] a)))
(succ (< e = (false as ({ e : Unit , d : B })) > as (Rec A . Float)))
(case (\ c : (Float -> Bool) . (\ e : (Rec C . C) . "boy")) of < d = c > => (\ e : ({ a : C , e : (Bool -> Nat) }) . (pred 1)) | < e = e > => (succ (pred ((fix 2) (pred a)))))
(< e = (pred (pred (\ b : (String -> Float) . (fix c)))) > as ({ e : (< d : (Rec E . A) , e : ({ d : A , d : Unit }) >) , a : ((A -> B) -> ({ b : B , e : String })) }))
((fix (pred (\ a : Float . "boy"))) as (Rec A . (Rec E . (A -> Nat))))
((fold [ (Rec E . (< d : String , e : C >)) ] (iszero a)) . e)
(case (iszero (0 as (< e : Nat , e : C >))) of < a = d > => (pred (pred "apple")) | < a = a > => (fold [ (({ b : Bool , d : String }) -> A) ] (case (if "apple" then c else 2) of < a = a > => ({ c = a , c = unit }) | < c = c > => (iszero ("apple" . a)))))
(pred (succ (if (\ e : Unit . unit) then (unfold [ Float ] b) else ((iszero 1) . b))))
(case (pred (\ d : (Rec E . C) . (iszero (succ 1)))) of < c = c > => (case (< a = a > as B) of < c = b > => ({ b = c , c = a }) | < b = d > => (case (succ unit) of < a = a > => (unfold [ B ] 1) | < d = b > => (< e = false > as A))) | < a = c > => (unfold [ ((Rec B . Bool) -> (Rec C . Bool)) ] ({ b = (pred (unfold [ B ] 2)) , d = (\ d : (< a : Float , b : Nat >) . false) })))
(fold [ ({ b : ({ d : Bool , d : Nat }) , d : (Rec E . ({ b : C , d : Unit })) }) ] (pred (case 2 of < c = e > => (succ 2) | < c = c > => (case "apple" of < d = e > => b | < a = a > => true))))
(if (unfold [ (< a : Unit , b : A >) ] (\ c : Float . 0)) then (unfold [ (< c : (Rec A . A) , d : Bool >) ] (if (iszero unit) then (case "boy" of < d = a > => (iszero a) | < b = e > => true) else (\ d : ({ b : B , c : B }) . 2))) else ((1 . d) (case (< c = 1 > as Unit) of < e = c > => (b 1) | < a = c > => ({ c = a , c = a }))))
((case (unfold [ (< e : C , c : Unit >) ] (fold [ Float ] "boy")) of < b = e > => (if (\ b : Nat . false) then (case "boy" of < d = c > => c | < b = b > => c) else (fold [ C ] a)) | < b = a > => (0 as (String -> Bool))) as (Rec B . ({ d : Nat , d : String })))
({ a = ((a as (Rec A . Nat)) as (String -> (Rec D . String))) , e = (({ c = (case 2 of < a = c > => 2 | < b = e > => 1) , e = (succ 1) }) as ((< c : B , b : C >) -> Float)) })
(pred (case (fold [ Unit ] 2) of < d = e > => (fold [ Nat ] 2) | < c = d > => ("apple" as Nat)))
(let d = (if (< c = (\ a : Bool . c) > as (Float -> C)) then (fold [ String ] (let c = false in b)) else (unfold [ String ] a)) in (succ (pred 0)))
(iszero (pred (let e = ("apple" . a) in (case (fold [ B ] 0) of < c = a > => 2 | < b = e > => (b as Float)))))
(let e = (iszero (unfold [ String ] (\ c : B . b))) in ((< a = (fold [ Bool ] "apple") > as String) as ((< a : B , c : A >) -> (Rec A . (Rec E . Float)))))
((fold [ (Rec A . (< c : String , e : C >)) ] (fix (\ c : Float . 2))) (if ((fix false) as Bool) then (c (fold [ Nat ] unit)) else (c "apple")))
(< b = (< b = (pred 2) > as (< e : A , c : Nat >)) > as ({ d : (< d : String , b : C >) , b : ({ e : C , e : String }) }))
(unfold [ ({ a : (Rec D . Float) , d : (< e : Unit , e : C >) }) ] (case (case c of < d = d > => (fix 1) | < c = d > => (iszero c)) of < b = b > => (succ (2 as A)) | < e = a > => (({ e = a , c = "apple" }) as (({ b : B , b : Nat }) -> (< a : Bool , d : C >)))))
(fold [ ({ d : (< b : (Rec D . B) , b : (< c : A , b : Bool >) >) , a : (< e : B , e : ({ e : C , e : B }) >) }) ] (fold [ ({ b : (< e : Nat , e : Float >) , b : Nat }) ] ((if b then 2 else "boy") 1)))
(fix (unfold [ ({ d : (< b : Nat , e : Bool >) , c : C }) ] (let e = false in a)))
(unfold [ ({ d : ({ d : (< c : ({ c : String , d : Float }) , e : Unit >) , c : ({ e : (< e : Bool , d : Float >) , e : (Float -> A) }) }) , c : (({ d : C , b : Nat }) -> (< d : B , a : Float >)) }) ] (pred (if (\ e : C . "apple") then 2 else (unit . e))))
(fix (iszero (fix (fold [ B ] false))))
(< c = (unfold [ (Bool -> C) ] (\ c : (< d : Unit , d : Bool >) . true)) > as (Rec B . ({ d : Bool , c : B })))
(let d = (let e = (fold [ (String -> Bool) ] ({ b = unit , a = c })) in (succ b)) in ((let d = a in "apple") (succ false)))
(case (case (pred false) of < e = d > => (succ unit) | < b = a > => (fold [ (A -> C) ] (case unit of < e = e > => unit | < b = e > => "apple"))) of < e = d > => ((fix (let c = 1 in c)) . c) | < c = e > => (succ (case (\ d : (Rec A . Float) . unit) of < c = d > => (\ a : String . 0) | < b = e > => (if 0 then c else 1))))
(< d = ((let b = (succ unit) in (pred 1)) . b) > as (< b : ({ a : Bool , c : (< d : B , d : String >) }) , b : (({ d : B , b : Float }) -> (< d : A , c : B >)) >))
((fix (let e = 2 in c)) . d)
(\ d : ((< e : ({ a : String , a : (Unit -> B) }) , c : (Rec B . Unit) >) -> (Rec C . Float)) . ((case "boy" of < a = d > => b | < a = b > => 2) . d))
(succ (if ({ b = false , c = 0 }) then (pred 2) else (succ b)))
(fix (let e = (case (let a = c in a) of < e = d > => (case "apple" of < e = c > => a | < e = b > => 0) | < e = d > => (pred a)) in ((if (c . e) then (iszero unit) else (let a = "apple" in 0)) . a)))
((succ (succ (succ "apple"))) ({ c = (fix a) , c = (iszero 1) }))
(\ e : (((Rec C . Float) -> Float) -> ({ c : B , e : Nat })) . (\ b : ({ d : A , a : Float }) . ({ c = b , d = b })))
(unfold [ (< a : (Rec A . C) , a : (Rec C . (< b : Bool , b : String >)) >) ] (< a = (case b of < a = a > => 0 | < d = a > => false) > as ({ d : Nat , a : Nat })))
((if (false as (Rec A . Nat)) then (< d = true > as (Rec B . Float)) else ((if 0 then "boy" else 2) . a)) (pred (let c = b in b)))
((case ({ b = a , c = c }) of < e = e > => (pred "apple") | < b = d > => (unfold [ B ] "boy")) . e)
(< c = ((false . a) (< e = (if a then true else 0) > as Unit)) > as (((C -> Float) -> (Rec C . String)) -> ({ b : (< c : Float , b : B >) , d : ({ b : String , b : Nat }) })))
(fix ((iszero "apple") (unfold [ (String -> Bool) ] (fold [ C ] "boy"))))
((fold [ ({ a : A , a : Float }) ] (if 1 then 2 else (true as B))) (< c = ({ a = a , b = 2 }) > as (< c : (A -> Unit) , c : ({ d : Float , b : A }) >)))
(succ (case (case (fold [ ({ d : Nat , d : Nat }) ] c) of < d = e > => (iszero a) | < e = c > => (if c then 1 else a)) of < b = e > => (unfold [ ({ e : Float , b : B }) ] (let e = true in a)) | < e = c > => (pred (case 2 of < d = a > => "apple" | < b = b > => "boy"))))
(iszero (((iszero c) . b) as (< b : (< c : Nat , c : A >) , b : Bool >)))
(let a = (if (if false then (iszero "apple") else ({ e = "apple" , d = true })) then ((fold [ String ] "apple") as (Rec A . A)) else (\ d : ({ c : (< e : Bool , c : Unit >) , b : String }) . (fix 0))) in (\ b : (< b : (Rec A . String) , e : (Rec A . Unit) >) . (unfold [ Unit ] unit)))
(fix (\ e : (A -> ({ c : Unit , b : Unit })) . (succ c)))
((let e = (fold [ (Float -> Float) ] ((iszero false) as Bool)) in (case (< e = 0 > as C) of < e = e > => ("apple" . c) | < c = e > => (let a = false in 2))) ((if (0 (fold [ B ] c)) then (succ unit) else (\ a : C . 0)) as ((Unit -> Float) -> ({ d : B , e : A }))))
((unfold [ ({ a : A , c : Nat }) ] (if 0 then "apple" else 0)) (fold [ ((Float -> Nat) -> (Rec E . Nat)) ] (unfold [ (Unit -> B) ] (case "apple" of < b = a > => "boy" | < c = e > => a))))
(\ b : (({ b : Unit , c : Nat }) -> (< c : (< b : A , b : String >) , c : (Rec A . String) >)) . (if (pred b) then (unfold [ Unit ] 1) else (< e = 1 > as Float)))
(let d = (< c = (({ e = c , e = c }) . b) > as (String -> String)) in (pred (pred (pred unit))))
(iszero (let b = ((succ "boy") . a) in (succ "apple")))
((fold [ ({ b : (A -> Float) , e : (Rec D . C) }) ] (fix (succ a))) ((\ a : A . "apple") . b))
(let d = (if ((< e = false > as C) . c) then (1 . e) else (fold [ String ] c)) in (\ d : ((Bool -> String) -> (Rec D . Nat)) . (true as (Rec A . A))))
(((fix c) (fold [ Bool ] c)) . d)
({ d = (succ (iszero "apple")) , e = (case (pred unit) of < b = a > => (< e = 1 > as A) | < a = c > => (iszero (2 a))) })
(if (let e = ((unfold [ B ] "apple") as String) in (pred "apple")) then ((succ c) as ({ e : Float , d : Float })) else (if (fold [ Unit ] false) then (< b = b > as (< d : A , e : Nat >)) else ({ b = true , a = unit })))
(fold [ (({ b : B , a : Float }) -> (Bool -> Bool)) ] (unfold [ (< a : ({ d : Float , b : B }) , c : (Rec D . Float) >) ] (if ({ d = "apple" , b = 1 }) then (if 2 then "boy" else "boy") else 0)))
(pred (< c = (unfold [ ({ d : Unit , c : String }) ] ("boy" as Unit)) > as (< b : C , c : Float >)))
(let d = (\ c : (Float -> Nat) . ((b as Float) as Nat)) in (let d = (if 0 then c else 0) in (fold [ B ] b)))
(let e = (\ c : (< b : (< d : Bool , b : Float >) , a : Unit >) . ({ a = true , c = 2 })) in (< c = (false . c) > as (Rec C . B)))
((succ (1 false)) . d)
(succ (succ ("boy" true)))
(((iszero (pred "boy")) . e) (if ((fold [ Nat ] 0) as (Rec D . B)) then (succ (unfold [ A ] "boy")) else (if (let e = (case false of < b = d > => b | < c = e > => true) in (unfold [ Bool ] b)) then (< e = (succ b) > as (Unit -> C)) else (let d = 2 in b))))
(case (\ b : ({ b : Float , e : Float }) . (case 0 of < a = e > => 2 | < c = b > => 2)) of < b = a > => (fix (fold [ (Rec A . String) ] "apple")) | < b = b > => (< d = ({ e = b , c = c }) > as ({ d : Bool , b : B })))
(fix ((let a = (succ 2) in c) . b))
(\ b : (< c : ({ c : C , e : Bool }) , b : (B -> Nat) >) . ((< e = "apple" > as Nat) . b))
(if (\ c : (C -> ({ a : C , b : B })) . ((0 true) . c)) then ((< a = 2 > as Float) (a as (Unit -> A))) else ((fold [ (Float -> B) ] (iszero (fold [ Float ] "apple"))) ((b 0) as (< c : Bool , a : String >))))
(pred (< e = (if ((c as B) . c) then (succ "apple") else (case a of < e = c > => a | < c = d > => (fix 2))) > as ({ c : (< b : C , c : Float >) , c : (Rec D . C) })))
(fold [ ((({ a : Float , e : Bool }) -> (Rec A . B)) -> (Rec C . ({ b : A , c : Float }))) ] (fold [ (Rec C . Bool) ] (\ c : (B -> A) . unit)))
(\ b : ({ b : (Nat -> B) , c : (Unit -> (< c : B , d : A >)) }) . ((succ (let e = "boy" in c)) (let a = (fix 1) in (let e = a in 0))))
(fix (let e = (succ (unfold [ Nat ] 1)) in ((iszero (fold [ Unit ] 1)) (unfold [ C ] (succ 0)))))
(< d = (iszero (pred (2 1))) > as ({ b : (Rec B . (< a : B , c : C >)) , e : ((< b : Bool , c : Nat >) -> ({ c : C , b : String })) }))
(let b = (((case unit of < b = a > => b | < b = d > => true) as Bool) (iszero (fix false))) in (unfold [ ({ b : (Rec E . B) , c : ({ a : C , d : B }) }) ] (let e = 2 in (< c = "apple" > as Bool))))
((case (b true) of < a = d > => (iszero 1) | < b = b > => (fix a)) . d)
(iszero (iszero (if (succ c) then (unfold [ (Rec C . Float) ] (0 false)) else ({ c = 1 , a = unit }))))
(fix (succ ("boy" as Unit)))
(let d = (pred (fold [ Nat ] true)) in (pred (fix (fold [ Bool ] b))))
(if (succ (unfold [ C ] (case "boy" of < e = d > => 1 | < c = e > => 1))) then (pred (if "boy" then "boy" else 2)) else ((succ (c . d)) (iszero (< a = 1 > as String))))
(((unfold [ (C -> B) ] (2 "apple")) as ({ a : C , a : (< e : C , d : Float >) })) . a)
(unfold [ (Rec D . (< b : Bool , c : (Float -> String) >)) ] (let e = (fix (case (unfold [ C ] a) of < b = d > => 0 | < a = d > => unit)) in ((pred 2) as ((C -> Unit) -> (B -> Float)))))
(if ((fold [ ({ b : String , e : Nat }) ] (succ (succ 0))) (iszero (fold [ String ] false))) then (((iszero 0) (< c = b > as Float)) (fold [ (< a : Bool , a : String >) ] ("apple" . d))) else (succ ((< b = true > as C) (\ b : B . unit))))
(case (succ (iszero (\ c : B . 2))) of < b = d > => ((let c = "apple" in c) (let c = (let c = unit in a) in (if b then "boy" else 1))) | < e = e > => (\ d : (({ a : C , a : B }) -> ({ e : C , b : Bool })) . (fold [ (Rec E . Bool) ] (< c = true > as Unit))))
(if (let b = (case (unit 1) of < e = c > => (\ b : ({ b : String , c : C }) . (if "boy" then 2 else true)) | < d = e > => (\ a : Unit . "boy")) in (succ (let b = unit in c))) then (fix ({ b = (iszero 1) , b = b })) else (fix (fold [ (String -> A) ] (2 . e))))
(succ ((pred (case b of < e = a > => a | < e = d > => unit)) . b))
(\ a : ({ b : (< d : String , c : B >) , b : ({ d : (< d : Unit , d : Bool >) , d : (Rec D . Bool) }) }) . (case (iszero 2) of < b = d > => ({ c = ({ d = b , b = "apple" }) , e = (fix 0) }) | < b = e > => (succ (fold [ Unit ] b))))
(< e = (fix (case "boy" of < e = d > => true | < c = a > => unit)) > as (< c : ({ e : (Rec E . Bool) , e : ({ c : C , a : String }) }) , a : (Rec E . C) >))
(((case c of < c = a > => a | < e = b > => (b . d)) (< b = false > as (String -> A))) . a)
(fix ({ b = (case (if c then 2 else a) of < c = d > => 2 | < c = d > => 1) , a = ("boy" . c) }))
(if (case (if (iszero 2) then (succ unit) else "boy") of < d = a > => (iszero (fold [ String ] false)) | < e = e > => (< e = b > as Nat)) then (\ e : (< c : Unit , c : Float >) . (({ a = "apple" , a = unit }) c)) else (if (if (iszero a) then (fix unit) else (fix unit)) then (({ c = "apple" , b = 2 }) as (C -> A)) else (pred ({ e = (fold [ String ] c) , c = 2 }))))
(succ (fix ({ d = (if b then (succ false) else (1 . b)) , e = ({ c = 1 , c = unit }) })))
(unfold [ (Rec E . (Rec A . B)) ] (iszero (succ a)))
(succ (case (\ b : (< c : C , e : Unit >) . (succ (< b = 1 > as Nat))) of < a = c > => (\ e : B . (if b then c else unit)) | < a = b > => ({ e = (0 (false as B)) , e = (if c then true else c) })))
(case (if (fold [ Unit ] (succ 1)) then (< a = b > as String) else (unfold [ Nat ] true)) of < e = a > => ((\ c : ({ d : C , d : Bool }) . (case (unit . b) of < e = a > => (c . b) | < a = b > => 0)) (\ b : String . 0)) | < e = c > => ((iszero (< b = b > as Nat)) as ((Rec C . A) -> (< b : Nat , b : Nat >))))
(case (fix ((< c = "boy" > as Float) . a)) of < a = e > => ({ e = (\ c : A . (if "apple" then 0 else 2)) , a = (let c = unit in c) }) | < a = c > => (fold [ (Rec D . Float) ] (\ a : (< d : Nat , c : C >) . (unfold [ (< b : A , d : A >) ] (< b = b > as B)))))
(iszero ((let c = (< a = unit > as Bool) in (iszero ("apple" as Float))) (fix (iszero true))))
(iszero (iszero ({ b = (unfold [ Bool ] "apple") , b = ({ c = unit , c = c }) })))
(if (succ (succ true)) then (let b = (fold [ (Rec D . ({ d : B , c : B })) ] (if false then 1 else 0)) in ({ d = (< e = false > as Float) , e = false })) else (let c = (pred b) in (2 . b)))
(fold [ (< c : (< b : Float , a : Nat >) , e : (Rec E . A) >) ] (fold [ ({ d : Float , e : String }) ] (case b of < d = e > => (pred true) | < d = e > => false)))
(fix (if (false . c) then (let c = b in b) else (let d = ({ a = unit , a = "apple" }) in (fix 0))))
(unfold [ (Rec C . ({ b : (C -> C) , d : B })) ] (iszero (succ ("boy" true))))
(pred (pred ((\ a : String . true) . d)))
(< b = (< a = ({ b = (fold [ B ] b) , c = (unfold [ Nat ] 2) }) > as (< d : ({ e : String , c : Unit }) , a : B >)) > as (< d : (B -> Nat) , e : ({ c : B , a : Float }) >))
(pred (< d = (let b = true in 1) > as ({ a : (< d : (< b : Bool , b : String >) , e : (Rec E . Float) >) , a : (Rec E . C) })))
(let d = (unfold [ ({ b : Nat , c : C }) ] (fix (fold [ Float ] b))) in (fold [ (< d : String , c : Bool >) ] (succ (if 1 then b else "apple"))))
(< c = ((fold [ (Unit -> Unit) ] a) . a) > as (< c : ((< c : String , b : String >) -> ({ c : Float , d : C })) , b : (Rec B . (Rec C . A)) >))
(\ d : (< a : (Rec E . Bool) , c : ({ e : (Unit -> C) , c : (< a : String , b : Unit >) }) >) . (fix ({ a = true , e = false })))
(iszero (({ e = (succ 0) , e = "boy" }) ({ a = (unit . e) , c = "boy" })))
(let e = ((pred (< c = b > as Bool)) . a) in ((fold [ B ] 1) (let a = (case c of < c = b > => c | < c = a > => 0) in "boy")))
((succ (b . b)) . e)
(unfold [ (Rec C . (Rec A . String)) ] (unfold [ (Unit -> Unit) ] (unfold [ C ] (< c = b > as A))))
(< c = (succ (succ (0 as Bool))) > as (< b : ({ c : (Rec C . Unit) , e : (B -> C) }) , e : ({ a : ({ c : Bool , e : (String -> B) }) , c : (Rec A . Unit) }) >))
(fold [ (< a : ({ e : (Rec A . C) , c : ({ a : Bool , a : Float }) }) , b : ({ b : (String -> A) , a : (< d : B , d : B >) }) >) ] (case ({ a = (case a of < d = a > => "boy" | < b = a > => 1) , b = 2 }) of < c = c > => (true . e) | < e = a > => (pred (iszero false))))
(case (fold [ (({ b : Nat , d : Bool }) -> (Float -> Float)) ] (succ b)) of < c = e > => (iszero (iszero true)) | < d = c > => ((iszero (\ b : Nat . false)) . c))
((pred (if a then true else true)) . a)
(< b = ((if true then unit else false) as (Unit -> Float)) > as ({ c : (< a : Nat , b : Unit >) , b : ((Rec A . Unit) -> String) }))
(fix (\ a : ((Rec B . B) -> (< c : Unit , e : A >)) . ({ c = 0 , e = 2 })))
((pred (case (case "boy" of < e = c > => c | < d = b > => 1) of < d = a > => ({ a = "apple" , a = "apple" }) | < a = e > => (if 2 then 1 else "boy"))) . b)
(if ((unfold [ Unit ] "apple") (case ({ d = false , e = unit }) of < c = e > => (fold [ B ] b) | < c = c > => (if "apple" then a else "apple"))) then (succ (\ b : (A -> Unit) . (case c of < e = e > => b | < d = c > => true))) else (\ e : ({ c : (Float -> C) , e : String }) . (< e = b > as Nat)))
(if (fold [ (< b : A , a : (B -> C) >) ] (iszero 1)) then (pred (unfold [ (String -> Unit) ] (case unit of < d = b > => c | < d = b > => b))) else (succ (fix (iszero "boy"))))
(if (< c = (\ d : Nat . b) > as (String -> Nat)) then ((< e = (succ a) > as B) . b) else (fold [ (Unit -> B) ] (fold [ Unit ] 2)))
(({ b = (\ c : Nat . b) , e = (iszero true) }) as (< e : (({ d : Unit , d : Bool }) -> (< c : ({ d : Float , d : A }) , d : ({ e : Nat , c : Unit }) >)) , a : (Rec E . ({ d : A , d : C })) >))
(case (let e = (pred ({ e = 0 , e = b })) in (pred (2 1))) of < b = b > => (case (case 1 of < a = d > => "boy" | < c = a > => false) of < a = d > => (unfold [ Unit ] (fix true)) | < d = b > => (fold [ (B -> String) ] true)) | < e = c > => ((fix 2) (case false of < a = b > => a | < e = d > => b)))
(if (fold [ ({ e : (< c : ({ c : Bool , b : C }) , d : String >) , e : (Rec C . Nat) }) ] ((< a = (if 2 then c else "apple") > as Bool) (iszero true))) then (pred (case b of < c = a > => (succ 1) | < c = a > => (fold [ Unit ] 2))) else (fold [ (< e : (< a : String , b : A >) , a : Float >) ] ("apple" . b)))
(fold [ (Rec E . (({ e : Float , b : B }) -> (Rec E . Float))) ] (let d = (let d = c in (< d = 2 > as Float)) in (let e = "apple" in (pred 0))))
((unfold [ (A -> ({ a : Float , e : Unit })) ] (pred b)) . d)
(fold [ (Rec E . ({ d : Float , d : A })) ] (iszero (fold [ A ] a)))
((let e = ({ a = (< c = false > as Float) , a = (case c of < e = b > => "boy" | < e = b > => 1) }) in (< a = (pred 0) > as (Rec B . B))) (succ ((0 as Nat) as (Rec E . Float))))
((fold [ (< d : Unit , a : (Rec C . Nat) >) ] ("boy" (pred false))) . d)
(if ((unfold [ C ] 0) as ({ c : (< d : C , e : Unit >) , a : Unit })) then (unfold [ (Rec D . Bool) ] (true . e)) else (< c = (b . d) > as ({ d : A , c : Bool })))
(((succ true) (iszero (unit as (Rec B . Nat)))) as ({ e : (< e : Bool , d : A >) , a : (Rec A . ({ c : Float , b : Bool })) }))
(fix (\ a : (C -> (C -> B)) . (unfold [ (< d : A , a : Unit >) ] b)))
(let c = (case (unit . e) of < d = b > => (case unit of < d = a > => 2 | < a = d > => (c 1)) | < e = a > => (false unit)) in (fold [ (Rec E . ({ a : Nat , b : C })) ] (fix true)))
(((succ a) as (Rec A . (< e : A , d : C >))) . b)
({ b = ((fold [ B ] 0) as (Rec B . Float)) , e = (\ a : (Rec A . (< e : Bool , c : Float >)) . (let a = "boy" in 2)) })
(\ e : ({ a : ({ d : Nat , b : A }) , a : ({ e : (< e : Float , e : Nat >) , b : A }) }) . (< b = (pred ("apple" as A)) > as (< e : (< e : String , c : String >) , a : ({ d : Bool , b : Float }) >)))
(< d = (\ e : ({ a : Bool , a : (C -> C) }) . (b . c)) > as (< b : (({ b : (Rec B . A) , d : (< b : A , d : B >) }) -> (B -> (Bool -> Unit))) , c : (Rec A . Float) >))
(let c = (case (0 c) of < d = d > => (false 0) | < e = b > => (if c then false else 0)) in (((\ d : Float . a) as String) as (Bool -> Bool)))
(((fold [ C ] "boy") as ({ c : Unit , e : A })) (pred (unfold [ Unit ] c)))
(if ((let d = (2 . d) in (\ e : A . 2)) (if (0 2) then (succ b) else "boy")) then (< c = (let d = (pred unit) in c) > as (Rec D . Nat)) else (pred (let a = false in a)))
(((< b = true > as B) . b) . d)
(fold [ (< d : (< e : Unit , b : Float >) , a : ({ d : Float , c : Nat }) >) ] (unfold [ (Rec A . C) ] (fold [ Nat ] b)))
(((fold [ String ] b) . c) (< d = (\ e : A . false) > as ((Float -> String) -> C)))
({ b = (if (case ({ b = (succ false) , c = 1 }) of < b = b > => (fold [ (B -> Nat) ] (let b = "boy" in 1)) | < e = e > => (if "apple" then (2 as Bool) else a)) then (\ b : (< a : A , b : Nat >) . 1) else (\ e : ({ b : String , e : Nat }) . a)) , b = (fix (case (\ a : A . c) of < c = c > => (pred a) | < e = e > => (case (unfold [ Unit ] false) of < a = d > => 2 | < c = b > => (a . e)))) })
({ e = (iszero (case c of < c = d > => false | < a = b > => 1)) , c = (\ b : (Nat -> B) . (succ ({ e = c , e = 0 }))) })
({ d = (\ b : ({ a : B , d : A }) . ({ e = c , e = c })) , e = (if (fix c) then ({ d = false , e = "boy" }) else (unfold [ Bool ] true)) })
(fix (let a = (\ c : (Rec A . (Rec C . Unit)) . (< e = b > as Nat)) in (succ false)))
(((let b = (< d = (iszero 0) > as B) in (case c of < a = e > => b | < b = b > => "apple")) (case (0 . b) of < e = c > => (\ c : (A -> String) . unit) | < a = d > => ("apple" . b))) (if (case ({ e = b , e = 0 }) of < d = d > => true | < d = e > => b) then (let d = (case 0 of < e = a > => (true . d) | < e = b > => (fold [ Bool ] c)) in (fix 1)) else (fold [ ({ c : ({ a : C , b : String }) , e : (String -> Nat) }) ] (pred (pred 1)))))
((fold [ (< c : Nat , b : (Unit -> Nat) >) ] ((true as Bool) (< c = b > as Nat))) as (Rec E . (Rec B . (A -> Nat))))
({ a = ((fold [ (Rec A . String) ] (pred false)) (succ (case "apple" of < a = b > => false | < e = b > => "apple"))) , a = (fold [ ({ e : (Float -> Float) , a : (< b : Nat , c : Float >) }) ] (fix (fix 1))) })
(\ d : (Rec C . ((Float -> Float) -> (< c : B , b : B >))) . (< a = ({ b = 0 , e = 1 }) > as (< d : (String -> B) , a : (< c : Nat , e : String >) >)))
(fold [ ({ d : (Rec B . A) , e : ((< e : Float , c : C >) -> (< d : String , b : String >)) }) ] (fold [ (Rec A . A) ] (succ (unfold [ ({ a : A , c : B }) ] c))))
(< b = (case (unit as Bool) of < d = e > => (2 as Bool) | < e = d > => (unfold [ (Rec D . Unit) ] (fix 0))) > as (((Float -> A) -> (Rec E . ({ c : String , b : B }))) -> ((Rec A . Bool) -> (Unit -> Bool))))
((fold [ (String -> (< e : Unit , a : Float >)) ] (iszero (unfold [ String ] "apple"))) as (Rec D . (String -> (String -> C))))
(pred ({ e = (b ({ e = "boy" , a = 2 })) , c = (fix false) }))
(let c = (if (if (case c of < e = a > => false | < c = c > => c) then (pred 0) else ({ c = "apple" , d = a })) then ((unit . c) as (< d : ({ c : A , b : C }) , c : A >)) else (fix (iszero "apple"))) in (unfold [ ({ e : A , e : Float }) ] (pred false)))
(\ b : (< c : ({ d : ({ d : B , a : B }) , c : ({ a : B , b : Float }) }) , e : (< a : (Rec D . String) , c : (C -> (Rec B . Nat)) >) >) . (pred (\ e : Float . b)))
(fix (if (< d = (< b = false > as Bool) > as ({ c : Float , b : Nat })) then (\ d : (< e : A , d : B >) . unit) else (\ a : (Rec B . Bool) . (fix (succ 1)))))
(pred (fix (let d = 0 in unit)))
(fix (iszero ({ a = b , d = 0 })))
((pred ({ d = b , a = b })) (succ (unfold [ String ] (fold [ String ] false))))
(if (iszero (fix true)) then (case ((true unit) (iszero b)) of < a = c > => (iszero c) | < c = e > => (iszero "boy")) else ((iszero b) . e))
({ a = (fold [ (< a : String , d : Nat >) ] ((fold [ A ] false) as (< b : String , c : C >))) , b = ((fold [ Bool ] "boy") (\ a : Unit . a)) })
(succ ((unfold [ ({ d : (< b : Unit , b : B >) , b : C }) ] ({ a = c , c = 0 })) . e))
(< e = (< e = ({ b = (unfold [ ({ e : Bool , c : A }) ] "apple") , c = (fix true) }) > as (< a : (Rec C . Nat) , d : ({ e : B , b : C }) >)) > as ({ e : (Rec B . C) , c : ({ d : (< a : C , e : Nat >) , c : ({ d : Bool , e : (Rec D . B) }) }) }))
(< c = (fold [ (Rec A . (< c : ({ d : B , c : Bool }) , e : String >)) ] ((fix c) as Bool)) > as ({ a : (({ a : (< d : B , a : B >) , e : Float }) -> ({ b : A , e : Bool })) , b : ((Rec E . String) -> ((< a : Nat , a : Nat >) -> (Rec D . Nat))) }))
(pred (unfold [ (String -> (Rec A . Unit)) ] ((pred false) as (String -> C))))
((fix (let b = (pred 0) in (iszero unit))) (((fold [ String ] false) . b) . e))
(if (succ ((unfold [ Unit ] "boy") . d)) then (succ (iszero (\ b : Float . 1))) else (fix (if (fold [ A ] "apple") then ((if false then unit else unit) as Nat) else (unfold [ ({ b : A , d : Bool }) ] a))))
(let c = (iszero (succ false)) in (pred ((\ d : Bool . true) . a)))
(iszero (unfold [ ({ c : ({ d : String , d : Nat }) , c : A }) ] (1 . c)))
(fix (< e = (((< e = true > as Bool) 2) . e) > as (Rec D . ({ d : A , d : Float }))))
(\ e : (Rec E . (< b : Float , b : C >)) . (succ ({ c = (fix "boy") , a = "apple" })))
((case (case (< e = 1 > as (< d : B , d : Unit >)) of < e = a > => ((c as B) as (Rec E . Bool)) | < b = d > => (case b of < c = c > => b | < e = c > => c)) of < e = e > => ({ c = ({ e = b , c = unit }) , e = (let d = true in 2) }) | < d = d > => (iszero (< b = 0 > as Bool))) as ({ d : ({ c : Nat , a : ({ b : C , a : Bool }) }) , b : ({ e : A , b : String }) }))
(fix (case (if 1 then 1 else (succ 1)) of < e = e > => (unfold [ Bool ] true) | < d = a > => ("boy" as String)))
(iszero (case (unfold [ (Rec A . (< a : C , e : C >)) ] (pred unit)) of < e = d > => ({ d = ((pred c) as (< c : String , e : String >)) , c = (\ e : (Rec E . Unit) . c) }) | < d = e > => (case (1 . d) of < c = c > => (2 as A) | < a = a > => (< d = "apple" > as C))))
(fold [ (< b : (({ d : Float , b : A }) -> (Float -> String)) , c : ((Unit -> C) -> ({ d : A , b : String })) >) ] (iszero (iszero true)))
(pred (pred (0 (false as A))))
(((case (\ b : Float . "boy") of < c = b > => ("boy" as (Rec A . A)) | < d = e > => (fold [ A ] 2)) as (< a : (< d : Unit , a : Nat >) , b : (Bool -> Nat) >)) ({ d = (pred c) , c = (fold [ Unit ] "boy") }))
(iszero (succ (unit as Float)))
(pred (< a = (case c of < c = b > => "apple" | < c = e > => 1) > as (Unit -> A)))
(pred (iszero (\ d : Nat . "apple")))
(fix ({ a = (let e = (pred (false . b)) in (fold [ (< c : Float , d : Unit >) ] a)) , c = (iszero (let a = 1 in "boy")) }))
(if (if (if true then "apple" else unit) then ((pred unit) as (Rec D . Bool)) else (pred 1)) then ((\ a : (C -> A) . unit) as (C -> String)) else ({ a = (false as (Rec E . A)) , c = ({ e = true , c = "apple" }) }))
(< b = (iszero (if c then unit else unit)) > as ({ d : ({ c : (Float -> A) , d : (Rec D . Float) }) , d : (< e : ({ a : Unit , c : A }) , a : (< b : Nat , e : Unit >) >) }))
(succ (if (succ c) then (succ ("boy" false)) else ((succ 0) (case (iszero a) of < d = d > => (a c) | < d = b > => (0 unit)))))
((iszero (case (true (case a of < a = d > => false | < a = e > => 0)) of < a = a > => (pred 1) | < c = e > => (\ a : A . unit))) (if (unfold [ Nat ] unit) then (\ c : (< e : Float , e : A >) . (< d = 1 > as Unit)) else (if (unfold [ Unit ] "boy") then (succ true) else b)))
(pred (iszero (unfold [ C ] 2)))
(< e = (case (pred (\ d : Float . true)) of < c = d > => (fold [ B ] (\ c : String . "boy")) | < a = c > => ({ a = c , e = a })) > as (< c : ({ e : (Rec D . C) , d : Bool }) , d : (< c : ({ c : ({ a : Bool , d : A }) , a : (Rec D . Bool) }) , c : (Rec B . (Rec C . Unit)) >) >))
((succ ({ c = (unit . e) , a = ({ d = 0 , d = unit }) })) ({ d = (case (fold [ Nat ] 0) of < d = d > => 1 | < b = d > => ("boy" as A)) , d = (< e = (unfold [ Bool ] (let d = true in false)) > as (String -> String)) }))
(((iszero (unit . c)) as (Rec E . (Rec B . Unit))) . d)
(case (case (case 2 of < e = e > => c | < d = d > => c) of < c = e > => (\ b : B . a) | < e = c > => (\ b : Nat . b)) of < b = a > => ((if "apple" then c else true) as (({ a : Float , b : String }) -> (Rec D . C))) | < b = c > => (if (succ (unit b)) then (c . a) else (succ a)))
(((succ false) (iszero unit)) (< a = (case false of < d = d > => (fix a) | < e = a > => unit) > as (< a : (< c : Unit , e : B >) , e : A >)))
(fold [ ((C -> Bool) -> (< d : (Rec B . Unit) , c : (< c : Nat , a : Nat >) >)) ] (pred (if c then unit else 1)))
